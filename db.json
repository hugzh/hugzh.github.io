{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/douban.png","path":"img/douban.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/delicious.png","path":"img/delicious.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/facebook.png","path":"img/facebook.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/github.png","path":"img/github.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/google.png","path":"img/google.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/mail.png","path":"img/mail.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/rss.png","path":"img/rss.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/twitter.png","path":"img/twitter.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/weibo.png","path":"img/weibo.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/js/instagram.js","path":"js/instagram.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/js/mobile.js","path":"js/mobile.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/js/pc.js","path":"js/pc.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":1,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/author.jpg","path":"img/author.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"76d4ee8048c30ebf20549391ac08dc1743ff9e47","modified":1471057724505},{"_id":"themes/yilia/README.md","hash":"8648a81b3ae08a4accd6b0541533e662511e6400","modified":1471057725095},{"_id":"themes/yilia/_config.yml","hash":"e7c4ad252ddcc744189c38d469c0689a161f4567","modified":1471057934994},{"_id":"themes/yilia/package.json","hash":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1471057725160},{"_id":"source/_posts/2015-08-15-javascript之Location对象.md","hash":"80dcca8f934c523bb7813c5f55c82db9ced3e59a","modified":1471057724506},{"_id":"source/_posts/2015-09-02-Flexbox-布局.md","hash":"2fb795f5a759b3f209aa8b9ca03868eabdf34b21","modified":1471057724507},{"_id":"source/_posts/2015-09-11-React-js那些事-介绍篇.md","hash":"5f0774f98906bbf5e680a45c7f8b0a61c54a3716","modified":1471057724509},{"_id":"source/_posts/2015-09-14-React-js那些事-入门篇.md","hash":"146734e034af129536b2e35791004b6e7b2dd741","modified":1471057724510},{"_id":"source/_posts/2015-10-07-React-js那些事-core篇.md","hash":"ebcfa5aa1c372581107668287c3c65820d92699e","modified":1471057724511},{"_id":"source/_posts/2015-12-09-单元测试工具Mocha和SuperTest组合.md","hash":"820511c937672c85f5a4176eea8842697fc0bca2","modified":1471057724529},{"_id":"source/_posts/Flexbox-布局.md","hash":"473049b7fac01bd322ee1e699d6c984b4572a1a5","modified":1471057724530},{"_id":"source/_posts/JavaScript高阶函数之currying和uncurrying.md","hash":"387fdba5dbb0a8b55720e18ffc08718e0a2dc0ea","modified":1471057724531},{"_id":"source/_posts/React-js那些事-core篇.md","hash":"ebcfa5aa1c372581107668287c3c65820d92699e","modified":1471057724532},{"_id":"source/_posts/React-js那些事-介绍篇.md","hash":"5f0774f98906bbf5e680a45c7f8b0a61c54a3716","modified":1471057724532},{"_id":"source/_posts/React-js那些事-入门篇.md","hash":"146734e034af129536b2e35791004b6e7b2dd741","modified":1471057724533},{"_id":"source/_posts/Vue初接触实战之账单组件.md","hash":"09a2bd5ae2adcee58803335e11bf42d0299a2a72","modified":1471078807031},{"_id":"source/_posts/cleaver-make-ppt.md","hash":"26611bd27a1ae586d832a145d51950315e015559","modified":1471057724534},{"_id":"source/_posts/from-ajax-to-seo.md","hash":"e3699237728808f61d4249135b740d1621e14d71","modified":1471057724535},{"_id":"source/_posts/haskell-introduce.md","hash":"2452845fbe39b066e963831940639b2676f5ac27","modified":1471057724536},{"_id":"source/_posts/html5-placeholder.md","hash":"6ffb26e7b26fb4a1ead44c4071ca1ffa2b2e7fab","modified":1471057724536},{"_id":"source/_posts/javascript-op.md","hash":"f570b9c861fb0f38abdbe6e9cba39dece7331681","modified":1471057724537},{"_id":"source/_posts/javascript之Location对象.md","hash":"80dcca8f934c523bb7813c5f55c82db9ced3e59a","modified":1471057724548},{"_id":"source/_posts/jmobile-use-1.md","hash":"f10613317e993b309db089c5c6cfbd0705f0147f","modified":1471057724548},{"_id":"source/_posts/jmobile-use-2.md","hash":"93341bd95fd9a5e7d7a04bf4bb310c3561bd85ce","modified":1471057724549},{"_id":"source/_posts/one-interview-closure.md","hash":"4c110b047788de48276db5995c1c6c4011e9b62c","modified":1471057724550},{"_id":"source/_posts/node-spider.md","hash":"3e31a55d17eac3633998f796aa58ccdfaf98355c","modified":1471057724549},{"_id":"source/_posts/problem-of-hash.md","hash":"bba5eff67a6eec4a44ecc584a863641c414c488f","modified":1471057724550},{"_id":"source/_posts/socket.io搭建多聊天室.md","hash":"644832bd92770b473da688aa8b0727c2ce03cdb9","modified":1471057724551},{"_id":"source/_posts/uploadyfy-introduce.md","hash":"04b75c53fc8440d288477054a1a903396fbd043e","modified":1471057724551},{"_id":"source/_posts/webpack学习实践系列-一.md","hash":"18a9e149bd47d302557f435aa5aea168f82fe564","modified":1471057724552},{"_id":"source/_posts/yanzhengma-php.md","hash":"e1f2ed0a1fb0e0f97a4f91fb764403ae0d761a7a","modified":1471057724553},{"_id":"source/_posts/一个应届生对近来前端界流派之争的一点思考.md","hash":"82fed0e73365dd92bc01ac77ba36a62792a1847a","modified":1471057724567},{"_id":"source/_posts/关于软件工程的一点感想——以前端为例.md","hash":"fb8c0c08f5b0fe20a1db3d1656d44baceb8c8c9b","modified":1471057724568},{"_id":"source/_posts/前端笔试面试中的常用到的CSS知识点总结.md","hash":"6874ba0a1b34066d4f9e32a3bc80ba911cbeb590","modified":1471057724569},{"_id":"source/_posts/单元测试工具Mocha和SuperTest组合.md","hash":"b97af7a79a35956a5aafb19567408f7b66dc7fe7","modified":1471057724569},{"_id":"themes/yilia/languages/de.yml","hash":"bc80f78f61c3d7af9652e6aa6fc3e4ff39b0c8d3","modified":1471057725099},{"_id":"themes/yilia/languages/default.yml","hash":"f0a7a032b31555c9ec05a711e1ac19bb07724708","modified":1471057725100},{"_id":"themes/yilia/languages/en.yml","hash":"a093e794aef63ec9e9e9ef490cf7e4474e45e59f","modified":1471057725101},{"_id":"themes/yilia/languages/fr-FR.yml","hash":"04b9a0d80d88d01e039e8077afe88f741e9620ba","modified":1471057725103},{"_id":"themes/yilia/languages/ru.yml","hash":"62f84ea82a696060c481fc22d4742e6201bb9bdc","modified":1471057725104},{"_id":"themes/yilia/languages/zh-Hans.yml","hash":"d2336578e14bb880d152266981c2b17523fc8742","modified":1471057725118},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"005559baa96b7bb34e1efe6b031829a95d58d5e0","modified":1471057725119},{"_id":"themes/yilia/languages/zh-hk.yml","hash":"e702fc43556e54c396917bdf7c869d528742e28b","modified":1471057725118},{"_id":"themes/yilia/layout/.DS_Store","hash":"693e513b44d5241ea897cc90cc71aeba091283b9","modified":1471057725120},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1471057725142},{"_id":"themes/yilia/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1471057725143},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1471057725142},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1471057725153},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1471057725154},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1471057725154},{"_id":"themes/yilia/layout/layout.ejs","hash":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1471057725152},{"_id":"themes/yilia/layout/_partial/.DS_Store","hash":"e32979f5a18bff84e197c13b48f4c54e03796e4a","modified":1471057725121},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"5b29a383418cfdcf8d5c5719b4fc4608aaba6fe7","modified":1471057725123},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"3709af4e8f7e1196dbd1f9dea62fa440d4b47836","modified":1471057725122},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"420b94c78832456686ebd9831a5bfcb05365645a","modified":1471057725130},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1471057725130},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1471057725131},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1471057725132},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"2bbf5aad03f54055d9d7852e70ff7e6952a41f26","modified":1471057725132},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1471057725133},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"b03e8424b4798d4887801afdfae457fbf6027838","modified":1471057725134},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"7be03a92dabeb2f94bf0e731d12a1c1146d736dd","modified":1471057725134},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"6a7a2a4960dabf9d7cd523573da7869eebf4b02d","modified":1471057725135},{"_id":"themes/yilia/source/css/.DS_Store","hash":"fc5a428fe40854a0ba66b4cea196c6700a57cae7","modified":1471057725161},{"_id":"themes/yilia/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1471057725162},{"_id":"themes/yilia/source/css/_variables.styl","hash":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1471057725181},{"_id":"themes/yilia/source/css/style.styl","hash":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1471057725245},{"_id":"themes/yilia/source/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1471057725273},{"_id":"themes/yilia/source/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1471057725275},{"_id":"themes/yilia/source/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1471057725274},{"_id":"themes/yilia/source/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1471057725278},{"_id":"themes/yilia/source/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1471057725279},{"_id":"themes/yilia/source/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1471057725280},{"_id":"themes/yilia/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1471057725281},{"_id":"themes/yilia/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1471057725281},{"_id":"themes/yilia/source/img/favicon.png","hash":"5a52307766d0fbfb5d62655217edb6f96ade50fa","modified":1471057725279},{"_id":"themes/yilia/source/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1471057725283},{"_id":"themes/yilia/source/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1471057725282},{"_id":"themes/yilia/source/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1471057725283},{"_id":"themes/yilia/source/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1471057725284},{"_id":"themes/yilia/source/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1471057725285},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1471057725285},{"_id":"themes/yilia/source/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1471057725286},{"_id":"themes/yilia/source/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1471057725287},{"_id":"themes/yilia/source/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1471057725287},{"_id":"themes/yilia/source/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1471057725288},{"_id":"themes/yilia/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1471057725246},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1471057725247},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1471057725248},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1471057725256},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1471057725257},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1471057725258},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","hash":"96138eaddfbd305160ddcb98a5f08555ca6cb4ee","modified":1471057725268},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","hash":"004bb0812414554ab48067792f09e978603253b6","modified":1471057725269},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1471057725270},{"_id":"themes/yilia/source/js/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1471057725289},{"_id":"themes/yilia/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1471057725290},{"_id":"themes/yilia/source/js/jquery.lazyload.js","hash":"9c34c37b4dca82386648d364da913153d1db902e","modified":1471057725291},{"_id":"themes/yilia/source/js/main.js","hash":"e2633f282e377a4169649c9f17dc96036ad4fc64","modified":1471057725292},{"_id":"themes/yilia/source/js/mobile.js","hash":"387c047e661f04fbb5f5bfc4b2db617023e836ce","modified":1471057725293},{"_id":"themes/yilia/source/js/pc.js","hash":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1471057725293},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"27fab3e6ccc41c075dc4c5ba3ca9e7f3b6247945","modified":1471057725136},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1471057725137},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"c115c282eebfb6b18612d2d8733272c270b03066","modified":1471057725138},{"_id":"themes/yilia/layout/_partial/post/share_addthis.ejs","hash":"4ab6cab2a975a4df8419448b33dec4724279d85c","modified":1471057725139},{"_id":"themes/yilia/layout/_partial/post/share_jia.ejs","hash":"d50294bf9858e7942208c380e851a37ed37f1d6f","modified":1471057725140},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"acf1b9d79ccec172881f9f0080e96667f4178885","modified":1471057725141},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1471057725141},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"06d8914b5aef73b5ec2cabb0105e275ff821b321","modified":1471057725137},{"_id":"themes/yilia/source/css/_partial/archive.styl","hash":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1471057725163},{"_id":"themes/yilia/source/css/_partial/article.styl","hash":"872fc4e63509fef885c939e5fd70e6ed439beced","modified":1471057725164},{"_id":"themes/yilia/source/css/_partial/footer.styl","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1471057725164},{"_id":"themes/yilia/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1471057725168},{"_id":"themes/yilia/source/css/_partial/highlight.styl","hash":"08d3205dde3235f3e6881126268e6c473f46a8ac","modified":1471057725169},{"_id":"themes/yilia/source/css/_partial/instagram.styl","hash":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1471057725169},{"_id":"themes/yilia/source/css/_partial/main.styl","hash":"c368f1533053d4cffdf0ad982603271400b08e33","modified":1471057725170},{"_id":"themes/yilia/source/css/_partial/mobile.styl","hash":"3a03b04ef8ac305aa5dbf7b9db99cd9377d07383","modified":1471057725171},{"_id":"themes/yilia/source/css/_partial/page.styl","hash":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1471057725172},{"_id":"themes/yilia/source/css/_partial/scroll.styl","hash":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1471057725173},{"_id":"themes/yilia/source/css/_partial/share.styl","hash":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1471057725173},{"_id":"themes/yilia/source/css/_partial/tagcloud.styl","hash":"af0115de5c6455f899a2e09225b50224982c039d","modified":1471057725174},{"_id":"themes/yilia/source/css/_partial/wheelmenu.styl","hash":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1471057725175},{"_id":"themes/yilia/source/css/_partial/mobile-slider.styl","hash":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1471057725171},{"_id":"themes/yilia/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1471057725176},{"_id":"themes/yilia/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1471057725176},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1471057725183},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1471057725221},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1471057725244},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1471057725245},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1471057725259},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1471057725266},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1471057725266},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1471057725267},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1471057725260},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1471057725265},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","hash":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1471057725211},{"_id":"themes/yilia/source/img/author.jpg","hash":"4437d5f1afe99dacfbc6a8968986bda2fa83c9ef","modified":1471057725273},{"_id":"public/atom.xml","hash":"e8055d02334146e1b5514f7e30f04a7465a1fc4b","modified":1471079493760},{"_id":"public/sitemap.xml","hash":"08b86ea1e3c579cf2edf8df126881545450ec4d3","modified":1471079494446},{"_id":"public/categories/Nodejs/index.html","hash":"3d124fc7eb8f116f56d00fd8fafbf7378b0c6ed7","modified":1471079494498},{"_id":"public/categories/其它/index.html","hash":"07da2bf18a6509aca31656bc90b54f21c7a54997","modified":1471079494498},{"_id":"public/categories/php/index.html","hash":"b034afd770931ef509714778041bebae2e814349","modified":1471079494498},{"_id":"public/categories/杂谈/index.html","hash":"0ca6efbdd39dcfeea523c6d36221037b93e44088","modified":1471079494498},{"_id":"public/archives/page/4/index.html","hash":"bfb876f3c53d4760f4f843091d14593e57cbf8cd","modified":1471079494498},{"_id":"public/archives/2014/index.html","hash":"034bd9702e6ee65a3b63ff462b0693c35e1d33b0","modified":1471079494498},{"_id":"public/archives/2014/09/index.html","hash":"8fd6d47d8f39fc5774984f344e6ab22c88844af3","modified":1471079494498},{"_id":"public/archives/2014/10/index.html","hash":"b44a9e4d7b4f830961a6a0039e65e0ed505438d7","modified":1471079494498},{"_id":"public/archives/2014/11/index.html","hash":"474b3912868b14ff196ebcb7c93c85729fb2009d","modified":1471079494499},{"_id":"public/archives/2015/page/3/index.html","hash":"9647df6275c73e8c85cf27748948e874ab1c76c8","modified":1471079494499},{"_id":"public/archives/2015/01/index.html","hash":"71fc212127dcaa80e44dbb898f9b83deedbfa795","modified":1471079494499},{"_id":"public/archives/2015/03/index.html","hash":"7b8a343c6c42e23566736d1d5f913fdc5aeed421","modified":1471079494499},{"_id":"public/archives/2015/04/index.html","hash":"66f256bd33dfb39e509e0e0f0d168f693a2e5ee3","modified":1471079494499},{"_id":"public/archives/2015/05/index.html","hash":"05561ab11b60c2721665f650c87f40e924b2e249","modified":1471079494499},{"_id":"public/archives/2015/07/index.html","hash":"1f60595706bfcf1cb1217d51ab66bddb04ad6f15","modified":1471079494499},{"_id":"public/archives/2015/08/index.html","hash":"d776efb5ca12fe40914369e09093c23516f76e59","modified":1471079494499},{"_id":"public/archives/2015/09/index.html","hash":"b6f1755fcbeffcdffa8f3f1068e03be6485e9434","modified":1471079494499},{"_id":"public/archives/2015/10/index.html","hash":"5c3e577a1b6c932002817ec4f24f09741af9bd57","modified":1471079494499},{"_id":"public/archives/2015/12/index.html","hash":"f6f308ffbe94151fe23f10ea785e826fe1bd3608","modified":1471079494499},{"_id":"public/archives/2016/index.html","hash":"4b763341bb76531ef8574228e0875d726233d628","modified":1471079494499},{"_id":"public/archives/2016/01/index.html","hash":"651a45c69fd88bb939327411aa31132be2d966dc","modified":1471079494499},{"_id":"public/archives/2016/03/index.html","hash":"4718ca41f765e0f4e0860bf111b7a1674c60f3d0","modified":1471079494499},{"_id":"public/archives/2016/05/index.html","hash":"a0c6d6d12f0962efffff9d086d727230dd660226","modified":1471079494499},{"_id":"public/archives/2016/08/index.html","hash":"a4eae367e33621622e1ecada5e55a8568476de23","modified":1471079494499},{"_id":"public/page/4/index.html","hash":"1f319e5a77a9b306a2d6575313fc87128b676efe","modified":1471079494499},{"_id":"public/tags/hash/index.html","hash":"118bfda6a5209a0e95865e023f93bc2366e359b5","modified":1471079494499},{"_id":"public/tags/location/index.html","hash":"fe117c4e5024ff29b6aeb4156ce02aa447df09a8","modified":1471079494499},{"_id":"public/tags/css/index.html","hash":"887b28d6bfceccec86cda8bd8432168eefe3d9c0","modified":1471079494499},{"_id":"public/tags/flexbox/index.html","hash":"a98fd049378101bee2e8cedd0687aefb34e24f24","modified":1471079494499},{"_id":"public/tags/React/index.html","hash":"3daad3faad3475c17b894d1528355aee281df3da","modified":1471079494500},{"_id":"public/tags/virtual-dom/index.html","hash":"ee4dbfb90068858b8a4160881200fcde426d45db","modified":1471079494500},{"_id":"public/tags/组件化开发/index.html","hash":"36e7ef42a3fadd6899947388216200c269dd79cf","modified":1471079494500},{"_id":"public/tags/mocha/index.html","hash":"f78328325d0cf381a310fb73cfb415671f3341c0","modified":1471079494500},{"_id":"public/tags/node/index.html","hash":"90a2a5a3fa50d239a7fce32b3a1b1fd9b048ea92","modified":1471079494500},{"_id":"public/tags/js/index.html","hash":"126c03dd7a420a684f5fd862709e0aae9aeeb458","modified":1471079494500},{"_id":"public/tags/curring/index.html","hash":"2c5c2defcbf6004caad82873d0fa6b0a260e949b","modified":1471079494500},{"_id":"public/tags/uncurrying/index.html","hash":"4fe0efd4d588030bb8dc8c79d9268b3bdda347d3","modified":1471079494500},{"_id":"public/tags/Vue/index.html","hash":"9632bd2d64e4d461743581ee40040d3f7f88658d","modified":1471079494500},{"_id":"public/tags/MVVM/index.html","hash":"48c7c393cf5c1982ab395f582a2477d07ce7ee15","modified":1471079494500},{"_id":"public/tags/Vuex/index.html","hash":"8b08d9dc6a4eaef4185e6b1895b43983a84a17c1","modified":1471079494500},{"_id":"public/tags/cleaver/index.html","hash":"55e8f7616c9fc129385b3c55bc21eeab030505f0","modified":1471079494500},{"_id":"public/tags/幻灯/index.html","hash":"774a9e523606d4193025f5c8cc631ed57a326c36","modified":1471079494500},{"_id":"public/tags/SEO/index.html","hash":"78f8b000f9910dcc6dfafba1855f8c89739d9d27","modified":1471079494500},{"_id":"public/tags/爬虫/index.html","hash":"3c15d4dc4d710f3b407c1f8a2ace4a6136d2aa1f","modified":1471079494500},{"_id":"public/tags/html5/index.html","hash":"9860cdb9cb301d1641327cc4127a505e94da469b","modified":1471079494500},{"_id":"public/tags/前端杂谈/index.html","hash":"8832702de92794ad0bc8b3c77af448a8b44e3393","modified":1471079494501},{"_id":"public/tags/网络/index.html","hash":"11bc561cba9a38ef866801869fe7a198873979d0","modified":1471079494501},{"_id":"public/tags/构建工具/index.html","hash":"6054f9720e15296cdf2290d68b781cb06a30c025","modified":1471079494501},{"_id":"public/tags/前端工程/index.html","hash":"468cacaa8cea35a59155ee1844a73d661c2f671b","modified":1471079494501},{"_id":"public/2016/08/13/Vue初接触实战之账单组件/index.html","hash":"5421e96a44e7eed161455a3ad65bc947ec83bde5","modified":1471079494501},{"_id":"public/2016/05/02/webpack学习实践系列-一/index.html","hash":"42da3a989c76ce9e797fe4ae7840d6ddbcd9558a","modified":1471079494501},{"_id":"public/2016/03/14/关于软件工程的一点感想——以前端为例/index.html","hash":"79272ca2cefc16046d012c9e128980831f37f596","modified":1471079494501},{"_id":"public/2016/01/26/JavaScript高阶函数之currying和uncurrying/index.html","hash":"e395b6475f890b54955db7e5ac88a473b39a4066","modified":1471079494501},{"_id":"public/2016/01/23/一个应届生对近来前端界流派之争的一点思考/index.html","hash":"59bb48a114c81a1c60cee298b3208e22e922746d","modified":1471079494501},{"_id":"public/2016/01/05/socket.io搭建多聊天室/index.html","hash":"95108462dfa492aa39c82f1aab99455c6629e9b8","modified":1471079494501},{"_id":"public/2015/12/15/前端笔试面试中的常用到的CSS知识点总结/index.html","hash":"3b91392c32b96241a54144095fcc29bc9c31602f","modified":1471079494501},{"_id":"public/2015/12/08/2015-12-09-单元测试工具Mocha和SuperTest组合/index.html","hash":"bfee52bae7fe42be5da1d3635ba2450d98964f81","modified":1471079494501},{"_id":"public/2015/12/08/单元测试工具Mocha和SuperTest组合/index.html","hash":"9f96a8b139e3e469c4f1a70d33e2d78f6b7aa07f","modified":1471079494501},{"_id":"public/2015/10/07/2015-10-07-React-js那些事-core篇/index.html","hash":"963534ac3ca32ae3ae0fb24e72a9b238f9215fd5","modified":1471079494501},{"_id":"public/2015/10/07/React-js那些事-core篇/index.html","hash":"497311099b13f9df037657a165dd7c2c86724a6d","modified":1471079494501},{"_id":"public/2015/09/14/2015-09-14-React-js那些事-入门篇/index.html","hash":"d15b4b31b88245af0cba256616ce320ddc93ea0e","modified":1471079494501},{"_id":"public/2015/09/14/React-js那些事-入门篇/index.html","hash":"bc51542512f93b403c3269a58e8886d486e55b34","modified":1471079494501},{"_id":"public/2015/09/11/2015-09-11-React-js那些事-介绍篇/index.html","hash":"89d3183281caa119228c266477320b42ee171ac6","modified":1471079494502},{"_id":"public/2015/09/11/React-js那些事-介绍篇/index.html","hash":"ed94f73274cde3c49af07fc5d9cb50d1411d5f8a","modified":1471079494502},{"_id":"public/2015/09/02/Flexbox-布局/index.html","hash":"c9ed78c28917228074e831af948e8ad2c196c930","modified":1471079494502},{"_id":"public/2015/09/02/2015-09-02-Flexbox-布局/index.html","hash":"98dd764804a336fdf5f6b39a110203cbdb69e0c4","modified":1471079494502},{"_id":"public/2015/08/15/2015-08-15-javascript之Location对象/index.html","hash":"34b79131ed8e56480cc1f819a2288fe55763f2e6","modified":1471079494502},{"_id":"public/2015/08/15/javascript之Location对象/index.html","hash":"3d503960718aae28cab5b542dd17689cd74e2cba","modified":1471079494502},{"_id":"public/2015/07/07/cleaver-make-ppt/index.html","hash":"eeda0502e6196c26b5bb2ec7064cec438ae5c09b","modified":1471079494502},{"_id":"public/2015/05/14/from-ajax-to-seo/index.html","hash":"05ef7b4e59048a8dbe6509777f2e88c5cffff75d","modified":1471079494502},{"_id":"public/2015/04/16/node-spider/index.html","hash":"cbfb4a29478490375f6c458f0f3837a03c7169f2","modified":1471079494502},{"_id":"public/2015/03/31/one-interview-closure/index.html","hash":"017b62d13d6014863bad77002cc82211b78f0891","modified":1471079494502},{"_id":"public/2015/03/26/html5-placeholder/index.html","hash":"b75086b20185c8da6a8edf7cb650ff0c60969878","modified":1471079494502},{"_id":"public/2015/03/11/javascript-op/index.html","hash":"576c5d5b3e2fd01e894c830bd213658e7b3f3117","modified":1471079494502},{"_id":"public/2015/01/29/jmobile-use-2/index.html","hash":"460f51cb4d5630e22fd1ba0c8664e0b1870b2cbc","modified":1471079494502},{"_id":"public/2015/01/28/jmobile-use-1/index.html","hash":"69758ef5e2209ac6afa55646f88425e35d82415b","modified":1471079494502},{"_id":"public/2014/11/21/problem-of-hash/index.html","hash":"c83af95d12fe9fd80e9d7345f044ccf7875d18a4","modified":1471079494502},{"_id":"public/2014/10/01/uploadyfy-introduce/index.html","hash":"fdeba78804eb65f973ba1ee9e230e955d668ef91","modified":1471079494502},{"_id":"public/2014/09/17/yanzhengma-php/index.html","hash":"eea66d39793642d3cff18210193aeea78e89b3b4","modified":1471079494502},{"_id":"public/2014/09/03/haskell-introduce/index.html","hash":"756c32efa9cd8c45c861b406c2a3bad786d21bc1","modified":1471079494502},{"_id":"public/categories/前端开发/index.html","hash":"27bbe476861512b191fa8c220c2aea765dea73c4","modified":1471079494502},{"_id":"public/categories/前端开发/page/2/index.html","hash":"aed8d1d131955ed3120e7d7cc16be365a6f2e504","modified":1471079494502},{"_id":"public/archives/index.html","hash":"cec951bb4a5f9ed2391172b7dbb5bbe93e77b266","modified":1471079494503},{"_id":"public/archives/page/2/index.html","hash":"00ef1b92423f9055330fef274ec15e0a35d3ca15","modified":1471079494503},{"_id":"public/archives/page/3/index.html","hash":"5f3f7f8676c8aa9184cdd86f419f4122f4d345b4","modified":1471079494503},{"_id":"public/archives/2015/index.html","hash":"6fddd6e5c72a62ddba5d4a544b71b14c52e05559","modified":1471079494503},{"_id":"public/archives/2015/page/2/index.html","hash":"d7baf9adcbc19089ee461feccaea83631b4622fb","modified":1471079494503},{"_id":"public/index.html","hash":"52f7c9154533b7b33d36b1eadf16acb92702bd83","modified":1471079494503},{"_id":"public/page/2/index.html","hash":"ee6276e0c51ede1d0f4aa0fd4757d7ff13e2eb13","modified":1471079494503},{"_id":"public/page/3/index.html","hash":"15cc05a80eddcdb9f85c157e7959d668908a6192","modified":1471079494503},{"_id":"public/CNAME","hash":"76d4ee8048c30ebf20549391ac08dc1743ff9e47","modified":1471079494519},{"_id":"public/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1471079494519},{"_id":"public/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1471079494520},{"_id":"public/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1471079494520},{"_id":"public/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1471079494520},{"_id":"public/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1471079494520},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1471079494520},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1471079494520},{"_id":"public/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1471079494520},{"_id":"public/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1471079494520},{"_id":"public/img/favicon.png","hash":"5a52307766d0fbfb5d62655217edb6f96ade50fa","modified":1471079494520},{"_id":"public/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1471079494520},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1471079494520},{"_id":"public/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1471079494520},{"_id":"public/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1471079494520},{"_id":"public/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1471079494520},{"_id":"public/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1471079494520},{"_id":"public/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1471079494520},{"_id":"public/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1471079494520},{"_id":"public/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1471079494520},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1471079494520},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1471079494520},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1471079494520},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1471079494520},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1471079494520},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1471079494521},{"_id":"public/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1471079494521},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1471079494521},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1471079494521},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1471079494521},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1471079494521},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1471079495049},{"_id":"public/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1471079495060},{"_id":"public/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1471079495060},{"_id":"public/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1471079495061},{"_id":"public/js/pc.js","hash":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10","modified":1471079495061},{"_id":"public/js/mobile.js","hash":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1471079495061},{"_id":"public/js/main.js","hash":"0640b68a76fab3c693b3cd1e4d04d14be1e53940","modified":1471079495061},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1471079495061},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1471079495061},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1471079495061},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1471079495062},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1471079495062},{"_id":"public/css/style.css","hash":"d794dc967f8a195d02daba0b6af69b4bc36d21db","modified":1471079495062},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1471079495062},{"_id":"public/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1471079495062},{"_id":"public/img/author.jpg","hash":"4437d5f1afe99dacfbc6a8968986bda2fa83c9ef","modified":1471079495070}],"Category":[{"name":"前端开发","_id":"cirsyqtqd00037kau3vchlnsu"},{"name":"Nodejs","_id":"cirsyqtqs000k7kau4hq5wn3a"},{"name":"其它","_id":"cirsyqtr400127kautzmhwv11"},{"name":"php","_id":"cirsyqtrn001v7kaubbwfmgkw"},{"name":"杂谈","_id":"cirsyqtrx002d7kausyxa6k97"}],"Data":[],"Page":[],"Post":[{"title":"javascript之Location对象","date":"2015-08-15T04:55:22.000Z","_content":"\n#  Location对象\n\nlocation对象是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。location对象既是window对象的属性，也是document对象的属性，window.location和document.location是引用同一个对象。\n<!--more-->\n## location对象的所有属性\n* hash          //返回URL中的hash(#后面跟的零个或者多个字符),如果URL中不包含散列，则返回空字符串\n* host          //返回服务器的名称和端口（如果有）\n* hostname      //返回不带端口的服务器名称\n* href          //返回当前加载页面的完整URL，location对象的toString()方法也是返回这个值\n* pathname      //返回URL中的路径\n* port          //返回URL中指定的端口号，没有包含则为空\n* ptotocol      //返回这个页面使用的协议\n* search        //返回查询字符串，比如“?q=javascript”\n我想在这里讨论的是location对象的hash属性及其用法\n\n## 关于hash\n#### “#”的含义\n“#”代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如,\"http://www.example.com/index.html#print\"\n就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。\n为网页位置指定标识符，有两个方法。一是使用锚点，比如\n```html \n<a name=\"print\"></a>\n```\n二是使用id属性，比如\n```html\n<div id=\"print\" ></div>\n```\n\n#### HTTP请求不包括\"#\"\n“#”是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括“#”。在第一个“#”后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。\n\n#### 改变“#”后面的字符不触发网页重载\n单单改变“#”后的部分，浏览器只会滚动到相应位置，不会重新加载网\n\n#### 改变“#”会改变浏览器的访问历史\n每一次改变“#”后的部分，都会在浏览器的访问历史中增加一个记录，使用\"后退\"按钮，就可以回到上一个位置。\n这对于ajax应用程序特别有用，可以用不同的“#”值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。\n值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。\n\n#### 监听hash值变化的方法\n```javascript\nwindow.onhashchange = func;\n<body onhashchange=\"func();\">\nwindow.addEventListener(\"hashchange\", func, false);\n```\n其中，onhashchange是一个html5的事件。当“#”值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0+支持该事件。对于不支持onhashchange的浏览器，可以用setInterval监控location.hash的变化。\n\n#### Google抓取“#”的机制\n默认情况下，Google的网络蜘蛛忽视URL的#部分。\n但是，Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用\"#!\"，Google会自动将其后面的内容转成查询字符串_escaped_fragment_的值。","source":"_posts/2015-08-15-javascript之Location对象.md","raw":"title: javascript之Location对象\ndate: 2015-08-15 12:55:22\ntags:\n    - hash\n    - location\ncategories:\n    - 前端开发\n---\n\n#  Location对象\n\nlocation对象是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。location对象既是window对象的属性，也是document对象的属性，window.location和document.location是引用同一个对象。\n<!--more-->\n## location对象的所有属性\n* hash          //返回URL中的hash(#后面跟的零个或者多个字符),如果URL中不包含散列，则返回空字符串\n* host          //返回服务器的名称和端口（如果有）\n* hostname      //返回不带端口的服务器名称\n* href          //返回当前加载页面的完整URL，location对象的toString()方法也是返回这个值\n* pathname      //返回URL中的路径\n* port          //返回URL中指定的端口号，没有包含则为空\n* ptotocol      //返回这个页面使用的协议\n* search        //返回查询字符串，比如“?q=javascript”\n我想在这里讨论的是location对象的hash属性及其用法\n\n## 关于hash\n#### “#”的含义\n“#”代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如,\"http://www.example.com/index.html#print\"\n就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。\n为网页位置指定标识符，有两个方法。一是使用锚点，比如\n```html \n<a name=\"print\"></a>\n```\n二是使用id属性，比如\n```html\n<div id=\"print\" ></div>\n```\n\n#### HTTP请求不包括\"#\"\n“#”是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括“#”。在第一个“#”后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。\n\n#### 改变“#”后面的字符不触发网页重载\n单单改变“#”后的部分，浏览器只会滚动到相应位置，不会重新加载网\n\n#### 改变“#”会改变浏览器的访问历史\n每一次改变“#”后的部分，都会在浏览器的访问历史中增加一个记录，使用\"后退\"按钮，就可以回到上一个位置。\n这对于ajax应用程序特别有用，可以用不同的“#”值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。\n值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。\n\n#### 监听hash值变化的方法\n```javascript\nwindow.onhashchange = func;\n<body onhashchange=\"func();\">\nwindow.addEventListener(\"hashchange\", func, false);\n```\n其中，onhashchange是一个html5的事件。当“#”值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0+支持该事件。对于不支持onhashchange的浏览器，可以用setInterval监控location.hash的变化。\n\n#### Google抓取“#”的机制\n默认情况下，Google的网络蜘蛛忽视URL的#部分。\n但是，Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用\"#!\"，Google会自动将其后面的内容转成查询字符串_escaped_fragment_的值。","slug":"2015-08-15-javascript之Location对象","published":1,"updated":"2016-08-13T03:08:44.506Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtq500007kaulmqzviwd","content":"<h1 id=\"Location对象\"><a href=\"#Location对象\" class=\"headerlink\" title=\"Location对象\"></a>Location对象</h1><p>location对象是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。location对象既是window对象的属性，也是document对象的属性，window.location和document.location是引用同一个对象。<br><a id=\"more\"></a></p>\n<h2 id=\"location对象的所有属性\"><a href=\"#location对象的所有属性\" class=\"headerlink\" title=\"location对象的所有属性\"></a>location对象的所有属性</h2><ul>\n<li>hash          //返回URL中的hash(#后面跟的零个或者多个字符),如果URL中不包含散列，则返回空字符串</li>\n<li>host          //返回服务器的名称和端口（如果有）</li>\n<li>hostname      //返回不带端口的服务器名称</li>\n<li>href          //返回当前加载页面的完整URL，location对象的toString()方法也是返回这个值</li>\n<li>pathname      //返回URL中的路径</li>\n<li>port          //返回URL中指定的端口号，没有包含则为空</li>\n<li>ptotocol      //返回这个页面使用的协议</li>\n<li>search        //返回查询字符串，比如“?q=javascript”<br>我想在这里讨论的是location对象的hash属性及其用法</li>\n</ul>\n<h2 id=\"关于hash\"><a href=\"#关于hash\" class=\"headerlink\" title=\"关于hash\"></a>关于hash</h2><h4 id=\"“-”的含义\"><a href=\"#“-”的含义\" class=\"headerlink\" title=\"“#”的含义\"></a>“#”的含义</h4><p>“#”代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如,”<a href=\"http://www.example.com/index.html#print\" target=\"_blank\" rel=\"external\">http://www.example.com/index.html#print</a>“<br>就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。<br>为网页位置指定标识符，有两个方法。一是使用锚点，比如<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">name</span>=<span class=\"string\">\"print\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>二是使用id属性，比如<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"print\"</span> &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"HTTP请求不包括”-”\"><a href=\"#HTTP请求不包括”-”\" class=\"headerlink\" title=\"HTTP请求不包括”#”\"></a>HTTP请求不包括”#”</h4><p>“#”是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括“#”。在第一个“#”后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。</p>\n<h4 id=\"改变“-”后面的字符不触发网页重载\"><a href=\"#改变“-”后面的字符不触发网页重载\" class=\"headerlink\" title=\"改变“#”后面的字符不触发网页重载\"></a>改变“#”后面的字符不触发网页重载</h4><p>单单改变“#”后的部分，浏览器只会滚动到相应位置，不会重新加载网</p>\n<h4 id=\"改变“-”会改变浏览器的访问历史\"><a href=\"#改变“-”会改变浏览器的访问历史\" class=\"headerlink\" title=\"改变“#”会改变浏览器的访问历史\"></a>改变“#”会改变浏览器的访问历史</h4><p>每一次改变“#”后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置。<br>这对于ajax应用程序特别有用，可以用不同的“#”值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。<br>值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。</p>\n<h4 id=\"监听hash值变化的方法\"><a href=\"#监听hash值变化的方法\" class=\"headerlink\" title=\"监听hash值变化的方法\"></a>监听hash值变化的方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.onhashchange = func;</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onhashchange</span>=<span class=\"string\">\"func();\"</span>&gt;</span></span></div><div class=\"line\">window.addEventListener(\"hashchange\", func, false);</div></pre></td></tr></table></figure>\n<p>其中，onhashchange是一个html5的事件。当“#”值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0+支持该事件。对于不支持onhashchange的浏览器，可以用setInterval监控location.hash的变化。</p>\n<h4 id=\"Google抓取“-”的机制\"><a href=\"#Google抓取“-”的机制\" class=\"headerlink\" title=\"Google抓取“#”的机制\"></a>Google抓取“#”的机制</h4><p>默认情况下，Google的网络蜘蛛忽视URL的#部分。<br>但是，Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用”#!”，Google会自动将其后面的内容转成查询字符串_escaped<em>fragment</em>的值。</p>\n","excerpt":"<h1 id=\"Location对象\"><a href=\"#Location对象\" class=\"headerlink\" title=\"Location对象\"></a>Location对象</h1><p>location对象是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。location对象既是window对象的属性，也是document对象的属性，window.location和document.location是引用同一个对象。<br>","more":"</p>\n<h2 id=\"location对象的所有属性\"><a href=\"#location对象的所有属性\" class=\"headerlink\" title=\"location对象的所有属性\"></a>location对象的所有属性</h2><ul>\n<li>hash          //返回URL中的hash(#后面跟的零个或者多个字符),如果URL中不包含散列，则返回空字符串</li>\n<li>host          //返回服务器的名称和端口（如果有）</li>\n<li>hostname      //返回不带端口的服务器名称</li>\n<li>href          //返回当前加载页面的完整URL，location对象的toString()方法也是返回这个值</li>\n<li>pathname      //返回URL中的路径</li>\n<li>port          //返回URL中指定的端口号，没有包含则为空</li>\n<li>ptotocol      //返回这个页面使用的协议</li>\n<li>search        //返回查询字符串，比如“?q=javascript”<br>我想在这里讨论的是location对象的hash属性及其用法</li>\n</ul>\n<h2 id=\"关于hash\"><a href=\"#关于hash\" class=\"headerlink\" title=\"关于hash\"></a>关于hash</h2><h4 id=\"“-”的含义\"><a href=\"#“-”的含义\" class=\"headerlink\" title=\"“#”的含义\"></a>“#”的含义</h4><p>“#”代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如,”<a href=\"http://www.example.com/index.html#print\">http://www.example.com/index.html#print</a>“<br>就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。<br>为网页位置指定标识符，有两个方法。一是使用锚点，比如<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">name</span>=<span class=\"string\">\"print\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>二是使用id属性，比如<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"print\"</span> &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"HTTP请求不包括”-”\"><a href=\"#HTTP请求不包括”-”\" class=\"headerlink\" title=\"HTTP请求不包括”#”\"></a>HTTP请求不包括”#”</h4><p>“#”是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括“#”。在第一个“#”后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。</p>\n<h4 id=\"改变“-”后面的字符不触发网页重载\"><a href=\"#改变“-”后面的字符不触发网页重载\" class=\"headerlink\" title=\"改变“#”后面的字符不触发网页重载\"></a>改变“#”后面的字符不触发网页重载</h4><p>单单改变“#”后的部分，浏览器只会滚动到相应位置，不会重新加载网</p>\n<h4 id=\"改变“-”会改变浏览器的访问历史\"><a href=\"#改变“-”会改变浏览器的访问历史\" class=\"headerlink\" title=\"改变“#”会改变浏览器的访问历史\"></a>改变“#”会改变浏览器的访问历史</h4><p>每一次改变“#”后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置。<br>这对于ajax应用程序特别有用，可以用不同的“#”值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。<br>值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。</p>\n<h4 id=\"监听hash值变化的方法\"><a href=\"#监听hash值变化的方法\" class=\"headerlink\" title=\"监听hash值变化的方法\"></a>监听hash值变化的方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.onhashchange = func;</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onhashchange</span>=<span class=\"string\">\"func();\"</span>&gt;</span></div><div class=\"line\">window.addEventListener(\"hashchange\", func, false);</span></div></pre></td></tr></table></figure>\n<p>其中，onhashchange是一个html5的事件。当“#”值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0+支持该事件。对于不支持onhashchange的浏览器，可以用setInterval监控location.hash的变化。</p>\n<h4 id=\"Google抓取“-”的机制\"><a href=\"#Google抓取“-”的机制\" class=\"headerlink\" title=\"Google抓取“#”的机制\"></a>Google抓取“#”的机制</h4><p>默认情况下，Google的网络蜘蛛忽视URL的#部分。<br>但是，Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用”#!”，Google会自动将其后面的内容转成查询字符串_escaped<em>fragment</em>的值。</p>"},{"title":"Flexbox 布局","date":"2015-09-02T03:57:07.000Z","_content":"\n# 1、简述\n\nFlex布局也叫“弹性盒子布局”，用来为盒状模型提供最大的灵活性。弹性布局的主要思想是让容器有能力来改变项目的宽度和高度，以填满可用空间（主要是为了容纳所有类型的显示设备和屏幕尺寸）的能力。\n最重要的是弹性盒子布局与方向无关，相对于常规的布局（块是垂直和内联水平为基础），很显然，这些工作以及网页设计缺乏灵活性，无法支持大型和复杂的应用程序（特别当它涉及到改变方向，缩放、拉伸和收缩等）。\n\n由于flexbox是一个整体模块，而不是单一的一个属性，它涉及到了很多东西，包括它的整个属性集。它们之中有一些是在父容器上设置，而有一些则是在子容器上设置。\n<!--more-->\n## 2、flexbox属性详解\n首先，需要看看整个弹性盒子的组成，先看下面一个图：\n![flexbox](http://img.caibaojian.com/uploads/2014/05/flexbox.png)\n\n采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称\"项目\"。\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n\n## 3、容器的flex属性\n\n首先，定义一个flex容器的方法:\n\n```css\n.container {\n  display: -webkit-flex;\n  display: flex; /* or inline-flex */\n}\n```\n容器的属性包括6个：\n* flex-direction\n* flex-wrap\n* flex-flow\n* justify-content\n* align-items\n* align-content\n### 3.1、flex-direction属性\n该属性决定主轴的方向，包括4个值：\n* row（默认值）：主轴为水平方向，起点在左端。\n* row-reverse：主轴为水平方向，起点在右端。\n* column：主轴为垂直方向，起点在上沿。\n* column-reverse：主轴为垂直方向，起点在下沿。\n![flex-direction](https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-direction1.svg)\n\n```css\n.container {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n```\n### 3.2、flex-wrap属性\n默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n一共3个值，\n* nowrap:(默认)不换行\n* wrap：换行\n* wrap-reverse：按照从左往右，换行之后从右到左，再换行从左到右这样的顺序排列\n![flex-wrap](https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-wrap.svg)\n```css\n.container{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n### 3.3、flex-flow属性\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n\n```css\n.container{\n    flex-flow: <‘flex-direction’> || <‘flex-wrap’>\n}\n```\n\n### 3.4、justify-content属性\n定义主轴上面的对齐方式，帮助灵活或者不灵活的元素在未占满整行的时候分布多余的空间。包括5个值：\n* flex-start（默认值）：主轴开始方向对齐\n* flex-end：主轴结束方向对齐\n* center： 居中\n* space-between：两端对齐，项目之间的间隔都相等。\n* space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n![justify-content](https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg)\n```css\n.container {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n\n### 3.5、align-items属性\nalign-items属性定义项目在交叉轴上如何对齐。包括5个值：\n* flex-start：交叉轴的起点对齐。\n* flex-end：交叉轴的终点对齐。\n* center：交叉轴的中点对齐。\n* baseline: 项目的第一行文字的基线对齐。\n* stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n![align-items](https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg)\n\n```css\n.container {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n### 3.6、align-content属性\n定义交叉抽上面有多余空间时的对齐方式。类似于主轴上面对齐的justify-content属性。如果项目只有一根轴线，该属性不起作用。\n该属性可以取6个值：\n* flex-start：与交叉轴的起点对齐。\n* flex-end：与交叉轴的终点对齐。\n* center：与交叉轴的中点对齐。\n* space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n* space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n* stretch（默认值）：轴线占满整个交叉轴。\n\n![align-content](https://cdn.css-tricks.com/wp-content/uploads/2013/04/align-content.svg)\n\n```css\n.container {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n\n## 4、子元素（项目）的属性\n弹性布局元素的子元素的属性包括6个：\n* order\n* flex-grow\n* flex-shrink\n* flex-basis\n* flex\n* align-self\n\n\n### 4.1、order属性\n子元素默认是按照代码声明的顺序铺层的，可以通过order值指定某个子元素的排序。order的取值为整数（可以是负数，默认0）\n![order](https://cdn.css-tricks.com/wp-content/uploads/2013/04/order-2.svg)\n\n```css\n.item {\n  order: <integer>;\n}\n```\n\n### 4.2、flex-grow属性\n该属性定义弹性布局子元素的“生长”能力。\n\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n![flex-grow](https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-grow.svg)\n\n```css\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n\n### 4.3、flex-shrink属性\nflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。不允许为负数。\n\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n```css\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n\n### 4.4、flex-basis属性\n定义剩余空间未分配之前的元素默认尺寸。\n```css\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n\n### 4.5、flex属性\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会自动推算其它相关值。\n```css\n.item {\n  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n}\n```\n\n### 4.6、align-self属性\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该元素包括6个值。\n![align-self](https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-self.svg)\n\n```css\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n本文参考CSS-TRICKS上的文章[A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)\n\n\n\n","source":"_posts/2015-09-02-Flexbox-布局.md","raw":"title: Flexbox 布局\ndate: 2015-09-02 11:57:07\ntags: \n    - css\n    - flexbox\ncategories:\n    - 前端开发\n---\n\n# 1、简述\n\nFlex布局也叫“弹性盒子布局”，用来为盒状模型提供最大的灵活性。弹性布局的主要思想是让容器有能力来改变项目的宽度和高度，以填满可用空间（主要是为了容纳所有类型的显示设备和屏幕尺寸）的能力。\n最重要的是弹性盒子布局与方向无关，相对于常规的布局（块是垂直和内联水平为基础），很显然，这些工作以及网页设计缺乏灵活性，无法支持大型和复杂的应用程序（特别当它涉及到改变方向，缩放、拉伸和收缩等）。\n\n由于flexbox是一个整体模块，而不是单一的一个属性，它涉及到了很多东西，包括它的整个属性集。它们之中有一些是在父容器上设置，而有一些则是在子容器上设置。\n<!--more-->\n## 2、flexbox属性详解\n首先，需要看看整个弹性盒子的组成，先看下面一个图：\n![flexbox](http://img.caibaojian.com/uploads/2014/05/flexbox.png)\n\n采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称\"项目\"。\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n\n## 3、容器的flex属性\n\n首先，定义一个flex容器的方法:\n\n```css\n.container {\n  display: -webkit-flex;\n  display: flex; /* or inline-flex */\n}\n```\n容器的属性包括6个：\n* flex-direction\n* flex-wrap\n* flex-flow\n* justify-content\n* align-items\n* align-content\n### 3.1、flex-direction属性\n该属性决定主轴的方向，包括4个值：\n* row（默认值）：主轴为水平方向，起点在左端。\n* row-reverse：主轴为水平方向，起点在右端。\n* column：主轴为垂直方向，起点在上沿。\n* column-reverse：主轴为垂直方向，起点在下沿。\n![flex-direction](https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-direction1.svg)\n\n```css\n.container {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n```\n### 3.2、flex-wrap属性\n默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n一共3个值，\n* nowrap:(默认)不换行\n* wrap：换行\n* wrap-reverse：按照从左往右，换行之后从右到左，再换行从左到右这样的顺序排列\n![flex-wrap](https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-wrap.svg)\n```css\n.container{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n### 3.3、flex-flow属性\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n\n```css\n.container{\n    flex-flow: <‘flex-direction’> || <‘flex-wrap’>\n}\n```\n\n### 3.4、justify-content属性\n定义主轴上面的对齐方式，帮助灵活或者不灵活的元素在未占满整行的时候分布多余的空间。包括5个值：\n* flex-start（默认值）：主轴开始方向对齐\n* flex-end：主轴结束方向对齐\n* center： 居中\n* space-between：两端对齐，项目之间的间隔都相等。\n* space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n![justify-content](https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg)\n```css\n.container {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n\n### 3.5、align-items属性\nalign-items属性定义项目在交叉轴上如何对齐。包括5个值：\n* flex-start：交叉轴的起点对齐。\n* flex-end：交叉轴的终点对齐。\n* center：交叉轴的中点对齐。\n* baseline: 项目的第一行文字的基线对齐。\n* stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n![align-items](https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg)\n\n```css\n.container {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n### 3.6、align-content属性\n定义交叉抽上面有多余空间时的对齐方式。类似于主轴上面对齐的justify-content属性。如果项目只有一根轴线，该属性不起作用。\n该属性可以取6个值：\n* flex-start：与交叉轴的起点对齐。\n* flex-end：与交叉轴的终点对齐。\n* center：与交叉轴的中点对齐。\n* space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n* space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n* stretch（默认值）：轴线占满整个交叉轴。\n\n![align-content](https://cdn.css-tricks.com/wp-content/uploads/2013/04/align-content.svg)\n\n```css\n.container {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n\n## 4、子元素（项目）的属性\n弹性布局元素的子元素的属性包括6个：\n* order\n* flex-grow\n* flex-shrink\n* flex-basis\n* flex\n* align-self\n\n\n### 4.1、order属性\n子元素默认是按照代码声明的顺序铺层的，可以通过order值指定某个子元素的排序。order的取值为整数（可以是负数，默认0）\n![order](https://cdn.css-tricks.com/wp-content/uploads/2013/04/order-2.svg)\n\n```css\n.item {\n  order: <integer>;\n}\n```\n\n### 4.2、flex-grow属性\n该属性定义弹性布局子元素的“生长”能力。\n\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n![flex-grow](https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-grow.svg)\n\n```css\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n\n### 4.3、flex-shrink属性\nflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。不允许为负数。\n\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n```css\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n\n### 4.4、flex-basis属性\n定义剩余空间未分配之前的元素默认尺寸。\n```css\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n\n### 4.5、flex属性\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会自动推算其它相关值。\n```css\n.item {\n  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n}\n```\n\n### 4.6、align-self属性\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该元素包括6个值。\n![align-self](https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-self.svg)\n\n```css\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n本文参考CSS-TRICKS上的文章[A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)\n\n\n\n","slug":"2015-09-02-Flexbox-布局","published":1,"updated":"2016-08-13T03:08:44.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtq900017kausn05etr6","content":"<h1 id=\"1、简述\"><a href=\"#1、简述\" class=\"headerlink\" title=\"1、简述\"></a>1、简述</h1><p>Flex布局也叫“弹性盒子布局”，用来为盒状模型提供最大的灵活性。弹性布局的主要思想是让容器有能力来改变项目的宽度和高度，以填满可用空间（主要是为了容纳所有类型的显示设备和屏幕尺寸）的能力。<br>最重要的是弹性盒子布局与方向无关，相对于常规的布局（块是垂直和内联水平为基础），很显然，这些工作以及网页设计缺乏灵活性，无法支持大型和复杂的应用程序（特别当它涉及到改变方向，缩放、拉伸和收缩等）。</p>\n<p>由于flexbox是一个整体模块，而不是单一的一个属性，它涉及到了很多东西，包括它的整个属性集。它们之中有一些是在父容器上设置，而有一些则是在子容器上设置。<br><a id=\"more\"></a></p>\n<h2 id=\"2、flexbox属性详解\"><a href=\"#2、flexbox属性详解\" class=\"headerlink\" title=\"2、flexbox属性详解\"></a>2、flexbox属性详解</h2><p>首先，需要看看整个弹性盒子的组成，先看下面一个图：<br><img src=\"http://img.caibaojian.com/uploads/2014/05/flexbox.png\" alt=\"flexbox\"></p>\n<p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>\n<h2 id=\"3、容器的flex属性\"><a href=\"#3、容器的flex属性\" class=\"headerlink\" title=\"3、容器的flex属性\"></a>3、容器的flex属性</h2><p>首先，定义一个flex容器的方法:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: -webkit-flex;</div><div class=\"line\">  <span class=\"attribute\">display</span>: flex; <span class=\"comment\">/* or inline-flex */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>容器的属性包括6个：</p>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content<h3 id=\"3-1、flex-direction属性\"><a href=\"#3-1、flex-direction属性\" class=\"headerlink\" title=\"3.1、flex-direction属性\"></a>3.1、flex-direction属性</h3>该属性决定主轴的方向，包括4个值：</li>\n<li>row（默认值）：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿。<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-direction1.svg\" alt=\"flex-direction\"></li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-direction</span>: row | row-reverse | column | column-reverse;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-2、flex-wrap属性\"><a href=\"#3-2、flex-wrap属性\" class=\"headerlink\" title=\"3.2、flex-wrap属性\"></a>3.2、flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br>一共3个值，</p>\n<ul>\n<li>nowrap:(默认)不换行</li>\n<li>wrap：换行</li>\n<li>wrap-reverse：按照从左往右，换行之后从右到左，再换行从左到右这样的顺序排列<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-wrap.svg\" alt=\"flex-wrap\"><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">flex-wrap</span>: nowrap | wrap | wrap-reverse;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"3-3、flex-flow属性\"><a href=\"#3-3、flex-flow属性\" class=\"headerlink\" title=\"3.3、flex-flow属性\"></a>3.3、flex-flow属性</h3><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">flex-flow</span>: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-4、justify-content属性\"><a href=\"#3-4、justify-content属性\" class=\"headerlink\" title=\"3.4、justify-content属性\"></a>3.4、justify-content属性</h3><p>定义主轴上面的对齐方式，帮助灵活或者不灵活的元素在未占满整行的时候分布多余的空间。包括5个值：</p>\n<ul>\n<li>flex-start（默认值）：主轴开始方向对齐</li>\n<li>flex-end：主轴结束方向对齐</li>\n<li>center： 居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n<p><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg\" alt=\"justify-content\"><br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-5、align-items属性\"><a href=\"#3-5、align-items属性\" class=\"headerlink\" title=\"3.5、align-items属性\"></a>3.5、align-items属性</h3><p>align-items属性定义项目在交叉轴上如何对齐。包括5个值：</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n<p><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg\" alt=\"align-items\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">align-items</span>: flex-start | flex-end | center | baseline | stretch;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-6、align-content属性\"><a href=\"#3-6、align-content属性\" class=\"headerlink\" title=\"3.6、align-content属性\"></a>3.6、align-content属性</h3><p>定义交叉抽上面有多余空间时的对齐方式。类似于主轴上面对齐的justify-content属性。如果项目只有一根轴线，该属性不起作用。<br>该属性可以取6个值：</p>\n<ul>\n<li>flex-start：与交叉轴的起点对齐。</li>\n<li>flex-end：与交叉轴的终点对齐。</li>\n<li>center：与交叉轴的中点对齐。</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li>stretch（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n<p><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2013/04/align-content.svg\" alt=\"align-content\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"4、子元素（项目）的属性\"><a href=\"#4、子元素（项目）的属性\" class=\"headerlink\" title=\"4、子元素（项目）的属性\"></a>4、子元素（项目）的属性</h2><p>弹性布局元素的子元素的属性包括6个：</p>\n<ul>\n<li>order</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h3 id=\"4-1、order属性\"><a href=\"#4-1、order属性\" class=\"headerlink\" title=\"4.1、order属性\"></a>4.1、order属性</h3><p>子元素默认是按照代码声明的顺序铺层的，可以通过order值指定某个子元素的排序。order的取值为整数（可以是负数，默认0）<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2013/04/order-2.svg\" alt=\"order\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">order</span>: &lt;integer&gt;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-2、flex-grow属性\"><a href=\"#4-2、flex-grow属性\" class=\"headerlink\" title=\"4.2、flex-grow属性\"></a>4.2、flex-grow属性</h3><p>该属性定义弹性布局子元素的“生长”能力。</p>\n<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-grow.svg\" alt=\"flex-grow\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-grow</span>: &lt;number&gt;; <span class=\"comment\">/* default 0 */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-3、flex-shrink属性\"><a href=\"#4-3、flex-shrink属性\" class=\"headerlink\" title=\"4.3、flex-shrink属性\"></a>4.3、flex-shrink属性</h3><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。不允许为负数。</p>\n<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-shrink</span>: &lt;number&gt;; <span class=\"comment\">/* default 1 */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-4、flex-basis属性\"><a href=\"#4-4、flex-basis属性\" class=\"headerlink\" title=\"4.4、flex-basis属性\"></a>4.4、flex-basis属性</h3><p>定义剩余空间未分配之前的元素默认尺寸。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-basis</span>: &lt;length&gt; | auto; <span class=\"comment\">/* default auto */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-5、flex属性\"><a href=\"#4-5、flex属性\" class=\"headerlink\" title=\"4.5、flex属性\"></a>4.5、flex属性</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会自动推算其它相关值。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex</span>: none | [ &lt;<span class=\"string\">'flex-grow'</span>&gt; &lt;<span class=\"string\">'flex-shrink'</span>&gt;? || &lt;<span class=\"string\">'flex-basis'</span>&gt; ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-6、align-self属性\"><a href=\"#4-6、align-self属性\" class=\"headerlink\" title=\"4.6、align-self属性\"></a>4.6、align-self属性</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该元素包括6个值。<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-self.svg\" alt=\"align-self\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>本文参考CSS-TRICKS上的文章<a href=\"https://css-tricks.com/snippets/css/a-guide-to-flexbox/\" target=\"_blank\" rel=\"external\">A Complete Guide to Flexbox</a></p>\n","excerpt":"<h1 id=\"1、简述\"><a href=\"#1、简述\" class=\"headerlink\" title=\"1、简述\"></a>1、简述</h1><p>Flex布局也叫“弹性盒子布局”，用来为盒状模型提供最大的灵活性。弹性布局的主要思想是让容器有能力来改变项目的宽度和高度，以填满可用空间（主要是为了容纳所有类型的显示设备和屏幕尺寸）的能力。<br>最重要的是弹性盒子布局与方向无关，相对于常规的布局（块是垂直和内联水平为基础），很显然，这些工作以及网页设计缺乏灵活性，无法支持大型和复杂的应用程序（特别当它涉及到改变方向，缩放、拉伸和收缩等）。</p>\n<p>由于flexbox是一个整体模块，而不是单一的一个属性，它涉及到了很多东西，包括它的整个属性集。它们之中有一些是在父容器上设置，而有一些则是在子容器上设置。<br>","more":"</p>\n<h2 id=\"2、flexbox属性详解\"><a href=\"#2、flexbox属性详解\" class=\"headerlink\" title=\"2、flexbox属性详解\"></a>2、flexbox属性详解</h2><p>首先，需要看看整个弹性盒子的组成，先看下面一个图：<br><img src=\"http://img.caibaojian.com/uploads/2014/05/flexbox.png\" alt=\"flexbox\"></p>\n<p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>\n<h2 id=\"3、容器的flex属性\"><a href=\"#3、容器的flex属性\" class=\"headerlink\" title=\"3、容器的flex属性\"></a>3、容器的flex属性</h2><p>首先，定义一个flex容器的方法:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: -webkit-flex;</div><div class=\"line\">  <span class=\"attribute\">display</span>: flex; <span class=\"comment\">/* or inline-flex */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>容器的属性包括6个：</p>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content<h3 id=\"3-1、flex-direction属性\"><a href=\"#3-1、flex-direction属性\" class=\"headerlink\" title=\"3.1、flex-direction属性\"></a>3.1、flex-direction属性</h3>该属性决定主轴的方向，包括4个值：</li>\n<li>row（默认值）：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿。<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-direction1.svg\" alt=\"flex-direction\"></li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-direction</span>: row | row-reverse | column | column-reverse;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-2、flex-wrap属性\"><a href=\"#3-2、flex-wrap属性\" class=\"headerlink\" title=\"3.2、flex-wrap属性\"></a>3.2、flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br>一共3个值，</p>\n<ul>\n<li>nowrap:(默认)不换行</li>\n<li>wrap：换行</li>\n<li>wrap-reverse：按照从左往右，换行之后从右到左，再换行从左到右这样的顺序排列<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-wrap.svg\" alt=\"flex-wrap\"><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">flex-wrap</span>: nowrap | wrap | wrap-reverse;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"3-3、flex-flow属性\"><a href=\"#3-3、flex-flow属性\" class=\"headerlink\" title=\"3.3、flex-flow属性\"></a>3.3、flex-flow属性</h3><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">flex-flow</span>: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-4、justify-content属性\"><a href=\"#3-4、justify-content属性\" class=\"headerlink\" title=\"3.4、justify-content属性\"></a>3.4、justify-content属性</h3><p>定义主轴上面的对齐方式，帮助灵活或者不灵活的元素在未占满整行的时候分布多余的空间。包括5个值：</p>\n<ul>\n<li>flex-start（默认值）：主轴开始方向对齐</li>\n<li>flex-end：主轴结束方向对齐</li>\n<li>center： 居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n<p><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg\" alt=\"justify-content\"><br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-5、align-items属性\"><a href=\"#3-5、align-items属性\" class=\"headerlink\" title=\"3.5、align-items属性\"></a>3.5、align-items属性</h3><p>align-items属性定义项目在交叉轴上如何对齐。包括5个值：</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n<p><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg\" alt=\"align-items\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">align-items</span>: flex-start | flex-end | center | baseline | stretch;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-6、align-content属性\"><a href=\"#3-6、align-content属性\" class=\"headerlink\" title=\"3.6、align-content属性\"></a>3.6、align-content属性</h3><p>定义交叉抽上面有多余空间时的对齐方式。类似于主轴上面对齐的justify-content属性。如果项目只有一根轴线，该属性不起作用。<br>该属性可以取6个值：</p>\n<ul>\n<li>flex-start：与交叉轴的起点对齐。</li>\n<li>flex-end：与交叉轴的终点对齐。</li>\n<li>center：与交叉轴的中点对齐。</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li>stretch（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n<p><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2013/04/align-content.svg\" alt=\"align-content\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"4、子元素（项目）的属性\"><a href=\"#4、子元素（项目）的属性\" class=\"headerlink\" title=\"4、子元素（项目）的属性\"></a>4、子元素（项目）的属性</h2><p>弹性布局元素的子元素的属性包括6个：</p>\n<ul>\n<li>order</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h3 id=\"4-1、order属性\"><a href=\"#4-1、order属性\" class=\"headerlink\" title=\"4.1、order属性\"></a>4.1、order属性</h3><p>子元素默认是按照代码声明的顺序铺层的，可以通过order值指定某个子元素的排序。order的取值为整数（可以是负数，默认0）<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2013/04/order-2.svg\" alt=\"order\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">order</span>: &lt;integer&gt;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-2、flex-grow属性\"><a href=\"#4-2、flex-grow属性\" class=\"headerlink\" title=\"4.2、flex-grow属性\"></a>4.2、flex-grow属性</h3><p>该属性定义弹性布局子元素的“生长”能力。</p>\n<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-grow.svg\" alt=\"flex-grow\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-grow</span>: &lt;number&gt;; <span class=\"comment\">/* default 0 */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-3、flex-shrink属性\"><a href=\"#4-3、flex-shrink属性\" class=\"headerlink\" title=\"4.3、flex-shrink属性\"></a>4.3、flex-shrink属性</h3><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。不允许为负数。</p>\n<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-shrink</span>: &lt;number&gt;; <span class=\"comment\">/* default 1 */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-4、flex-basis属性\"><a href=\"#4-4、flex-basis属性\" class=\"headerlink\" title=\"4.4、flex-basis属性\"></a>4.4、flex-basis属性</h3><p>定义剩余空间未分配之前的元素默认尺寸。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-basis</span>: &lt;length&gt; | auto; <span class=\"comment\">/* default auto */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-5、flex属性\"><a href=\"#4-5、flex属性\" class=\"headerlink\" title=\"4.5、flex属性\"></a>4.5、flex属性</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会自动推算其它相关值。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex</span>: none | [ &lt;<span class=\"string\">'flex-grow'</span>&gt; &lt;<span class=\"string\">'flex-shrink'</span>&gt;? || &lt;<span class=\"string\">'flex-basis'</span>&gt; ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-6、align-self属性\"><a href=\"#4-6、align-self属性\" class=\"headerlink\" title=\"4.6、align-self属性\"></a>4.6、align-self属性</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该元素包括6个值。<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-self.svg\" alt=\"align-self\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>本文参考CSS-TRICKS上的文章<a href=\"https://css-tricks.com/snippets/css/a-guide-to-flexbox/\">A Complete Guide to Flexbox</a></p>"},{"title":"React.js那些事(介绍篇)","date":"2015-09-11T05:28:05.000Z","_content":"\n# 引言\nWEB前端开发的发展历史大概经过了“原始时代——类库时代——工程构建时代——模块化时代”。目前前端领域的发展正处在一个空前繁荣的阶段——“模块化/组件化时代”。\n\n## 原始时代\n曾几何时，前端开发在软件工程的技术栈里面只被视为设计类岗位，甚至现在为止也有一些小企业依然把前端的职责视为简单的编写html+css页面。早期的前端开发完全依赖于后端技术，所有的数据渲染都由后端开发者进行，界面源码和后台逻辑代码混在一起。这个时代的前端无疑是非常薄的，薄到“网页开发人员”的入门门槛几乎低至为零。\n<!--more-->\n## 类库时代\n这一阶段出现了对js封装的各种类库，代表作当然就是前端领域从业者无所不知的jquery库啦。类库时代的开发者承担了很大一部分数据交互的工作。借鉴于AJAX，开发过程可以实现很好的前后端分离，MVC开发框架日益盛行。这个时代，前端开发者在一定程度上摆脱了对后端的严重依赖，使得前后端开发依赖于接口，大大加快了开发效率。\n\n## 工程构建时代\n基于各种自动化构建工具部署前端代码是这一时代的基本特征，前端发展到今天，自动化构建依然是当前的技术主流，Grunt,gulp.js以及国内的Fis等都是自动化代码优化和部署的热门工具。\n\n## 模块化时代\n模块化时代标志着前端开发正式进入工程化阶段，“前端工程师”正式成为名副其实的“工程师”。我之所以这样认为是因为这一阶段前端开发可以完全实现代码的重用，实现模块化开发，系统化、规范化的软件开发就是“软件工程”。所以前端工程师也就是在这一阶段日渐活跃，需求量也迅猛增长。前端模块时代的技术代表就是Require.js以及国内的sea.js这样的模块加载器。在MVC开发模式的基础上实现了对视图层的模块化开发，MVC框架至此达到一个鼎盛阶段。\n然而前端之所以迷人在于新的开发模式和技术不会停止出现，不同的应用需求催生了新的开发技术的诞生。最近几年，组件化开发正成为前端领域的潮流，组件开发减少了代码的耦合，非常适合大型网站应用的开发（这类大型网站的特点就是大量的模块类似或者重复）。可实现代码高度重用的MVVM框架开发进入开发者眼中——这就是React.js的诞生背景\n\n# React.js\n## React是什么东西？\n来自官网的介绍：\n* 仅仅是UI\n许多人使用React作为MVC架构的V层。尽管React并没有假设过你的其余技术栈，但它仍可以作为一个小特征轻易地在已有项目中使用。\n* 虚拟DOM\nReact为了更高超的性能而使用虚拟DOM作为其不同的实现。它同时也可以由服务端Node.js渲染而不需要过重的浏览器DOM支持。\n* 数据流\nReact实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。\n\n也就是说，React是一个视图层的应用，并且是一个高效的视图。React提供了和以往不一样的方式来看待视图，它以组件开发为基础。对React应用而言，你需要分割你的页面，使其成为一个个的组件。也就是说，你的应用是由这些组件组合而成的。组件本身可以实现数据流的的单向流动，实现独立开发。这就是我们所说的“组件驱动开发”。\n\n## 虚拟DOM\nReact的一大特点是其所拥有的虚拟DOM，它让页面渲染变得非常的高效，并且比直接操纵DOM变得更为可控。由于虚拟DOM的绘制是在内存里面进行的，高效是它的特征。这两大特点的组合使得React具有强大的自上而下的页面渲染能力。\n\nReact提供了一个观察者模型用于替代传统的脏检查（dirty checking）， 也就是持续的检查模型的变化。这也就是解释了为什么React不需要计算哪些发生了改变的原因，因为它根据state的变化会立即知道。这个过程减少了DOM操作，并让应用程序变得更平滑。我们知道DOM操作是非常耗性能的，更少的DOM操作意味着更高效的渲染。React在底层实现了一个diffing算法，该算法使用DOM的树形表示法，当某个 节点发生变化（标记为dirty）时它会重新计算整个子树，你会注意到你的模型发生了改变，因为整个子树在之后会被重新渲染。\n\n## JSX\nJSX是什么鬼？？？JSX是一个看起来很像XML的JavaScript语法扩展。React可以用来做简单的JSX句法转换。React提供了（也是建议使用）JSX代替JS进行组件绘制，然后运行的时候使用一个JSX编译器进行转换。JSX的使用还是比较简单的：\n要渲染 HTML 标签，只需在 JSX 里使用小写字母开头的标签名。\n```jsx\n    var myDivElement = <div className=\"foo\" />;\n    React.render(myDivElement, document.body);\n```\n要渲染 React 组件，只需创建一个大写字母开头的本地变量。\n```jsx\n    var MyComponent = React.createClass({/*一些代码*/});\n    var myElement = <MyComponent someProperty={true} />;\n    React.render(myElement, document.body);\n```\n\n# 本节结语\n关于React.js的入门介绍暂时到这里，想要更多地了解React.js的朋友可以进入[官方文档](http://reactjs.cn/)进行学习。\n\n\n\n\n\n","source":"_posts/2015-09-11-React-js那些事-介绍篇.md","raw":"title: React.js那些事(介绍篇)\ndate: 2015-09-11 13:28:05\ntags:\n    - React\n    - virtual dom\ncategories:\n    - 前端开发\n---\n\n# 引言\nWEB前端开发的发展历史大概经过了“原始时代——类库时代——工程构建时代——模块化时代”。目前前端领域的发展正处在一个空前繁荣的阶段——“模块化/组件化时代”。\n\n## 原始时代\n曾几何时，前端开发在软件工程的技术栈里面只被视为设计类岗位，甚至现在为止也有一些小企业依然把前端的职责视为简单的编写html+css页面。早期的前端开发完全依赖于后端技术，所有的数据渲染都由后端开发者进行，界面源码和后台逻辑代码混在一起。这个时代的前端无疑是非常薄的，薄到“网页开发人员”的入门门槛几乎低至为零。\n<!--more-->\n## 类库时代\n这一阶段出现了对js封装的各种类库，代表作当然就是前端领域从业者无所不知的jquery库啦。类库时代的开发者承担了很大一部分数据交互的工作。借鉴于AJAX，开发过程可以实现很好的前后端分离，MVC开发框架日益盛行。这个时代，前端开发者在一定程度上摆脱了对后端的严重依赖，使得前后端开发依赖于接口，大大加快了开发效率。\n\n## 工程构建时代\n基于各种自动化构建工具部署前端代码是这一时代的基本特征，前端发展到今天，自动化构建依然是当前的技术主流，Grunt,gulp.js以及国内的Fis等都是自动化代码优化和部署的热门工具。\n\n## 模块化时代\n模块化时代标志着前端开发正式进入工程化阶段，“前端工程师”正式成为名副其实的“工程师”。我之所以这样认为是因为这一阶段前端开发可以完全实现代码的重用，实现模块化开发，系统化、规范化的软件开发就是“软件工程”。所以前端工程师也就是在这一阶段日渐活跃，需求量也迅猛增长。前端模块时代的技术代表就是Require.js以及国内的sea.js这样的模块加载器。在MVC开发模式的基础上实现了对视图层的模块化开发，MVC框架至此达到一个鼎盛阶段。\n然而前端之所以迷人在于新的开发模式和技术不会停止出现，不同的应用需求催生了新的开发技术的诞生。最近几年，组件化开发正成为前端领域的潮流，组件开发减少了代码的耦合，非常适合大型网站应用的开发（这类大型网站的特点就是大量的模块类似或者重复）。可实现代码高度重用的MVVM框架开发进入开发者眼中——这就是React.js的诞生背景\n\n# React.js\n## React是什么东西？\n来自官网的介绍：\n* 仅仅是UI\n许多人使用React作为MVC架构的V层。尽管React并没有假设过你的其余技术栈，但它仍可以作为一个小特征轻易地在已有项目中使用。\n* 虚拟DOM\nReact为了更高超的性能而使用虚拟DOM作为其不同的实现。它同时也可以由服务端Node.js渲染而不需要过重的浏览器DOM支持。\n* 数据流\nReact实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。\n\n也就是说，React是一个视图层的应用，并且是一个高效的视图。React提供了和以往不一样的方式来看待视图，它以组件开发为基础。对React应用而言，你需要分割你的页面，使其成为一个个的组件。也就是说，你的应用是由这些组件组合而成的。组件本身可以实现数据流的的单向流动，实现独立开发。这就是我们所说的“组件驱动开发”。\n\n## 虚拟DOM\nReact的一大特点是其所拥有的虚拟DOM，它让页面渲染变得非常的高效，并且比直接操纵DOM变得更为可控。由于虚拟DOM的绘制是在内存里面进行的，高效是它的特征。这两大特点的组合使得React具有强大的自上而下的页面渲染能力。\n\nReact提供了一个观察者模型用于替代传统的脏检查（dirty checking）， 也就是持续的检查模型的变化。这也就是解释了为什么React不需要计算哪些发生了改变的原因，因为它根据state的变化会立即知道。这个过程减少了DOM操作，并让应用程序变得更平滑。我们知道DOM操作是非常耗性能的，更少的DOM操作意味着更高效的渲染。React在底层实现了一个diffing算法，该算法使用DOM的树形表示法，当某个 节点发生变化（标记为dirty）时它会重新计算整个子树，你会注意到你的模型发生了改变，因为整个子树在之后会被重新渲染。\n\n## JSX\nJSX是什么鬼？？？JSX是一个看起来很像XML的JavaScript语法扩展。React可以用来做简单的JSX句法转换。React提供了（也是建议使用）JSX代替JS进行组件绘制，然后运行的时候使用一个JSX编译器进行转换。JSX的使用还是比较简单的：\n要渲染 HTML 标签，只需在 JSX 里使用小写字母开头的标签名。\n```jsx\n    var myDivElement = <div className=\"foo\" />;\n    React.render(myDivElement, document.body);\n```\n要渲染 React 组件，只需创建一个大写字母开头的本地变量。\n```jsx\n    var MyComponent = React.createClass({/*一些代码*/});\n    var myElement = <MyComponent someProperty={true} />;\n    React.render(myElement, document.body);\n```\n\n# 本节结语\n关于React.js的入门介绍暂时到这里，想要更多地了解React.js的朋友可以进入[官方文档](http://reactjs.cn/)进行学习。\n\n\n\n\n\n","slug":"2015-09-11-React-js那些事-介绍篇","published":1,"updated":"2016-08-13T03:08:44.509Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtqe00047kauehhbz1rh","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>WEB前端开发的发展历史大概经过了“原始时代——类库时代——工程构建时代——模块化时代”。目前前端领域的发展正处在一个空前繁荣的阶段——“模块化/组件化时代”。</p>\n<h2 id=\"原始时代\"><a href=\"#原始时代\" class=\"headerlink\" title=\"原始时代\"></a>原始时代</h2><p>曾几何时，前端开发在软件工程的技术栈里面只被视为设计类岗位，甚至现在为止也有一些小企业依然把前端的职责视为简单的编写html+css页面。早期的前端开发完全依赖于后端技术，所有的数据渲染都由后端开发者进行，界面源码和后台逻辑代码混在一起。这个时代的前端无疑是非常薄的，薄到“网页开发人员”的入门门槛几乎低至为零。<br><a id=\"more\"></a></p>\n<h2 id=\"类库时代\"><a href=\"#类库时代\" class=\"headerlink\" title=\"类库时代\"></a>类库时代</h2><p>这一阶段出现了对js封装的各种类库，代表作当然就是前端领域从业者无所不知的jquery库啦。类库时代的开发者承担了很大一部分数据交互的工作。借鉴于AJAX，开发过程可以实现很好的前后端分离，MVC开发框架日益盛行。这个时代，前端开发者在一定程度上摆脱了对后端的严重依赖，使得前后端开发依赖于接口，大大加快了开发效率。</p>\n<h2 id=\"工程构建时代\"><a href=\"#工程构建时代\" class=\"headerlink\" title=\"工程构建时代\"></a>工程构建时代</h2><p>基于各种自动化构建工具部署前端代码是这一时代的基本特征，前端发展到今天，自动化构建依然是当前的技术主流，Grunt,gulp.js以及国内的Fis等都是自动化代码优化和部署的热门工具。</p>\n<h2 id=\"模块化时代\"><a href=\"#模块化时代\" class=\"headerlink\" title=\"模块化时代\"></a>模块化时代</h2><p>模块化时代标志着前端开发正式进入工程化阶段，“前端工程师”正式成为名副其实的“工程师”。我之所以这样认为是因为这一阶段前端开发可以完全实现代码的重用，实现模块化开发，系统化、规范化的软件开发就是“软件工程”。所以前端工程师也就是在这一阶段日渐活跃，需求量也迅猛增长。前端模块时代的技术代表就是Require.js以及国内的sea.js这样的模块加载器。在MVC开发模式的基础上实现了对视图层的模块化开发，MVC框架至此达到一个鼎盛阶段。<br>然而前端之所以迷人在于新的开发模式和技术不会停止出现，不同的应用需求催生了新的开发技术的诞生。最近几年，组件化开发正成为前端领域的潮流，组件开发减少了代码的耦合，非常适合大型网站应用的开发（这类大型网站的特点就是大量的模块类似或者重复）。可实现代码高度重用的MVVM框架开发进入开发者眼中——这就是React.js的诞生背景</p>\n<h1 id=\"React-js\"><a href=\"#React-js\" class=\"headerlink\" title=\"React.js\"></a>React.js</h1><h2 id=\"React是什么东西？\"><a href=\"#React是什么东西？\" class=\"headerlink\" title=\"React是什么东西？\"></a>React是什么东西？</h2><p>来自官网的介绍：</p>\n<ul>\n<li>仅仅是UI<br>许多人使用React作为MVC架构的V层。尽管React并没有假设过你的其余技术栈，但它仍可以作为一个小特征轻易地在已有项目中使用。</li>\n<li>虚拟DOM<br>React为了更高超的性能而使用虚拟DOM作为其不同的实现。它同时也可以由服务端Node.js渲染而不需要过重的浏览器DOM支持。</li>\n<li>数据流<br>React实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。</li>\n</ul>\n<p>也就是说，React是一个视图层的应用，并且是一个高效的视图。React提供了和以往不一样的方式来看待视图，它以组件开发为基础。对React应用而言，你需要分割你的页面，使其成为一个个的组件。也就是说，你的应用是由这些组件组合而成的。组件本身可以实现数据流的的单向流动，实现独立开发。这就是我们所说的“组件驱动开发”。</p>\n<h2 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h2><p>React的一大特点是其所拥有的虚拟DOM，它让页面渲染变得非常的高效，并且比直接操纵DOM变得更为可控。由于虚拟DOM的绘制是在内存里面进行的，高效是它的特征。这两大特点的组合使得React具有强大的自上而下的页面渲染能力。</p>\n<p>React提供了一个观察者模型用于替代传统的脏检查（dirty checking）， 也就是持续的检查模型的变化。这也就是解释了为什么React不需要计算哪些发生了改变的原因，因为它根据state的变化会立即知道。这个过程减少了DOM操作，并让应用程序变得更平滑。我们知道DOM操作是非常耗性能的，更少的DOM操作意味着更高效的渲染。React在底层实现了一个diffing算法，该算法使用DOM的树形表示法，当某个 节点发生变化（标记为dirty）时它会重新计算整个子树，你会注意到你的模型发生了改变，因为整个子树在之后会被重新渲染。</p>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><p>JSX是什么鬼？？？JSX是一个看起来很像XML的JavaScript语法扩展。React可以用来做简单的JSX句法转换。React提供了（也是建议使用）JSX代替JS进行组件绘制，然后运行的时候使用一个JSX编译器进行转换。JSX的使用还是比较简单的：<br>要渲染 HTML 标签，只需在 JSX 里使用小写字母开头的标签名。<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myDivElement = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"foo\"</span> /&gt;</span>;</span></div><div class=\"line\">React.render(myDivElement, document.body);</div></pre></td></tr></table></figure></p>\n<p>要渲染 React 组件，只需创建一个大写字母开头的本地变量。<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> MyComponent = React.createClass(&#123;<span class=\"comment\">/*一些代码*/</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> myElement = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">MyComponent</span> <span class=\"attr\">someProperty</span>=<span class=\"string\">&#123;true&#125;</span> /&gt;</span>;</span></div><div class=\"line\">React.render(myElement, document.body);</div></pre></td></tr></table></figure></p>\n<h1 id=\"本节结语\"><a href=\"#本节结语\" class=\"headerlink\" title=\"本节结语\"></a>本节结语</h1><p>关于React.js的入门介绍暂时到这里，想要更多地了解React.js的朋友可以进入<a href=\"http://reactjs.cn/\" target=\"_blank\" rel=\"external\">官方文档</a>进行学习。</p>\n","excerpt":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>WEB前端开发的发展历史大概经过了“原始时代——类库时代——工程构建时代——模块化时代”。目前前端领域的发展正处在一个空前繁荣的阶段——“模块化/组件化时代”。</p>\n<h2 id=\"原始时代\"><a href=\"#原始时代\" class=\"headerlink\" title=\"原始时代\"></a>原始时代</h2><p>曾几何时，前端开发在软件工程的技术栈里面只被视为设计类岗位，甚至现在为止也有一些小企业依然把前端的职责视为简单的编写html+css页面。早期的前端开发完全依赖于后端技术，所有的数据渲染都由后端开发者进行，界面源码和后台逻辑代码混在一起。这个时代的前端无疑是非常薄的，薄到“网页开发人员”的入门门槛几乎低至为零。<br>","more":"</p>\n<h2 id=\"类库时代\"><a href=\"#类库时代\" class=\"headerlink\" title=\"类库时代\"></a>类库时代</h2><p>这一阶段出现了对js封装的各种类库，代表作当然就是前端领域从业者无所不知的jquery库啦。类库时代的开发者承担了很大一部分数据交互的工作。借鉴于AJAX，开发过程可以实现很好的前后端分离，MVC开发框架日益盛行。这个时代，前端开发者在一定程度上摆脱了对后端的严重依赖，使得前后端开发依赖于接口，大大加快了开发效率。</p>\n<h2 id=\"工程构建时代\"><a href=\"#工程构建时代\" class=\"headerlink\" title=\"工程构建时代\"></a>工程构建时代</h2><p>基于各种自动化构建工具部署前端代码是这一时代的基本特征，前端发展到今天，自动化构建依然是当前的技术主流，Grunt,gulp.js以及国内的Fis等都是自动化代码优化和部署的热门工具。</p>\n<h2 id=\"模块化时代\"><a href=\"#模块化时代\" class=\"headerlink\" title=\"模块化时代\"></a>模块化时代</h2><p>模块化时代标志着前端开发正式进入工程化阶段，“前端工程师”正式成为名副其实的“工程师”。我之所以这样认为是因为这一阶段前端开发可以完全实现代码的重用，实现模块化开发，系统化、规范化的软件开发就是“软件工程”。所以前端工程师也就是在这一阶段日渐活跃，需求量也迅猛增长。前端模块时代的技术代表就是Require.js以及国内的sea.js这样的模块加载器。在MVC开发模式的基础上实现了对视图层的模块化开发，MVC框架至此达到一个鼎盛阶段。<br>然而前端之所以迷人在于新的开发模式和技术不会停止出现，不同的应用需求催生了新的开发技术的诞生。最近几年，组件化开发正成为前端领域的潮流，组件开发减少了代码的耦合，非常适合大型网站应用的开发（这类大型网站的特点就是大量的模块类似或者重复）。可实现代码高度重用的MVVM框架开发进入开发者眼中——这就是React.js的诞生背景</p>\n<h1 id=\"React-js\"><a href=\"#React-js\" class=\"headerlink\" title=\"React.js\"></a>React.js</h1><h2 id=\"React是什么东西？\"><a href=\"#React是什么东西？\" class=\"headerlink\" title=\"React是什么东西？\"></a>React是什么东西？</h2><p>来自官网的介绍：</p>\n<ul>\n<li>仅仅是UI<br>许多人使用React作为MVC架构的V层。尽管React并没有假设过你的其余技术栈，但它仍可以作为一个小特征轻易地在已有项目中使用。</li>\n<li>虚拟DOM<br>React为了更高超的性能而使用虚拟DOM作为其不同的实现。它同时也可以由服务端Node.js渲染而不需要过重的浏览器DOM支持。</li>\n<li>数据流<br>React实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。</li>\n</ul>\n<p>也就是说，React是一个视图层的应用，并且是一个高效的视图。React提供了和以往不一样的方式来看待视图，它以组件开发为基础。对React应用而言，你需要分割你的页面，使其成为一个个的组件。也就是说，你的应用是由这些组件组合而成的。组件本身可以实现数据流的的单向流动，实现独立开发。这就是我们所说的“组件驱动开发”。</p>\n<h2 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h2><p>React的一大特点是其所拥有的虚拟DOM，它让页面渲染变得非常的高效，并且比直接操纵DOM变得更为可控。由于虚拟DOM的绘制是在内存里面进行的，高效是它的特征。这两大特点的组合使得React具有强大的自上而下的页面渲染能力。</p>\n<p>React提供了一个观察者模型用于替代传统的脏检查（dirty checking）， 也就是持续的检查模型的变化。这也就是解释了为什么React不需要计算哪些发生了改变的原因，因为它根据state的变化会立即知道。这个过程减少了DOM操作，并让应用程序变得更平滑。我们知道DOM操作是非常耗性能的，更少的DOM操作意味着更高效的渲染。React在底层实现了一个diffing算法，该算法使用DOM的树形表示法，当某个 节点发生变化（标记为dirty）时它会重新计算整个子树，你会注意到你的模型发生了改变，因为整个子树在之后会被重新渲染。</p>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><p>JSX是什么鬼？？？JSX是一个看起来很像XML的JavaScript语法扩展。React可以用来做简单的JSX句法转换。React提供了（也是建议使用）JSX代替JS进行组件绘制，然后运行的时候使用一个JSX编译器进行转换。JSX的使用还是比较简单的：<br>要渲染 HTML 标签，只需在 JSX 里使用小写字母开头的标签名。<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myDivElement = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"foo\"</span> /&gt;</span>;</div><div class=\"line\">React.render(myDivElement, document.body);</span></div></pre></td></tr></table></figure></p>\n<p>要渲染 React 组件，只需创建一个大写字母开头的本地变量。<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> MyComponent = React.createClass(&#123;<span class=\"comment\">/*一些代码*/</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> myElement = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">MyComponent</span> <span class=\"attr\">someProperty</span>=<span class=\"string\">&#123;true&#125;</span> /&gt;</span>;</div><div class=\"line\">React.render(myElement, document.body);</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"本节结语\"><a href=\"#本节结语\" class=\"headerlink\" title=\"本节结语\"></a>本节结语</h1><p>关于React.js的入门介绍暂时到这里，想要更多地了解React.js的朋友可以进入<a href=\"http://reactjs.cn/\">官方文档</a>进行学习。</p>"},{"title":"React.js那些事(入门篇)","date":"2015-09-14T10:59:50.000Z","_content":"\n关于React.js的相关背景知识以及它的核心概念已经在[上一篇文章](http://hugzh.github.io/2015/09/11/React-js%E9%82%A3%E4%BA%9B%E4%BA%8B-%E4%BB%8B%E7%BB%8D%E7%AF%87/)里面说过。在这一篇里面，我通过一个组件开发的实例简单介绍如何使用React进行web组件开发。\n\n先来介绍一下这个打算实现的组件的功能：这是一个简单的三列表格，包含用户id，用户名，电话号码三列。当用户点击表头thead的单元时，表格会根据点中的列的字段进行升序排序。\n<!--more-->\n三军未动，先上demo：\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/hugzh/6jzz77de/3/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n## 第一步：划分组件\n首先，我们需要将整个组件划分为几个子组件，这是组件开发的重要思想——拆分组合。这是实现组件重用的关键技术。根据案例的原型，我将组件划分如下：\n![table partion](http://huguozhi-media.stor.sinaapp.com/mygitio%2Ftable.JPG)\n最外层的组件是我需要的目标组件 ——TableComponent，由绿色部分和黄色部分组成;\n绿色部分为组件Thead，由三个相同的组件TheadCell构成(红色);\n黄色部分为组件Tbody,每一行是一个组件Cell(蓝色)；\n红色部分—— TheadCell;\n蓝色部分—— Cell;\n\n\n## 第二步：组件绘制\n组件绘制非常简单，首先需要引入react.js文件以及TSX转换器文件JSXTransformer.js。然后，创建一个组件只需要调用一个函数React.createClass()即可，可以从外层到里层构件或者从里层到外层构件。比如，我先构造组件TheadCell:\n\n```\nvar  TheadCell = React.createClass({\n    render: function (){\n        return (\n            <th ref=\"getSortKey\" title=\"点击此键进行排序\">{this.props.content}</th>\n        );\n    }\n}) \n```\n这样就可以构造出一个Thead组件了，它的UI表现就是一个表头的 th 元素。一个组件的数据内容由该组件的父级传递过来，父级传递给子级的数据是通过 props 对象来传递的。然后子级组件通过this.props来读取数据对象的内容。父级组件传递数据对象给子级组件的方法也很简单，只要在组件传入一个属性值即可。在这里，TheadCell的父级组件为Thead，创建它并传递数据给TheadCell：\n```\nvar  Thead = React.createClass({\n    render: function (){\n        return (\n            <thead>\n                <caption>点击表格头部进行排序</caption>\n                <tr>\n                    <TheadCell content={this.props.uid} />\n                    <TheadCell content={this.props.name} />\n                    <TheadCell content={this.props.tel} />\n                </tr>\n            </thead>\n        );\n    }\n});\n```\n这样，Thead包含了三个子组件TheadCell，然后类似XML的标签语法定义组件的“属性”——content。在这里，content的值来自Thead的父级组件TableComponent。\n同样的道理，创建剩下的所有静态组件：\n\n创建Cell：\n```\nvar Cell  = React.createClass({\n    render: function(){\n        return (\n            <tr>\n                <td>{this.props.userItem.uid}</td>\n                <td>{this.props.userItem.name}</td>\n                <td>{this.props.userItem.tel}</td>\n            </tr>\n        );\n    }\n});\n```\n创建Tbody:\n```\nvar Tbody = React.createClass({\n    render: function (){\n        var row = [],\n            userlist = this.props.items;\n        for(var item in userlist){\n            row.push(<Cell userItem={this.props.items[item]} key={item}/>);\n        }\n\n        return(\n            <tbody>\n                {row}\n            </tbody>\n        );\n    }\n});\n```\n创建TableComponent:\n```\nvar TableComponent = React.createClass({\n    render: function (){\n        return (\n            <table>\n                <Thead  uid=\"uid\" name=\"name\" tel=\"tel\"/>\n                <Tbody items={this.props.data}/>\n            </table>\n        );\n    }\n});\n```\n在这个地方，为了方便，我省略了从服务器加载数据的步骤，直接声明一个静态数据：\n```\nvar USERS = [\n    {\"uid\":4,\"name\":\"zhut\",\"tel\":\"13899994567\"},\n    {\"uid\":2,\"name\":\"xiaom\",\"tel\":\"13580889999\"},\n    {\"uid\":3,\"name\":\"Brand\",\"tel\":\"15918446402\"},\n    {\"uid\":1,\"name\":\"defan\",\"tel\":\"18913145678\"}\n ];\n```\n最后，把组件渲染到html页面上。静态组件也就绘制完成了：\n```\nReact.render(<TableComponent data={USERS} />,document.getElementById(\"content\"));\n```\n\n## 第三步：识别UI的state\nstate是组件私有的，可以通过调用 this.setState() 来改变它。当状态更新之后，组件重新渲染自己。也就是说每当state改变之后，React的虚拟DOM机制就会感知到变化然后重新绘制UI。由于虚拟DOM操作是在内存里面，这就使得UI的重新绘制非常地高效快捷。这是React的精髓所在。\n好了，寻找state的三步法：\n* 是否是从父级通过 props 传入的？如果是，可能不是 state 。\n* 是否会随着时间改变？如果不是，可能不是 state 。\n* 能根据组件中其它 state 数据或者 props 计算出来吗？如果是，就不是 state 。\n\n在这里，我们的组件是随着TheadCell被点击，整个组件重新排序。所以Thead组件的变化必须影响到Tbody的状态。所以我们把state设置在Thead和Tbody的父级组件TableComponent上。\n```\nvar TableComponent = React.createClass({\n    getInitialState: function (){\n        return {\n            sortBy:''\n        };\n    },\n    render: function (){\n        return (\n            <table>\n                <Thead uid=\"uid\" name=\"name\" tel=\"tel\"/>\n                <Tbody items={this.props.data} sortBy={this.state.sortBy}/>\n            </table>\n        );\n    }\n});\n```\ngetInitialState 初始化组件的state，然后传递给子级Tbody。\n\n## 第四步：添加反向数据流\nstate的动态变化才会导致组件重新绘制，所以发生在组件点击事件必须要能改变组件的state，组件树中层级很深的表单组件TheadCell需要更新 TableComponent 中的 state 。\n```\nvar TableComponent = React.createClass({\n    getInitialState: function (){\n        return {\n            sortBy:''\n        };\n    },\n    handleClick: function(value){\n        this.setState({\n            sortBy:value\n        });\n    },\n    render: function (){\n        return (\n            <table>\n                <Thead  sort={this.handleClick} uid=\"uid\" name=\"name\" tel=\"tel\"/>\n                <Tbody items={this.props.data} sortBy={this.state.sortBy}/>\n            </table>\n        );\n    }\n});\n```\n这里，传递给子级组件Thead一个回调函数handleClick，回调函数触发时调用this.setState()来改变组件的state。由于点击事件是绑定在Thead的子级TheadCell上的，所以我这里的处理方法就是让Thead把回调函数handleClick再传递给下一子级TheadCell。Thead是这样子处理的：\n```\nvar  Thead = React.createClass({\n    returnSort: function(v){\n        this.props.sort(v);\n    },\n    render: function (){\n        return (\n            <thead>\n                <caption>点击表格头部进行排序</caption>\n                <tr>\n                    <TheadCell bubbleClick={this.returnSort} content={this.props.uid} />\n                    <TheadCell bubbleClick={this.returnSort} content={this.props.name} />\n                    <TheadCell bubbleClick={this.returnSort} content={this.props.tel} />\n                </tr>\n            </thead>\n        );\n    }\n});\n```\n把TheadCell的回调作为回调sort的一个过渡。\n\n最后，需要知道鼠标点击的是哪一个表头字段（uid,name还是tel）。React提供的获取标签值得方法是refs，所以 th 标签需要知道一个ref属性，我把它的值叫做getSortKey，也就是用来排序的字段。通过getDOMNode获取到UI的具体节点。在这里需要说明的一点就是，React里面给标签对象注册事件必须使用基于元素的DOM0级事件注册，而且是用驼峰格式。比如注册点击事件onClick。\n```\nvar  TheadCell = React.createClass({\n    handler: function(){\n        this.props.bubbleClick(this.refs.getSortKey.getDOMNode().innerHTML);\n    },\n    render: function (){\n        return (\n            <th ref=\"getSortKey\" title=\"点击此键进行排序\" onClick={this.handler}>{this.props.content}</th>\n        );\n    }\n}) \n```\n\n接下来就是双向数据流绑定的重要一步，也就是组件state改变之后UI如何实时响应并重新渲染绘制。这一步是发生在Tbody组件上面的，关键的地方在于表格tbody的绘制必须要由state计算而来，这样state的改变才会导致UI的重新绘制：\n```\nvar Tbody = React.createClass({\n    render: function (){\n        var row = [],\n            userlist = this.props.items,\n                cmpKey = \"\",\n                    sortBy = this.props.sortBy;\n        // 获取需要拿来比较的字段\n        for (it in userlist[0]){\n            if(sortBy == it){\n                cmpKey = it;\n            }\n        }\n\n        // 如果有排序键，进行排序\n        if (cmpKey){\n            userlist.sort(function (a,b){\n                if(a[cmpKey] < b[cmpKey]){\n                    return -1;\n                }\n                if(a[cmpKey] > b[cmpKey]){\n                    return 1;\n                }\n                return 0;\n            });\n        }\n        \n        // 排序后的table\n        for(var item in userlist){\n            row.push(<Cell userItem={this.props.items[item]} key={item}/>);\n        }\n\n        return(\n            <tbody>\n                {row}\n            </tbody>\n        );\n    }\n});\n```\n\n# 本篇结语\n这一篇主要是介绍怎么样去使用React制作组件，这是入门级别的说明。想要更多地了解React.js的朋友可以进入[官方文档](http://reactjs.cn/)进行深入学习。\n\n","source":"_posts/2015-09-14-React-js那些事-入门篇.md","raw":"title: React.js那些事(入门篇)\ndate: 2015-09-14 18:59:50\ntags:\n    - React\n    - 组件化开发\ncategories:\n    - 前端开发\n---\n\n关于React.js的相关背景知识以及它的核心概念已经在[上一篇文章](http://hugzh.github.io/2015/09/11/React-js%E9%82%A3%E4%BA%9B%E4%BA%8B-%E4%BB%8B%E7%BB%8D%E7%AF%87/)里面说过。在这一篇里面，我通过一个组件开发的实例简单介绍如何使用React进行web组件开发。\n\n先来介绍一下这个打算实现的组件的功能：这是一个简单的三列表格，包含用户id，用户名，电话号码三列。当用户点击表头thead的单元时，表格会根据点中的列的字段进行升序排序。\n<!--more-->\n三军未动，先上demo：\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/hugzh/6jzz77de/3/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n## 第一步：划分组件\n首先，我们需要将整个组件划分为几个子组件，这是组件开发的重要思想——拆分组合。这是实现组件重用的关键技术。根据案例的原型，我将组件划分如下：\n![table partion](http://huguozhi-media.stor.sinaapp.com/mygitio%2Ftable.JPG)\n最外层的组件是我需要的目标组件 ——TableComponent，由绿色部分和黄色部分组成;\n绿色部分为组件Thead，由三个相同的组件TheadCell构成(红色);\n黄色部分为组件Tbody,每一行是一个组件Cell(蓝色)；\n红色部分—— TheadCell;\n蓝色部分—— Cell;\n\n\n## 第二步：组件绘制\n组件绘制非常简单，首先需要引入react.js文件以及TSX转换器文件JSXTransformer.js。然后，创建一个组件只需要调用一个函数React.createClass()即可，可以从外层到里层构件或者从里层到外层构件。比如，我先构造组件TheadCell:\n\n```\nvar  TheadCell = React.createClass({\n    render: function (){\n        return (\n            <th ref=\"getSortKey\" title=\"点击此键进行排序\">{this.props.content}</th>\n        );\n    }\n}) \n```\n这样就可以构造出一个Thead组件了，它的UI表现就是一个表头的 th 元素。一个组件的数据内容由该组件的父级传递过来，父级传递给子级的数据是通过 props 对象来传递的。然后子级组件通过this.props来读取数据对象的内容。父级组件传递数据对象给子级组件的方法也很简单，只要在组件传入一个属性值即可。在这里，TheadCell的父级组件为Thead，创建它并传递数据给TheadCell：\n```\nvar  Thead = React.createClass({\n    render: function (){\n        return (\n            <thead>\n                <caption>点击表格头部进行排序</caption>\n                <tr>\n                    <TheadCell content={this.props.uid} />\n                    <TheadCell content={this.props.name} />\n                    <TheadCell content={this.props.tel} />\n                </tr>\n            </thead>\n        );\n    }\n});\n```\n这样，Thead包含了三个子组件TheadCell，然后类似XML的标签语法定义组件的“属性”——content。在这里，content的值来自Thead的父级组件TableComponent。\n同样的道理，创建剩下的所有静态组件：\n\n创建Cell：\n```\nvar Cell  = React.createClass({\n    render: function(){\n        return (\n            <tr>\n                <td>{this.props.userItem.uid}</td>\n                <td>{this.props.userItem.name}</td>\n                <td>{this.props.userItem.tel}</td>\n            </tr>\n        );\n    }\n});\n```\n创建Tbody:\n```\nvar Tbody = React.createClass({\n    render: function (){\n        var row = [],\n            userlist = this.props.items;\n        for(var item in userlist){\n            row.push(<Cell userItem={this.props.items[item]} key={item}/>);\n        }\n\n        return(\n            <tbody>\n                {row}\n            </tbody>\n        );\n    }\n});\n```\n创建TableComponent:\n```\nvar TableComponent = React.createClass({\n    render: function (){\n        return (\n            <table>\n                <Thead  uid=\"uid\" name=\"name\" tel=\"tel\"/>\n                <Tbody items={this.props.data}/>\n            </table>\n        );\n    }\n});\n```\n在这个地方，为了方便，我省略了从服务器加载数据的步骤，直接声明一个静态数据：\n```\nvar USERS = [\n    {\"uid\":4,\"name\":\"zhut\",\"tel\":\"13899994567\"},\n    {\"uid\":2,\"name\":\"xiaom\",\"tel\":\"13580889999\"},\n    {\"uid\":3,\"name\":\"Brand\",\"tel\":\"15918446402\"},\n    {\"uid\":1,\"name\":\"defan\",\"tel\":\"18913145678\"}\n ];\n```\n最后，把组件渲染到html页面上。静态组件也就绘制完成了：\n```\nReact.render(<TableComponent data={USERS} />,document.getElementById(\"content\"));\n```\n\n## 第三步：识别UI的state\nstate是组件私有的，可以通过调用 this.setState() 来改变它。当状态更新之后，组件重新渲染自己。也就是说每当state改变之后，React的虚拟DOM机制就会感知到变化然后重新绘制UI。由于虚拟DOM操作是在内存里面，这就使得UI的重新绘制非常地高效快捷。这是React的精髓所在。\n好了，寻找state的三步法：\n* 是否是从父级通过 props 传入的？如果是，可能不是 state 。\n* 是否会随着时间改变？如果不是，可能不是 state 。\n* 能根据组件中其它 state 数据或者 props 计算出来吗？如果是，就不是 state 。\n\n在这里，我们的组件是随着TheadCell被点击，整个组件重新排序。所以Thead组件的变化必须影响到Tbody的状态。所以我们把state设置在Thead和Tbody的父级组件TableComponent上。\n```\nvar TableComponent = React.createClass({\n    getInitialState: function (){\n        return {\n            sortBy:''\n        };\n    },\n    render: function (){\n        return (\n            <table>\n                <Thead uid=\"uid\" name=\"name\" tel=\"tel\"/>\n                <Tbody items={this.props.data} sortBy={this.state.sortBy}/>\n            </table>\n        );\n    }\n});\n```\ngetInitialState 初始化组件的state，然后传递给子级Tbody。\n\n## 第四步：添加反向数据流\nstate的动态变化才会导致组件重新绘制，所以发生在组件点击事件必须要能改变组件的state，组件树中层级很深的表单组件TheadCell需要更新 TableComponent 中的 state 。\n```\nvar TableComponent = React.createClass({\n    getInitialState: function (){\n        return {\n            sortBy:''\n        };\n    },\n    handleClick: function(value){\n        this.setState({\n            sortBy:value\n        });\n    },\n    render: function (){\n        return (\n            <table>\n                <Thead  sort={this.handleClick} uid=\"uid\" name=\"name\" tel=\"tel\"/>\n                <Tbody items={this.props.data} sortBy={this.state.sortBy}/>\n            </table>\n        );\n    }\n});\n```\n这里，传递给子级组件Thead一个回调函数handleClick，回调函数触发时调用this.setState()来改变组件的state。由于点击事件是绑定在Thead的子级TheadCell上的，所以我这里的处理方法就是让Thead把回调函数handleClick再传递给下一子级TheadCell。Thead是这样子处理的：\n```\nvar  Thead = React.createClass({\n    returnSort: function(v){\n        this.props.sort(v);\n    },\n    render: function (){\n        return (\n            <thead>\n                <caption>点击表格头部进行排序</caption>\n                <tr>\n                    <TheadCell bubbleClick={this.returnSort} content={this.props.uid} />\n                    <TheadCell bubbleClick={this.returnSort} content={this.props.name} />\n                    <TheadCell bubbleClick={this.returnSort} content={this.props.tel} />\n                </tr>\n            </thead>\n        );\n    }\n});\n```\n把TheadCell的回调作为回调sort的一个过渡。\n\n最后，需要知道鼠标点击的是哪一个表头字段（uid,name还是tel）。React提供的获取标签值得方法是refs，所以 th 标签需要知道一个ref属性，我把它的值叫做getSortKey，也就是用来排序的字段。通过getDOMNode获取到UI的具体节点。在这里需要说明的一点就是，React里面给标签对象注册事件必须使用基于元素的DOM0级事件注册，而且是用驼峰格式。比如注册点击事件onClick。\n```\nvar  TheadCell = React.createClass({\n    handler: function(){\n        this.props.bubbleClick(this.refs.getSortKey.getDOMNode().innerHTML);\n    },\n    render: function (){\n        return (\n            <th ref=\"getSortKey\" title=\"点击此键进行排序\" onClick={this.handler}>{this.props.content}</th>\n        );\n    }\n}) \n```\n\n接下来就是双向数据流绑定的重要一步，也就是组件state改变之后UI如何实时响应并重新渲染绘制。这一步是发生在Tbody组件上面的，关键的地方在于表格tbody的绘制必须要由state计算而来，这样state的改变才会导致UI的重新绘制：\n```\nvar Tbody = React.createClass({\n    render: function (){\n        var row = [],\n            userlist = this.props.items,\n                cmpKey = \"\",\n                    sortBy = this.props.sortBy;\n        // 获取需要拿来比较的字段\n        for (it in userlist[0]){\n            if(sortBy == it){\n                cmpKey = it;\n            }\n        }\n\n        // 如果有排序键，进行排序\n        if (cmpKey){\n            userlist.sort(function (a,b){\n                if(a[cmpKey] < b[cmpKey]){\n                    return -1;\n                }\n                if(a[cmpKey] > b[cmpKey]){\n                    return 1;\n                }\n                return 0;\n            });\n        }\n        \n        // 排序后的table\n        for(var item in userlist){\n            row.push(<Cell userItem={this.props.items[item]} key={item}/>);\n        }\n\n        return(\n            <tbody>\n                {row}\n            </tbody>\n        );\n    }\n});\n```\n\n# 本篇结语\n这一篇主要是介绍怎么样去使用React制作组件，这是入门级别的说明。想要更多地了解React.js的朋友可以进入[官方文档](http://reactjs.cn/)进行深入学习。\n\n","slug":"2015-09-14-React-js那些事-入门篇","published":1,"updated":"2016-08-13T03:08:44.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtqg00057kaulycxjw51","content":"<p>关于React.js的相关背景知识以及它的核心概念已经在<a href=\"http://hugzh.github.io/2015/09/11/React-js%E9%82%A3%E4%BA%9B%E4%BA%8B-%E4%BB%8B%E7%BB%8D%E7%AF%87/\" target=\"_blank\" rel=\"external\">上一篇文章</a>里面说过。在这一篇里面，我通过一个组件开发的实例简单介绍如何使用React进行web组件开发。</p>\n<p>先来介绍一下这个打算实现的组件的功能：这是一个简单的三列表格，包含用户id，用户名，电话号码三列。当用户点击表头thead的单元时，表格会根据点中的列的字段进行升序排序。<br><a id=\"more\"></a><br>三军未动，先上demo：</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/hugzh/6jzz77de/3/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<h2 id=\"第一步：划分组件\"><a href=\"#第一步：划分组件\" class=\"headerlink\" title=\"第一步：划分组件\"></a>第一步：划分组件</h2><p>首先，我们需要将整个组件划分为几个子组件，这是组件开发的重要思想——拆分组合。这是实现组件重用的关键技术。根据案例的原型，我将组件划分如下：<br><img src=\"http://huguozhi-media.stor.sinaapp.com/mygitio%2Ftable.JPG\" alt=\"table partion\"><br>最外层的组件是我需要的目标组件 ——TableComponent，由绿色部分和黄色部分组成;<br>绿色部分为组件Thead，由三个相同的组件TheadCell构成(红色);<br>黄色部分为组件Tbody,每一行是一个组件Cell(蓝色)；<br>红色部分—— TheadCell;<br>蓝色部分—— Cell;</p>\n<h2 id=\"第二步：组件绘制\"><a href=\"#第二步：组件绘制\" class=\"headerlink\" title=\"第二步：组件绘制\"></a>第二步：组件绘制</h2><p>组件绘制非常简单，首先需要引入react.js文件以及TSX转换器文件JSXTransformer.js。然后，创建一个组件只需要调用一个函数React.createClass()即可，可以从外层到里层构件或者从里层到外层构件。比如，我先构造组件TheadCell:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span>  TheadCell = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"getSortKey\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"点击此键进行排序\"</span>&gt;</span>&#123;this.props.content&#125;<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样就可以构造出一个Thead组件了，它的UI表现就是一个表头的 th 元素。一个组件的数据内容由该组件的父级传递过来，父级传递给子级的数据是通过 props 对象来传递的。然后子级组件通过this.props来读取数据对象的内容。父级组件传递数据对象给子级组件的方法也很简单，只要在组件传入一个属性值即可。在这里，TheadCell的父级组件为Thead，创建它并传递数据给TheadCell：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var  Thead = React.createClass(&#123;</div><div class=\"line\">    render: function ()&#123;</div><div class=\"line\">        return (</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">caption</span>&gt;</span>点击表格头部进行排序<span class=\"tag\">&lt;/<span class=\"name\">caption</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">TheadCell</span> <span class=\"attr\">content</span>=<span class=\"string\">&#123;this.props.uid&#125;</span> /&gt;</span></div><div class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">TheadCell</span> <span class=\"attr\">content</span>=<span class=\"string\">&#123;this.props.name&#125;</span> /&gt;</span></div><div class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">TheadCell</span> <span class=\"attr\">content</span>=<span class=\"string\">&#123;this.props.tel&#125;</span> /&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这样，Thead包含了三个子组件TheadCell，然后类似XML的标签语法定义组件的“属性”——content。在这里，content的值来自Thead的父级组件TableComponent。<br>同样的道理，创建剩下的所有静态组件：</p>\n<p>创建Cell：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Cell  = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>&#123;this.props.userItem.uid&#125;<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>&#123;this.props.userItem.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>&#123;this.props.userItem.tel&#125;<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>创建Tbody:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Tbody = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> row = [],</div><div class=\"line\">            userlist = <span class=\"keyword\">this</span>.props.items;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> userlist)&#123;</div><div class=\"line\">            row.push(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Cell</span> <span class=\"attr\">userItem</span>=<span class=\"string\">&#123;this.props.items[item]&#125;</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;item&#125;/</span>&gt;</span>);</span></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return(</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">                &#123;row&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>创建TableComponent:<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> TableComponent = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;table&gt;</div><div class=\"line\">                &lt;Thead  uid=<span class=\"string\">\"uid\"</span> name=<span class=\"string\">\"name\"</span> tel=<span class=\"string\">\"tel\"</span>/&gt;</div><div class=\"line\">                &lt;Tbody items=&#123;<span class=\"keyword\">this</span>.props.data&#125;/&gt;</div><div class=\"line\">            &lt;/table&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>在这个地方，为了方便，我省略了从服务器加载数据的步骤，直接声明一个静态数据：<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var USERS = [</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">4</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"zhut\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"13899994567\"</span>&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">2</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"xiaom\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"13580889999\"</span>&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">3</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Brand\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"15918446402\"</span>&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"defan\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"18913145678\"</span>&#125;</div><div class=\"line\"> ];</div></pre></td></tr></table></figure></p>\n<p>最后，把组件渲染到html页面上。静态组件也就绘制完成了：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">React</span><span class=\"selector-class\">.render</span>(&lt;TableComponent data=&#123;USERS&#125; /&gt;,document.getElementById(<span class=\"string\">\"content\"</span>));</div></pre></td></tr></table></figure></p>\n<h2 id=\"第三步：识别UI的state\"><a href=\"#第三步：识别UI的state\" class=\"headerlink\" title=\"第三步：识别UI的state\"></a>第三步：识别UI的state</h2><p>state是组件私有的，可以通过调用 this.setState() 来改变它。当状态更新之后，组件重新渲染自己。也就是说每当state改变之后，React的虚拟DOM机制就会感知到变化然后重新绘制UI。由于虚拟DOM操作是在内存里面，这就使得UI的重新绘制非常地高效快捷。这是React的精髓所在。<br>好了，寻找state的三步法：</p>\n<ul>\n<li>是否是从父级通过 props 传入的？如果是，可能不是 state 。</li>\n<li>是否会随着时间改变？如果不是，可能不是 state 。</li>\n<li>能根据组件中其它 state 数据或者 props 计算出来吗？如果是，就不是 state 。</li>\n</ul>\n<p>在这里，我们的组件是随着TheadCell被点击，整个组件重新排序。所以Thead组件的变化必须影响到Tbody的状态。所以我们把state设置在Thead和Tbody的父级组件TableComponent上。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> TableComponent = React.createClass(&#123;</div><div class=\"line\">    getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            sortBy:<span class=\"string\">''</span></div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;table&gt;</div><div class=\"line\">                &lt;Thead uid=<span class=\"string\">\"uid\"</span> name=<span class=\"string\">\"name\"</span> tel=<span class=\"string\">\"tel\"</span>/&gt;</div><div class=\"line\">                &lt;Tbody items=&#123;<span class=\"keyword\">this</span>.props.data&#125; sortBy=&#123;<span class=\"keyword\">this</span>.state.sortBy&#125;/&gt;</div><div class=\"line\">            &lt;/table&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>getInitialState 初始化组件的state，然后传递给子级Tbody。</p>\n<h2 id=\"第四步：添加反向数据流\"><a href=\"#第四步：添加反向数据流\" class=\"headerlink\" title=\"第四步：添加反向数据流\"></a>第四步：添加反向数据流</h2><p>state的动态变化才会导致组件重新绘制，所以发生在组件点击事件必须要能改变组件的state，组件树中层级很深的表单组件TheadCell需要更新 TableComponent 中的 state 。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> TableComponent = React.createClass(&#123;</div><div class=\"line\">    getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            sortBy:<span class=\"string\">''</span></div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    handleClick: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(value)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</div><div class=\"line\">            sortBy:value</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;table&gt;</div><div class=\"line\">                &lt;Thead  sort=&#123;<span class=\"keyword\">this</span>.handleClick&#125; uid=<span class=\"string\">\"uid\"</span> name=<span class=\"string\">\"name\"</span> tel=<span class=\"string\">\"tel\"</span>/&gt;</div><div class=\"line\">                &lt;Tbody items=&#123;<span class=\"keyword\">this</span>.props.data&#125; sortBy=&#123;<span class=\"keyword\">this</span>.state.sortBy&#125;/&gt;</div><div class=\"line\">            &lt;/table&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这里，传递给子级组件Thead一个回调函数handleClick，回调函数触发时调用this.setState()来改变组件的state。由于点击事件是绑定在Thead的子级TheadCell上的，所以我这里的处理方法就是让Thead把回调函数handleClick再传递给下一子级TheadCell。Thead是这样子处理的：<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span>  Thead = React.createClass(&#123;</div><div class=\"line\">    returnSort: function(v)&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.props.sort(v);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: function ()&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;thead&gt;</div><div class=\"line\">                &lt;caption&gt;点击表格头部进行排序&lt;/caption&gt;</div><div class=\"line\">                &lt;tr&gt;</div><div class=\"line\">                    &lt;TheadCell bubbleClick=&#123;<span class=\"keyword\">this</span>.returnSort&#125; content=&#123;<span class=\"keyword\">this</span>.props.uid&#125; /&gt;</div><div class=\"line\">                    &lt;TheadCell bubbleClick=&#123;<span class=\"keyword\">this</span>.returnSort&#125; content=&#123;<span class=\"keyword\">this</span>.props.name&#125; /&gt;</div><div class=\"line\">                    &lt;TheadCell bubbleClick=&#123;<span class=\"keyword\">this</span>.returnSort&#125; content=&#123;<span class=\"keyword\">this</span>.props.tel&#125; /&gt;</div><div class=\"line\">                &lt;/tr&gt;</div><div class=\"line\">            &lt;/thead&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>把TheadCell的回调作为回调sort的一个过渡。</p>\n<p>最后，需要知道鼠标点击的是哪一个表头字段（uid,name还是tel）。React提供的获取标签值得方法是refs，所以 th 标签需要知道一个ref属性，我把它的值叫做getSortKey，也就是用来排序的字段。通过getDOMNode获取到UI的具体节点。在这里需要说明的一点就是，React里面给标签对象注册事件必须使用基于元素的DOM0级事件注册，而且是用驼峰格式。比如注册点击事件onClick。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span>  TheadCell = React.createClass(&#123;</div><div class=\"line\">    handler: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.props.bubbleClick(<span class=\"keyword\">this</span>.refs.getSortKey.getDOMNode().innerHTML);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"getSortKey\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"点击此键进行排序\"</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handler&#125;</span>&gt;</span>&#123;this.props.content&#125;<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>接下来就是双向数据流绑定的重要一步，也就是组件state改变之后UI如何实时响应并重新渲染绘制。这一步是发生在Tbody组件上面的，关键的地方在于表格tbody的绘制必须要由state计算而来，这样state的改变才会导致UI的重新绘制：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Tbody = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> row = [],</div><div class=\"line\">            userlist = <span class=\"keyword\">this</span>.props.items,</div><div class=\"line\">                cmpKey = <span class=\"string\">\"\"</span>,</div><div class=\"line\">                    sortBy = <span class=\"keyword\">this</span>.props.sortBy;</div><div class=\"line\">        <span class=\"comment\">// 获取需要拿来比较的字段</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (it <span class=\"keyword\">in</span> userlist[<span class=\"number\">0</span>])&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(sortBy == it)&#123;</div><div class=\"line\">                cmpKey = it;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果有排序键，进行排序</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (cmpKey)&#123;</div><div class=\"line\">            userlist.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a,b</span>)</span>&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>(a[cmpKey] &lt; b[cmpKey])&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span>(a[cmpKey] &gt; b[cmpKey])&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 排序后的table</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> userlist)&#123;</div><div class=\"line\">            row.push(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Cell</span> <span class=\"attr\">userItem</span>=<span class=\"string\">&#123;this.props.items[item]&#125;</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;item&#125;/</span>&gt;</span>);</span></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return(</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">                &#123;row&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h1 id=\"本篇结语\"><a href=\"#本篇结语\" class=\"headerlink\" title=\"本篇结语\"></a>本篇结语</h1><p>这一篇主要是介绍怎么样去使用React制作组件，这是入门级别的说明。想要更多地了解React.js的朋友可以进入<a href=\"http://reactjs.cn/\" target=\"_blank\" rel=\"external\">官方文档</a>进行深入学习。</p>\n","excerpt":"<p>关于React.js的相关背景知识以及它的核心概念已经在<a href=\"http://hugzh.github.io/2015/09/11/React-js%E9%82%A3%E4%BA%9B%E4%BA%8B-%E4%BB%8B%E7%BB%8D%E7%AF%87/\">上一篇文章</a>里面说过。在这一篇里面，我通过一个组件开发的实例简单介绍如何使用React进行web组件开发。</p>\n<p>先来介绍一下这个打算实现的组件的功能：这是一个简单的三列表格，包含用户id，用户名，电话号码三列。当用户点击表头thead的单元时，表格会根据点中的列的字段进行升序排序。<br>","more":"<br>三军未动，先上demo：</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/hugzh/6jzz77de/3/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<h2 id=\"第一步：划分组件\"><a href=\"#第一步：划分组件\" class=\"headerlink\" title=\"第一步：划分组件\"></a>第一步：划分组件</h2><p>首先，我们需要将整个组件划分为几个子组件，这是组件开发的重要思想——拆分组合。这是实现组件重用的关键技术。根据案例的原型，我将组件划分如下：<br><img src=\"http://huguozhi-media.stor.sinaapp.com/mygitio%2Ftable.JPG\" alt=\"table partion\"><br>最外层的组件是我需要的目标组件 ——TableComponent，由绿色部分和黄色部分组成;<br>绿色部分为组件Thead，由三个相同的组件TheadCell构成(红色);<br>黄色部分为组件Tbody,每一行是一个组件Cell(蓝色)；<br>红色部分—— TheadCell;<br>蓝色部分—— Cell;</p>\n<h2 id=\"第二步：组件绘制\"><a href=\"#第二步：组件绘制\" class=\"headerlink\" title=\"第二步：组件绘制\"></a>第二步：组件绘制</h2><p>组件绘制非常简单，首先需要引入react.js文件以及TSX转换器文件JSXTransformer.js。然后，创建一个组件只需要调用一个函数React.createClass()即可，可以从外层到里层构件或者从里层到外层构件。比如，我先构造组件TheadCell:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span>  TheadCell = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"getSortKey\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"点击此键进行排序\"</span>&gt;</span>&#123;this.props.content&#125;<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样就可以构造出一个Thead组件了，它的UI表现就是一个表头的 th 元素。一个组件的数据内容由该组件的父级传递过来，父级传递给子级的数据是通过 props 对象来传递的。然后子级组件通过this.props来读取数据对象的内容。父级组件传递数据对象给子级组件的方法也很简单，只要在组件传入一个属性值即可。在这里，TheadCell的父级组件为Thead，创建它并传递数据给TheadCell：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var  Thead = React.createClass(&#123;</div><div class=\"line\">    render: function ()&#123;</div><div class=\"line\">        return (</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">caption</span>&gt;</span>点击表格头部进行排序<span class=\"tag\">&lt;/<span class=\"name\">caption</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">TheadCell</span> <span class=\"attr\">content</span>=<span class=\"string\">&#123;this.props.uid&#125;</span> /&gt;</span></div><div class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">TheadCell</span> <span class=\"attr\">content</span>=<span class=\"string\">&#123;this.props.name&#125;</span> /&gt;</span></div><div class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">TheadCell</span> <span class=\"attr\">content</span>=<span class=\"string\">&#123;this.props.tel&#125;</span> /&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这样，Thead包含了三个子组件TheadCell，然后类似XML的标签语法定义组件的“属性”——content。在这里，content的值来自Thead的父级组件TableComponent。<br>同样的道理，创建剩下的所有静态组件：</p>\n<p>创建Cell：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Cell  = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>&#123;this.props.userItem.uid&#125;<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>&#123;this.props.userItem.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>&#123;this.props.userItem.tel&#125;<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>创建Tbody:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Tbody = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> row = [],</div><div class=\"line\">            userlist = <span class=\"keyword\">this</span>.props.items;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> userlist)&#123;</div><div class=\"line\">            row.push(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Cell</span> <span class=\"attr\">userItem</span>=<span class=\"string\">&#123;this.props.items[item]&#125;</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;item&#125;/</span>&gt;</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return(</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">                &#123;row&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</span></div></pre></td></tr></table></figure></p>\n<p>创建TableComponent:<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> TableComponent = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;table&gt;</div><div class=\"line\">                &lt;Thead  uid=<span class=\"string\">\"uid\"</span> name=<span class=\"string\">\"name\"</span> tel=<span class=\"string\">\"tel\"</span>/&gt;</div><div class=\"line\">                &lt;Tbody items=&#123;<span class=\"keyword\">this</span>.props.data&#125;/&gt;</div><div class=\"line\">            &lt;/table&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>在这个地方，为了方便，我省略了从服务器加载数据的步骤，直接声明一个静态数据：<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var USERS = [</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">4</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"zhut\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"13899994567\"</span>&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">2</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"xiaom\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"13580889999\"</span>&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">3</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Brand\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"15918446402\"</span>&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"defan\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"18913145678\"</span>&#125;</div><div class=\"line\"> ];</div></pre></td></tr></table></figure></p>\n<p>最后，把组件渲染到html页面上。静态组件也就绘制完成了：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">React</span><span class=\"selector-class\">.render</span>(&lt;TableComponent data=&#123;USERS&#125; /&gt;,document.getElementById(<span class=\"string\">\"content\"</span>));</div></pre></td></tr></table></figure></p>\n<h2 id=\"第三步：识别UI的state\"><a href=\"#第三步：识别UI的state\" class=\"headerlink\" title=\"第三步：识别UI的state\"></a>第三步：识别UI的state</h2><p>state是组件私有的，可以通过调用 this.setState() 来改变它。当状态更新之后，组件重新渲染自己。也就是说每当state改变之后，React的虚拟DOM机制就会感知到变化然后重新绘制UI。由于虚拟DOM操作是在内存里面，这就使得UI的重新绘制非常地高效快捷。这是React的精髓所在。<br>好了，寻找state的三步法：</p>\n<ul>\n<li>是否是从父级通过 props 传入的？如果是，可能不是 state 。</li>\n<li>是否会随着时间改变？如果不是，可能不是 state 。</li>\n<li>能根据组件中其它 state 数据或者 props 计算出来吗？如果是，就不是 state 。</li>\n</ul>\n<p>在这里，我们的组件是随着TheadCell被点击，整个组件重新排序。所以Thead组件的变化必须影响到Tbody的状态。所以我们把state设置在Thead和Tbody的父级组件TableComponent上。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> TableComponent = React.createClass(&#123;</div><div class=\"line\">    getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            sortBy:<span class=\"string\">''</span></div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;table&gt;</div><div class=\"line\">                &lt;Thead uid=<span class=\"string\">\"uid\"</span> name=<span class=\"string\">\"name\"</span> tel=<span class=\"string\">\"tel\"</span>/&gt;</div><div class=\"line\">                &lt;Tbody items=&#123;<span class=\"keyword\">this</span>.props.data&#125; sortBy=&#123;<span class=\"keyword\">this</span>.state.sortBy&#125;/&gt;</div><div class=\"line\">            &lt;/table&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>getInitialState 初始化组件的state，然后传递给子级Tbody。</p>\n<h2 id=\"第四步：添加反向数据流\"><a href=\"#第四步：添加反向数据流\" class=\"headerlink\" title=\"第四步：添加反向数据流\"></a>第四步：添加反向数据流</h2><p>state的动态变化才会导致组件重新绘制，所以发生在组件点击事件必须要能改变组件的state，组件树中层级很深的表单组件TheadCell需要更新 TableComponent 中的 state 。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> TableComponent = React.createClass(&#123;</div><div class=\"line\">    getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            sortBy:<span class=\"string\">''</span></div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    handleClick: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(value)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</div><div class=\"line\">            sortBy:value</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;table&gt;</div><div class=\"line\">                &lt;Thead  sort=&#123;<span class=\"keyword\">this</span>.handleClick&#125; uid=<span class=\"string\">\"uid\"</span> name=<span class=\"string\">\"name\"</span> tel=<span class=\"string\">\"tel\"</span>/&gt;</div><div class=\"line\">                &lt;Tbody items=&#123;<span class=\"keyword\">this</span>.props.data&#125; sortBy=&#123;<span class=\"keyword\">this</span>.state.sortBy&#125;/&gt;</div><div class=\"line\">            &lt;/table&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这里，传递给子级组件Thead一个回调函数handleClick，回调函数触发时调用this.setState()来改变组件的state。由于点击事件是绑定在Thead的子级TheadCell上的，所以我这里的处理方法就是让Thead把回调函数handleClick再传递给下一子级TheadCell。Thead是这样子处理的：<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span>  Thead = React.createClass(&#123;</div><div class=\"line\">    returnSort: function(v)&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.props.sort(v);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: function ()&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;thead&gt;</div><div class=\"line\">                &lt;caption&gt;点击表格头部进行排序&lt;/caption&gt;</div><div class=\"line\">                &lt;tr&gt;</div><div class=\"line\">                    &lt;TheadCell bubbleClick=&#123;<span class=\"keyword\">this</span>.returnSort&#125; content=&#123;<span class=\"keyword\">this</span>.props.uid&#125; /&gt;</div><div class=\"line\">                    &lt;TheadCell bubbleClick=&#123;<span class=\"keyword\">this</span>.returnSort&#125; content=&#123;<span class=\"keyword\">this</span>.props.name&#125; /&gt;</div><div class=\"line\">                    &lt;TheadCell bubbleClick=&#123;<span class=\"keyword\">this</span>.returnSort&#125; content=&#123;<span class=\"keyword\">this</span>.props.tel&#125; /&gt;</div><div class=\"line\">                &lt;/tr&gt;</div><div class=\"line\">            &lt;/thead&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>把TheadCell的回调作为回调sort的一个过渡。</p>\n<p>最后，需要知道鼠标点击的是哪一个表头字段（uid,name还是tel）。React提供的获取标签值得方法是refs，所以 th 标签需要知道一个ref属性，我把它的值叫做getSortKey，也就是用来排序的字段。通过getDOMNode获取到UI的具体节点。在这里需要说明的一点就是，React里面给标签对象注册事件必须使用基于元素的DOM0级事件注册，而且是用驼峰格式。比如注册点击事件onClick。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span>  TheadCell = React.createClass(&#123;</div><div class=\"line\">    handler: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.props.bubbleClick(<span class=\"keyword\">this</span>.refs.getSortKey.getDOMNode().innerHTML);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"getSortKey\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"点击此键进行排序\"</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handler&#125;</span>&gt;</span>&#123;this.props.content&#125;<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>接下来就是双向数据流绑定的重要一步，也就是组件state改变之后UI如何实时响应并重新渲染绘制。这一步是发生在Tbody组件上面的，关键的地方在于表格tbody的绘制必须要由state计算而来，这样state的改变才会导致UI的重新绘制：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Tbody = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> row = [],</div><div class=\"line\">            userlist = <span class=\"keyword\">this</span>.props.items,</div><div class=\"line\">                cmpKey = <span class=\"string\">\"\"</span>,</div><div class=\"line\">                    sortBy = <span class=\"keyword\">this</span>.props.sortBy;</div><div class=\"line\">        <span class=\"comment\">// 获取需要拿来比较的字段</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (it <span class=\"keyword\">in</span> userlist[<span class=\"number\">0</span>])&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(sortBy == it)&#123;</div><div class=\"line\">                cmpKey = it;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果有排序键，进行排序</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (cmpKey)&#123;</div><div class=\"line\">            userlist.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a,b</span>)</span>&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>(a[cmpKey] &lt; b[cmpKey])&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span>(a[cmpKey] &gt; b[cmpKey])&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 排序后的table</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> userlist)&#123;</div><div class=\"line\">            row.push(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Cell</span> <span class=\"attr\">userItem</span>=<span class=\"string\">&#123;this.props.items[item]&#125;</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;item&#125;/</span>&gt;</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return(</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">                &#123;row&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"本篇结语\"><a href=\"#本篇结语\" class=\"headerlink\" title=\"本篇结语\"></a>本篇结语</h1><p>这一篇主要是介绍怎么样去使用React制作组件，这是入门级别的说明。想要更多地了解React.js的朋友可以进入<a href=\"http://reactjs.cn/\">官方文档</a>进行深入学习。</p>"},{"title":"单元测试工具Mocha和SuperTest组合","date":"2015-12-08T12:07:57.000Z","_content":"\n毕业季，一堆乱七八糟的事情搞得已经整整两个月没有时间写写笔记了。最近进行着一个Node小项目，其中关于单元测试部分花了不少时间去踩坑。所以在这里简单总结一下关于Node开发测试框架Mocha(摩卡)的一些基础用法。由于本人是入门级别的Node开发者，所以这篇文章也是仅适用于和我一样的初级Node开发者，如有不正确的地方欢迎大神们指正！\n\n## 一、Mocha\nMocha是非常流行JavaScript测试框架之一，在浏览器和Node环境都可以使用。这里主要是针对Node环境。\n<!--more-->\n### 1、安装\n关于Mocha的安装当然是万能的npm了，直接npm install就OK，这里不再罗嗦了。\n### 2、使用\n然后就是Mocha的语法了。首先来看一下最简单例子：\n```\n// 这是一个简单的加法函数\n//add.js\nfunction add(a, b){\n    return a+b;\n}\nmodule.exports = add;\n```\n现在用Mocha写一个测试脚本去测试这个函数。一般来说，测试脚本的命名要和测试的模块一致，后缀为.test.js。这里测试脚本的名称为add.test.js，表示对add模块进行测试。\n```\n//add.test.js\nvar add = require('./add');\nvar should = require('should');\n\ndescribe('test add', function() {\n    it('1 + 1 should be equal to 2', function(done){\n        (add(1,1) === 2).should.be.true;\n    });\n});\n```\n然后保存代码之后进入终端，执行mocha add.test 即可。其中describe()函数是测试描述，表示一组相关测试用例是对哪个模块的测试。it()是一个测试用例，在一个describe块的内部可以执行对个测试用例(it块)。\n\n这是同步函数的测试。在Node环境中，绝大部分的业务逻辑都是异步的，所以测试结果的回调是JavaScript测试框架需要解决的首要问题。Mocha提供了一个回调函数done，在业务代码执行完毕之后调用done()结束测试用例，不然的话测试用例就会出现timeout的情况导致测试用例失败。Mocha默认的超时时间是2000毫秒，如果由于测试用例的执行时间比较长需要延长超时时间，可以在命令行添加 -t 参数，比如mocha -t 3000 add.test.js。当然还有其他命令行参数，比如 mocha -w 用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。查看更多的命令行参数可以通过 mocha -h 查找。\n\n那么接下来看一个异步测试例子：\n```\ndescribe('test async function', function(){\n    it('supertest example', function(done){\n        request.post('/')\n        .expect(200)\n        .end(function(err, res) {\n            should.not.exist(err);\n            done();\n        })\n    })\n})\n```\n在request请求执行完毕end()之后，一定要调用done()，否则测试用例超时，那么这个用例就失败了。当然这里用到了断言库should，稍后再介绍它的语法。\n\n### 3、钩子(hooks)\nMocha的Hooks主要是用来设置前置条件和后置处理。比如说一个业务请求之前必须先登录，那个登录操作就在before()里面完成。Mocha提供了before,after,beforeEach,afterEach四个钩子。\n```\ndescribe('hooks', function() {\n  before(function() {\n    // runs before all tests in this block\n  });\n\n  after(function() {\n    // runs after all tests in this block\n  });\n\n  beforeEach(function() {\n    // runs before each test in this block\n  });\n\n  afterEach(function() {\n    // runs after each test in this block\n  });\n\n  it('test',function(done){\n    //test here\n  })\n});\n```\n如果说某个测试需要跳过，使用it.skip()，Mocha跳过这个用例而不影响其他it块；只测试某个测试用例，使用it.only()，Mocha只执行.only用例，无视其他it块。\n\n## 二、断言库should\nMocha本身是不包含断言库的，所以我们需要自己选择断言库。should是一个很简单的、贴近自然语言的断言库。当然，Mocha是适配所有的断言库的，如果你喜欢其他的断言库比如expect之类的，你也可以把它包含进来使用。\n\nshould的语法非常贴近自然语言，简单易懂，常见的should断言如下：\n```\n// 全等，相当于===\n.exactly\n(5).should.be.exactly(5)\n \n// 对象存在\n.ok\ntrue.should.be.ok;\n'yay'.should.be.ok;\n(1).should.be.ok;\n({}).should.be.ok;\nfalse.should.not.be.ok;\n\n// 真\n.true\n(5===5).should.be.true\n(err === null).should.be.true;\n\n// 相等,相当于 ==\n.eql\n({ foo: 'bar' }).should.eql({ foo: 'bar' });\n[1,2,3].should.eql([1,2,3]);\n// see next example it is correct, even if it is different types, but actual content the same\n[1, 2, 3].should.eql({ '0': 1, '1': 2, '2': 3 });\n\n// 非数字\n.NaN\n(undefined + 0).should.be.NaN;\n\n// 判断类型\n.typeof\nuser.should.be.type('object');\n'test'.should.be.type('string');\n\n// 构造函数的一个实例\n.instanceof\nuser.should.be.an.instanceof(User);\n[].should.be.an.instanceOf(Array);\n\n// 存在\n.exist()\nshould.not.exist(err)\n\n//深度包含\n.containDeep()\n[[1],[2],[3]].should.containDeep([[3]]);\n[[1],[2],[3, 4]].should.containDeep([[3]]);\n[{a: 'a'}, {b: 'b', c: 'c'}].should.containDeep([{a: 'a'}]);\n[{a: 'a'}, {b: 'b', c: 'c'}].should.containDeep([{b: 'b'}]);\n\n// 抛出异常\n.throw()和throwError()\n(function(){\n  throw new Error('fail');\n}).should.throw();\n(function(){\n  throw new Error('fail');\n}).should.throw('fail');\n\n// http响应的头部包含\n.header\nres.should.have.header('content-length');\nres.should.have.header('Content-Length', '123');\n\n// 包含或等价于\n.containEql\n({ b: 10 }).should.containEql({ b: 10 });\n([1, 2, { a: 10 }]).should.containEql({ a: 10 });\n```\n\n## 三、SuperTest\n单单使用Mocha和should就几乎可以满足所有JavaScript函数的单元测试。但是对于Node应用而言，不仅仅是函数的集合，比如一个web应用的测试。这时候就需要配合一个http代理，完成Http请求和路由的测试。\nSupertest是一个HTTP代理服务引擎，可以模拟一切HTTP请求行为。Supertest可以搭配任意的应用框架，从而进行应用的单元测试。\n\n### 1、用法\n#### API\n首先，传入应用来实例化supertest,比如说实例化一个express：\n```\nvar supertest = require('supertest'), \n    express = require('express');\nvar app = express();\nvar request = supertest(app);\n```\n接下来就可以在Mocha测试用例中直接使用request发出一个基于该web应用的http请求了。\n\n1、.set()\n如果需要设置数据，supertest的API提供了 .set 来设置，比如：\n```\ndescribe('GET /users', function(){\n  it('respond with json', function(done){\n    request(app)\n      .get('/user')\n      .set('Accept', 'application/json')\n      .expect(200)\n      .end(function(err, res){\n        should.not.exist(err);\n        res.text.should.containEql('success');\n        done();\n      });\n  });\n});\n```\n\n2、.expect()\n.expect 是一个断言，上述测试代码在执行之后期望的状态码是200(OK)。如果接收到的数据为html页面，.expect('Content-Type', 'text/html;charset=utf-8')\n\n3、.end()\n.end 是执行一个request请求，在回调函数里面根据业务逻辑的返回数据做断言分析。\n\n4、.send()\n很多情况下，项目需要测试一个表单业务。supertest提供了.send()方法来发送表单域数据。比如一个登录模块，需要发送用户名密码：\n```\ndescribe('test login', function(){\n    it('login sucessfully', function (done) {\n        request.post('/user')\n        .send({\n            username: 'username',\n            password: '123456'\n        })\n        .end(function (err, res) {\n            should.not.exists(err);\n            done();\n        });\n    });\n})\n```\n\n5、.attach()\n.attach方法主要用来测试文件上传，由于.send()只能上传文本域，所以关于multipart -file的上传需要通过附件来绑定。\n```\nrequest(app)\n.post('/')\n.field('name', 'my awesome avatar')\n.attach('avatar', 'test/fixtures/homeboy.jpg')\n...\n```\n\n#### 持久化Cookie\n在很多业务测试中，需要用户先登录才有权限执行操作。这个时候作为HTTP请求模拟，必须要可以保存一些Cookie数据，也就是Cookie的持久化。这一般有两种解决思路。\n1、在 supertest 中，可以通过 var request = supertest.agent(app) 获取一个 agent 对象，这个对象的 API 跟直接在 superagent 上调用各种方法是一样的。这个request在被多次调用 get 和 post 之后，可以一路把 cookie 都保存下来。\n```\nvar supertest = require('supertest');\n  var app = express();\n  var request = supertest.agent(app);\n\n  request.post('login').end(...);\n  // then ..\n  request.post('create_topic').end(...); // 此时的request中有用户登陆后的 cookie\n```\n2、通过.set()，在发起请求时，调用 .set('Cookie', 'a cookie string') 这样的方式。\n```\nvar request = require('supertest');\nvar userCookie;\nrequest.post('login')\n.end(function (err, res) {\n    userCookie = res.headers['Cookie']\n});\n// then ..\n\nrequest.post('create_topic')\n    .set('Cookie', userCookie)\n    .end(...)\n```\n\n### 2、实战demo\n为了更好地帮助理解SuperTest的强大功能，这里放上我的一个项目模块的测试demo。\n#### 项目源文件\n首先，这是一个express应用的登录注册和用户信息修改模块，要测试的就是这个user模块。为了节省篇幅，这里只放上UserController和Router两个项目文件。\n```\nUserController.js\n// 用户首页\nexports.getUser = function (req, res) {\n    if (!req.user) {\n        res.send({status: false, info: '未登录'});\n    } else {\n        res.render('user', {status: true, userdata: req.user});\n    }\n};\n\nexports.login =  function (req, res, next) {\n    req.session.save(function (err) {\n        if (err) {\n            log.error(err);\n            return next(err);\n        }\n        res.redirect('/user/' + req.user.username);\n    });\n};\n\nexports.logout = function (req, res, next) {\n    req.logout();\n    req.session.save(function (err) {\n        if (err) {\n            log.error(err);\n            return next (err);\n        }\n        res.redirect('/user');\n        res.end();\n    });\n};\n\n// 用户注册\nexports.addUser = function (req, res, next) {\n    if (!req.body.username || !req.body.password) {\n        return res.send({status: false, info: '用户名或密码不能为空'});\n    } else if (req.body.password.length < 6) {\n        return res.send({status: false, info: '密码长度太短'});\n    } \n\n    User.register(new User({username: req.body.username}), req.body.password, function (err, user) {\n        if (err) {\n            log.error(err);\n            return res.render('register', {info: '用户名已被使用'});\n        } \n        passport.authenticate('local')(req, res, function () {\n            req.session.save(function (err) {\n                if (err) {\n                    log.error(err);\n                    return next(err);\n                }\n                res.redirect('/user/' + req.body.username);\n            });\n        });\n\n    });\n};\n\n// 更新用户信息文字资料\nexports.updateInfo = function (req, res, next) {\n    User.findOne({username: req.user.username}, function (err, doc) {\n        if (doc) {\n            doc.update(req.body, function (err, data) {\n                if (err) {\n                    log.error(err);\n                    return next(err);\n                }\n                res.send({status: true});\n            });\n        } else {\n            next();\n        }\n    });\n};\n\n// 更换头像\nexports.updateAvator = function (req, res,next) {\n    upload(req, res, function (err) {\n        if (err) {\n            log.error(err);\n            return next(err);\n        }\n        User.findOne({username: req.user.username}, function (err, doc) {\n            if (err) {\n                log.error(err);\n                return next(err);\n            } else if (doc) {\n                doc.update({avator: req.file.filename}, function (err, data) {\n                    if (err) {\n                        log.error(err);\n                        return next(err);\n                    }\n                    res.type('html');\n                    res.send({status: true, avator: req.file.filename});\n                });\n            } else {\n                return next();\n            }\n        });\n    });\n};\n```\nRouter文件\n```\nrouter.get('/:uid', isAuthenticated, user.getUser);\nrouter.get('/', function (req, res) {\n    res.render('login', {info: ''});\n});\nrouter.post('/',passport.authenticate('local'), /*{failureRedirect: '/user'}),*/ user.login);\n\nrouter.post('/authenticate/logout', user.logout);\n\nrouter.get('/authenticate/register', function (req, res) {\n    res.render('register', {info: ''});\n});\n\nrouter.post('/authenticate/register', user.addUser);\n\n// 用户相关的资料\nrouter.post('/update/info', user.updateInfo);\nrouter.post('/update/avator', user.updateAvator);\n\nmodule.exports = router;\n```\n\n#### 测试脚本\n首先，测试注册功能。为了防止用户名冲突，在测试用例之前设置钩子before块，清除User集合。\n```\n // user.test.js\n describe('test user.addUser()', function () {\n        before(function (done) {\n            User.remove({}, function (err) {\n                done();\n            });\n        });\n\n        it('register sucessfully', function (done) {\n            request.post('/user/authenticate/register')\n            .send({\n                username: 'username',\n                password: '123456'\n            })\n            //注册成功之后重定向\n            .expect(302, function (err, res) {\n                should.not.exists(err);\n                done();\n            });\n        });\n        //测试用户名存在的用例\n        it('username already exist', function (done) {\n            request.post('/user/authenticate/register')\n            .send({\n                username: 'username',\n                password: '123456'\n            })\n            .end(function (err, res) {\n                should.not.exists(err);\n                res.text.should.containEql('用户名已被使用');\n                done();\n            });\n        });\n    });\n    // 测试头像上传\n    describe('test user.updateAvator()', function () {\n        //bofore HOOKS，测试业务逻辑之前先登录，并持久化cookie\n        before(function (done) {\n            request.post('/user')\n            .send({\n                username: 'username',\n                password: '123456'\n            })\n            .end(function (err, res) {\n                done();\n            });\n        });\n\n        it('update avator upload sucessfully', function (done) {\n            request.post('/user/update/avator')\n            .attach('avator','test/image/test.jpg')\n            .end(function (err, res) {\n                should.not.exists(err);\n                res.text.should.containEql('\"status\":true');\n                done();\n            });\n        }); \n    });\n```\n\n","source":"_posts/2015-12-09-单元测试工具Mocha和SuperTest组合.md","raw":"title: 单元测试工具Mocha和SuperTest组合\ndate: 2015-12-08 20:07:57\ntags:\n    - mocha\n    - node\ncategories:\n    - Nodejs\n---\n\n毕业季，一堆乱七八糟的事情搞得已经整整两个月没有时间写写笔记了。最近进行着一个Node小项目，其中关于单元测试部分花了不少时间去踩坑。所以在这里简单总结一下关于Node开发测试框架Mocha(摩卡)的一些基础用法。由于本人是入门级别的Node开发者，所以这篇文章也是仅适用于和我一样的初级Node开发者，如有不正确的地方欢迎大神们指正！\n\n## 一、Mocha\nMocha是非常流行JavaScript测试框架之一，在浏览器和Node环境都可以使用。这里主要是针对Node环境。\n<!--more-->\n### 1、安装\n关于Mocha的安装当然是万能的npm了，直接npm install就OK，这里不再罗嗦了。\n### 2、使用\n然后就是Mocha的语法了。首先来看一下最简单例子：\n```\n// 这是一个简单的加法函数\n//add.js\nfunction add(a, b){\n    return a+b;\n}\nmodule.exports = add;\n```\n现在用Mocha写一个测试脚本去测试这个函数。一般来说，测试脚本的命名要和测试的模块一致，后缀为.test.js。这里测试脚本的名称为add.test.js，表示对add模块进行测试。\n```\n//add.test.js\nvar add = require('./add');\nvar should = require('should');\n\ndescribe('test add', function() {\n    it('1 + 1 should be equal to 2', function(done){\n        (add(1,1) === 2).should.be.true;\n    });\n});\n```\n然后保存代码之后进入终端，执行mocha add.test 即可。其中describe()函数是测试描述，表示一组相关测试用例是对哪个模块的测试。it()是一个测试用例，在一个describe块的内部可以执行对个测试用例(it块)。\n\n这是同步函数的测试。在Node环境中，绝大部分的业务逻辑都是异步的，所以测试结果的回调是JavaScript测试框架需要解决的首要问题。Mocha提供了一个回调函数done，在业务代码执行完毕之后调用done()结束测试用例，不然的话测试用例就会出现timeout的情况导致测试用例失败。Mocha默认的超时时间是2000毫秒，如果由于测试用例的执行时间比较长需要延长超时时间，可以在命令行添加 -t 参数，比如mocha -t 3000 add.test.js。当然还有其他命令行参数，比如 mocha -w 用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。查看更多的命令行参数可以通过 mocha -h 查找。\n\n那么接下来看一个异步测试例子：\n```\ndescribe('test async function', function(){\n    it('supertest example', function(done){\n        request.post('/')\n        .expect(200)\n        .end(function(err, res) {\n            should.not.exist(err);\n            done();\n        })\n    })\n})\n```\n在request请求执行完毕end()之后，一定要调用done()，否则测试用例超时，那么这个用例就失败了。当然这里用到了断言库should，稍后再介绍它的语法。\n\n### 3、钩子(hooks)\nMocha的Hooks主要是用来设置前置条件和后置处理。比如说一个业务请求之前必须先登录，那个登录操作就在before()里面完成。Mocha提供了before,after,beforeEach,afterEach四个钩子。\n```\ndescribe('hooks', function() {\n  before(function() {\n    // runs before all tests in this block\n  });\n\n  after(function() {\n    // runs after all tests in this block\n  });\n\n  beforeEach(function() {\n    // runs before each test in this block\n  });\n\n  afterEach(function() {\n    // runs after each test in this block\n  });\n\n  it('test',function(done){\n    //test here\n  })\n});\n```\n如果说某个测试需要跳过，使用it.skip()，Mocha跳过这个用例而不影响其他it块；只测试某个测试用例，使用it.only()，Mocha只执行.only用例，无视其他it块。\n\n## 二、断言库should\nMocha本身是不包含断言库的，所以我们需要自己选择断言库。should是一个很简单的、贴近自然语言的断言库。当然，Mocha是适配所有的断言库的，如果你喜欢其他的断言库比如expect之类的，你也可以把它包含进来使用。\n\nshould的语法非常贴近自然语言，简单易懂，常见的should断言如下：\n```\n// 全等，相当于===\n.exactly\n(5).should.be.exactly(5)\n \n// 对象存在\n.ok\ntrue.should.be.ok;\n'yay'.should.be.ok;\n(1).should.be.ok;\n({}).should.be.ok;\nfalse.should.not.be.ok;\n\n// 真\n.true\n(5===5).should.be.true\n(err === null).should.be.true;\n\n// 相等,相当于 ==\n.eql\n({ foo: 'bar' }).should.eql({ foo: 'bar' });\n[1,2,3].should.eql([1,2,3]);\n// see next example it is correct, even if it is different types, but actual content the same\n[1, 2, 3].should.eql({ '0': 1, '1': 2, '2': 3 });\n\n// 非数字\n.NaN\n(undefined + 0).should.be.NaN;\n\n// 判断类型\n.typeof\nuser.should.be.type('object');\n'test'.should.be.type('string');\n\n// 构造函数的一个实例\n.instanceof\nuser.should.be.an.instanceof(User);\n[].should.be.an.instanceOf(Array);\n\n// 存在\n.exist()\nshould.not.exist(err)\n\n//深度包含\n.containDeep()\n[[1],[2],[3]].should.containDeep([[3]]);\n[[1],[2],[3, 4]].should.containDeep([[3]]);\n[{a: 'a'}, {b: 'b', c: 'c'}].should.containDeep([{a: 'a'}]);\n[{a: 'a'}, {b: 'b', c: 'c'}].should.containDeep([{b: 'b'}]);\n\n// 抛出异常\n.throw()和throwError()\n(function(){\n  throw new Error('fail');\n}).should.throw();\n(function(){\n  throw new Error('fail');\n}).should.throw('fail');\n\n// http响应的头部包含\n.header\nres.should.have.header('content-length');\nres.should.have.header('Content-Length', '123');\n\n// 包含或等价于\n.containEql\n({ b: 10 }).should.containEql({ b: 10 });\n([1, 2, { a: 10 }]).should.containEql({ a: 10 });\n```\n\n## 三、SuperTest\n单单使用Mocha和should就几乎可以满足所有JavaScript函数的单元测试。但是对于Node应用而言，不仅仅是函数的集合，比如一个web应用的测试。这时候就需要配合一个http代理，完成Http请求和路由的测试。\nSupertest是一个HTTP代理服务引擎，可以模拟一切HTTP请求行为。Supertest可以搭配任意的应用框架，从而进行应用的单元测试。\n\n### 1、用法\n#### API\n首先，传入应用来实例化supertest,比如说实例化一个express：\n```\nvar supertest = require('supertest'), \n    express = require('express');\nvar app = express();\nvar request = supertest(app);\n```\n接下来就可以在Mocha测试用例中直接使用request发出一个基于该web应用的http请求了。\n\n1、.set()\n如果需要设置数据，supertest的API提供了 .set 来设置，比如：\n```\ndescribe('GET /users', function(){\n  it('respond with json', function(done){\n    request(app)\n      .get('/user')\n      .set('Accept', 'application/json')\n      .expect(200)\n      .end(function(err, res){\n        should.not.exist(err);\n        res.text.should.containEql('success');\n        done();\n      });\n  });\n});\n```\n\n2、.expect()\n.expect 是一个断言，上述测试代码在执行之后期望的状态码是200(OK)。如果接收到的数据为html页面，.expect('Content-Type', 'text/html;charset=utf-8')\n\n3、.end()\n.end 是执行一个request请求，在回调函数里面根据业务逻辑的返回数据做断言分析。\n\n4、.send()\n很多情况下，项目需要测试一个表单业务。supertest提供了.send()方法来发送表单域数据。比如一个登录模块，需要发送用户名密码：\n```\ndescribe('test login', function(){\n    it('login sucessfully', function (done) {\n        request.post('/user')\n        .send({\n            username: 'username',\n            password: '123456'\n        })\n        .end(function (err, res) {\n            should.not.exists(err);\n            done();\n        });\n    });\n})\n```\n\n5、.attach()\n.attach方法主要用来测试文件上传，由于.send()只能上传文本域，所以关于multipart -file的上传需要通过附件来绑定。\n```\nrequest(app)\n.post('/')\n.field('name', 'my awesome avatar')\n.attach('avatar', 'test/fixtures/homeboy.jpg')\n...\n```\n\n#### 持久化Cookie\n在很多业务测试中，需要用户先登录才有权限执行操作。这个时候作为HTTP请求模拟，必须要可以保存一些Cookie数据，也就是Cookie的持久化。这一般有两种解决思路。\n1、在 supertest 中，可以通过 var request = supertest.agent(app) 获取一个 agent 对象，这个对象的 API 跟直接在 superagent 上调用各种方法是一样的。这个request在被多次调用 get 和 post 之后，可以一路把 cookie 都保存下来。\n```\nvar supertest = require('supertest');\n  var app = express();\n  var request = supertest.agent(app);\n\n  request.post('login').end(...);\n  // then ..\n  request.post('create_topic').end(...); // 此时的request中有用户登陆后的 cookie\n```\n2、通过.set()，在发起请求时，调用 .set('Cookie', 'a cookie string') 这样的方式。\n```\nvar request = require('supertest');\nvar userCookie;\nrequest.post('login')\n.end(function (err, res) {\n    userCookie = res.headers['Cookie']\n});\n// then ..\n\nrequest.post('create_topic')\n    .set('Cookie', userCookie)\n    .end(...)\n```\n\n### 2、实战demo\n为了更好地帮助理解SuperTest的强大功能，这里放上我的一个项目模块的测试demo。\n#### 项目源文件\n首先，这是一个express应用的登录注册和用户信息修改模块，要测试的就是这个user模块。为了节省篇幅，这里只放上UserController和Router两个项目文件。\n```\nUserController.js\n// 用户首页\nexports.getUser = function (req, res) {\n    if (!req.user) {\n        res.send({status: false, info: '未登录'});\n    } else {\n        res.render('user', {status: true, userdata: req.user});\n    }\n};\n\nexports.login =  function (req, res, next) {\n    req.session.save(function (err) {\n        if (err) {\n            log.error(err);\n            return next(err);\n        }\n        res.redirect('/user/' + req.user.username);\n    });\n};\n\nexports.logout = function (req, res, next) {\n    req.logout();\n    req.session.save(function (err) {\n        if (err) {\n            log.error(err);\n            return next (err);\n        }\n        res.redirect('/user');\n        res.end();\n    });\n};\n\n// 用户注册\nexports.addUser = function (req, res, next) {\n    if (!req.body.username || !req.body.password) {\n        return res.send({status: false, info: '用户名或密码不能为空'});\n    } else if (req.body.password.length < 6) {\n        return res.send({status: false, info: '密码长度太短'});\n    } \n\n    User.register(new User({username: req.body.username}), req.body.password, function (err, user) {\n        if (err) {\n            log.error(err);\n            return res.render('register', {info: '用户名已被使用'});\n        } \n        passport.authenticate('local')(req, res, function () {\n            req.session.save(function (err) {\n                if (err) {\n                    log.error(err);\n                    return next(err);\n                }\n                res.redirect('/user/' + req.body.username);\n            });\n        });\n\n    });\n};\n\n// 更新用户信息文字资料\nexports.updateInfo = function (req, res, next) {\n    User.findOne({username: req.user.username}, function (err, doc) {\n        if (doc) {\n            doc.update(req.body, function (err, data) {\n                if (err) {\n                    log.error(err);\n                    return next(err);\n                }\n                res.send({status: true});\n            });\n        } else {\n            next();\n        }\n    });\n};\n\n// 更换头像\nexports.updateAvator = function (req, res,next) {\n    upload(req, res, function (err) {\n        if (err) {\n            log.error(err);\n            return next(err);\n        }\n        User.findOne({username: req.user.username}, function (err, doc) {\n            if (err) {\n                log.error(err);\n                return next(err);\n            } else if (doc) {\n                doc.update({avator: req.file.filename}, function (err, data) {\n                    if (err) {\n                        log.error(err);\n                        return next(err);\n                    }\n                    res.type('html');\n                    res.send({status: true, avator: req.file.filename});\n                });\n            } else {\n                return next();\n            }\n        });\n    });\n};\n```\nRouter文件\n```\nrouter.get('/:uid', isAuthenticated, user.getUser);\nrouter.get('/', function (req, res) {\n    res.render('login', {info: ''});\n});\nrouter.post('/',passport.authenticate('local'), /*{failureRedirect: '/user'}),*/ user.login);\n\nrouter.post('/authenticate/logout', user.logout);\n\nrouter.get('/authenticate/register', function (req, res) {\n    res.render('register', {info: ''});\n});\n\nrouter.post('/authenticate/register', user.addUser);\n\n// 用户相关的资料\nrouter.post('/update/info', user.updateInfo);\nrouter.post('/update/avator', user.updateAvator);\n\nmodule.exports = router;\n```\n\n#### 测试脚本\n首先，测试注册功能。为了防止用户名冲突，在测试用例之前设置钩子before块，清除User集合。\n```\n // user.test.js\n describe('test user.addUser()', function () {\n        before(function (done) {\n            User.remove({}, function (err) {\n                done();\n            });\n        });\n\n        it('register sucessfully', function (done) {\n            request.post('/user/authenticate/register')\n            .send({\n                username: 'username',\n                password: '123456'\n            })\n            //注册成功之后重定向\n            .expect(302, function (err, res) {\n                should.not.exists(err);\n                done();\n            });\n        });\n        //测试用户名存在的用例\n        it('username already exist', function (done) {\n            request.post('/user/authenticate/register')\n            .send({\n                username: 'username',\n                password: '123456'\n            })\n            .end(function (err, res) {\n                should.not.exists(err);\n                res.text.should.containEql('用户名已被使用');\n                done();\n            });\n        });\n    });\n    // 测试头像上传\n    describe('test user.updateAvator()', function () {\n        //bofore HOOKS，测试业务逻辑之前先登录，并持久化cookie\n        before(function (done) {\n            request.post('/user')\n            .send({\n                username: 'username',\n                password: '123456'\n            })\n            .end(function (err, res) {\n                done();\n            });\n        });\n\n        it('update avator upload sucessfully', function (done) {\n            request.post('/user/update/avator')\n            .attach('avator','test/image/test.jpg')\n            .end(function (err, res) {\n                should.not.exists(err);\n                res.text.should.containEql('\"status\":true');\n                done();\n            });\n        }); \n    });\n```\n\n","slug":"2015-12-09-单元测试工具Mocha和SuperTest组合","published":1,"updated":"2016-08-13T03:08:44.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtqi00077kaueru2sthq","content":"<p>毕业季，一堆乱七八糟的事情搞得已经整整两个月没有时间写写笔记了。最近进行着一个Node小项目，其中关于单元测试部分花了不少时间去踩坑。所以在这里简单总结一下关于Node开发测试框架Mocha(摩卡)的一些基础用法。由于本人是入门级别的Node开发者，所以这篇文章也是仅适用于和我一样的初级Node开发者，如有不正确的地方欢迎大神们指正！</p>\n<h2 id=\"一、Mocha\"><a href=\"#一、Mocha\" class=\"headerlink\" title=\"一、Mocha\"></a>一、Mocha</h2><p>Mocha是非常流行JavaScript测试框架之一，在浏览器和Node环境都可以使用。这里主要是针对Node环境。<br><a id=\"more\"></a></p>\n<h3 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h3><p>关于Mocha的安装当然是万能的npm了，直接npm install就OK，这里不再罗嗦了。</p>\n<h3 id=\"2、使用\"><a href=\"#2、使用\" class=\"headerlink\" title=\"2、使用\"></a>2、使用</h3><p>然后就是Mocha的语法了。首先来看一下最简单例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这是一个简单的加法函数</span></div><div class=\"line\"><span class=\"comment\">//add.js</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a+b;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = add;</div></pre></td></tr></table></figure></p>\n<p>现在用Mocha写一个测试脚本去测试这个函数。一般来说，测试脚本的命名要和测试的模块一致，后缀为.test.js。这里测试脚本的名称为add.test.js，表示对add模块进行测试。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//add.test.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"keyword\">require</span>(<span class=\"string\">'./add'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> should = <span class=\"keyword\">require</span>(<span class=\"string\">'should'</span>);</div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'test add'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    it(<span class=\"string\">'1 + 1 should be equal to 2'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(done)</span></span>&#123;</div><div class=\"line\">        (add(<span class=\"number\">1</span>,<span class=\"number\">1</span>) === <span class=\"number\">2</span>).should.be.<span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>然后保存代码之后进入终端，执行mocha add.test 即可。其中describe()函数是测试描述，表示一组相关测试用例是对哪个模块的测试。it()是一个测试用例，在一个describe块的内部可以执行对个测试用例(it块)。</p>\n<p>这是同步函数的测试。在Node环境中，绝大部分的业务逻辑都是异步的，所以测试结果的回调是JavaScript测试框架需要解决的首要问题。Mocha提供了一个回调函数done，在业务代码执行完毕之后调用done()结束测试用例，不然的话测试用例就会出现timeout的情况导致测试用例失败。Mocha默认的超时时间是2000毫秒，如果由于测试用例的执行时间比较长需要延长超时时间，可以在命令行添加 -t 参数，比如mocha -t 3000 add.test.js。当然还有其他命令行参数，比如 mocha -w 用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。查看更多的命令行参数可以通过 mocha -h 查找。</p>\n<p>那么接下来看一个异步测试例子：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe('test async function', function()&#123;</div><div class=\"line\">    it('supertest example', function(<span class=\"name\">done</span>)&#123;</div><div class=\"line\">        request.post('/')</div><div class=\"line\">        .expect(<span class=\"number\">200</span>)</div><div class=\"line\">        .end(<span class=\"name\">function</span>(<span class=\"name\">err</span>, res) &#123;</div><div class=\"line\">            should.not.exist(<span class=\"name\">err</span>)<span class=\"comment\">;</span></div><div class=\"line\">            done()<span class=\"comment\">;</span></div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>在request请求执行完毕end()之后，一定要调用done()，否则测试用例超时，那么这个用例就失败了。当然这里用到了断言库should，稍后再介绍它的语法。</p>\n<h3 id=\"3、钩子-hooks\"><a href=\"#3、钩子-hooks\" class=\"headerlink\" title=\"3、钩子(hooks)\"></a>3、钩子(hooks)</h3><p>Mocha的Hooks主要是用来设置前置条件和后置处理。比如说一个业务请求之前必须先登录，那个登录操作就在before()里面完成。Mocha提供了before,after,beforeEach,afterEach四个钩子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe(<span class=\"string\">'hooks'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  before(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs before all tests in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  after(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs after all tests in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  beforeEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs before each test in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  afterEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs after each test in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  it(<span class=\"string\">'test'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//test here</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>如果说某个测试需要跳过，使用it.skip()，Mocha跳过这个用例而不影响其他it块；只测试某个测试用例，使用it.only()，Mocha只执行.only用例，无视其他it块。</p>\n<h2 id=\"二、断言库should\"><a href=\"#二、断言库should\" class=\"headerlink\" title=\"二、断言库should\"></a>二、断言库should</h2><p>Mocha本身是不包含断言库的，所以我们需要自己选择断言库。should是一个很简单的、贴近自然语言的断言库。当然，Mocha是适配所有的断言库的，如果你喜欢其他的断言库比如expect之类的，你也可以把它包含进来使用。</p>\n<p>should的语法非常贴近自然语言，简单易懂，常见的should断言如下：<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 全等，相当于===</span></div><div class=\"line\">.exactly</div><div class=\"line\">(<span class=\"number\">5</span>).should.be.exactly(<span class=\"number\">5</span>)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 对象存在</span></div><div class=\"line\">.ok</div><div class=\"line\"><span class=\"literal\">true</span>.should.be.ok;</div><div class=\"line\"><span class=\"string\">'yay'</span>.should.be.ok;</div><div class=\"line\">(<span class=\"number\">1</span>).should.be.ok;</div><div class=\"line\">(&#123;&#125;).should.be.ok;</div><div class=\"line\"><span class=\"literal\">false</span>.should.not.be.ok;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 真</span></div><div class=\"line\">.<span class=\"literal\">true</span></div><div class=\"line\">(<span class=\"number\">5</span>===<span class=\"number\">5</span>).should.be.<span class=\"literal\">true</span></div><div class=\"line\">(err === <span class=\"literal\">null</span>).should.be.<span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 相等,相当于 ==</span></div><div class=\"line\">.eql</div><div class=\"line\">(&#123; <span class=\"string\">foo:</span> <span class=\"string\">'bar'</span> &#125;).should.eql(&#123; <span class=\"string\">foo:</span> <span class=\"string\">'bar'</span> &#125;);</div><div class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].should.eql([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]);</div><div class=\"line\"><span class=\"comment\">// see next example it is correct, even if it is different types, but actual content the same</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].should.eql(&#123; <span class=\"string\">'0'</span>: <span class=\"number\">1</span>, <span class=\"string\">'1'</span>: <span class=\"number\">2</span>, <span class=\"string\">'2'</span>: <span class=\"number\">3</span> &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 非数字</span></div><div class=\"line\">.NaN</div><div class=\"line\">(undefined + <span class=\"number\">0</span>).should.be.NaN;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 判断类型</span></div><div class=\"line\">.typeof</div><div class=\"line\">user.should.be.type(<span class=\"string\">'object'</span>);</div><div class=\"line\"><span class=\"string\">'test'</span>.should.be.type(<span class=\"string\">'string'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 构造函数的一个实例</span></div><div class=\"line\">.<span class=\"keyword\">instanceof</span></div><div class=\"line\">user.should.be.an.<span class=\"keyword\">instanceof</span>(User);</div><div class=\"line\">[].should.be.an.instanceOf(Array);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 存在</span></div><div class=\"line\">.exist()</div><div class=\"line\">should.not.exist(err)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//深度包含</span></div><div class=\"line\">.containDeep()</div><div class=\"line\">[[<span class=\"number\">1</span>],[<span class=\"number\">2</span>],[<span class=\"number\">3</span>]].should.containDeep([[<span class=\"number\">3</span>]]);</div><div class=\"line\">[[<span class=\"number\">1</span>],[<span class=\"number\">2</span>],[<span class=\"number\">3</span>, <span class=\"number\">4</span>]].should.containDeep([[<span class=\"number\">3</span>]]);</div><div class=\"line\">[&#123;<span class=\"string\">a:</span> <span class=\"string\">'a'</span>&#125;, &#123;<span class=\"string\">b:</span> <span class=\"string\">'b'</span>, <span class=\"string\">c:</span> <span class=\"string\">'c'</span>&#125;].should.containDeep([&#123;<span class=\"string\">a:</span> <span class=\"string\">'a'</span>&#125;]);</div><div class=\"line\">[&#123;<span class=\"string\">a:</span> <span class=\"string\">'a'</span>&#125;, &#123;<span class=\"string\">b:</span> <span class=\"string\">'b'</span>, <span class=\"string\">c:</span> <span class=\"string\">'c'</span>&#125;].should.containDeep([&#123;<span class=\"string\">b:</span> <span class=\"string\">'b'</span>&#125;]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 抛出异常</span></div><div class=\"line\">.<span class=\"keyword\">throw</span>()和throwError()</div><div class=\"line\">(function()&#123;</div><div class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">'fail'</span>);</div><div class=\"line\">&#125;).should.<span class=\"keyword\">throw</span>();</div><div class=\"line\">(function()&#123;</div><div class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">'fail'</span>);</div><div class=\"line\">&#125;).should.<span class=\"keyword\">throw</span>(<span class=\"string\">'fail'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// http响应的头部包含</span></div><div class=\"line\">.header</div><div class=\"line\">res.should.have.header(<span class=\"string\">'content-length'</span>);</div><div class=\"line\">res.should.have.header(<span class=\"string\">'Content-Length'</span>, <span class=\"string\">'123'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 包含或等价于</span></div><div class=\"line\">.containEql</div><div class=\"line\">(&#123; <span class=\"string\">b:</span> <span class=\"number\">10</span> &#125;).should.containEql(&#123; <span class=\"string\">b:</span> <span class=\"number\">10</span> &#125;);</div><div class=\"line\">([<span class=\"number\">1</span>, <span class=\"number\">2</span>, &#123; <span class=\"string\">a:</span> <span class=\"number\">10</span> &#125;]).should.containEql(&#123; <span class=\"string\">a:</span> <span class=\"number\">10</span> &#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"三、SuperTest\"><a href=\"#三、SuperTest\" class=\"headerlink\" title=\"三、SuperTest\"></a>三、SuperTest</h2><p>单单使用Mocha和should就几乎可以满足所有JavaScript函数的单元测试。但是对于Node应用而言，不仅仅是函数的集合，比如一个web应用的测试。这时候就需要配合一个http代理，完成Http请求和路由的测试。<br>Supertest是一个HTTP代理服务引擎，可以模拟一切HTTP请求行为。Supertest可以搭配任意的应用框架，从而进行应用的单元测试。</p>\n<h3 id=\"1、用法\"><a href=\"#1、用法\" class=\"headerlink\" title=\"1、用法\"></a>1、用法</h3><h4 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h4><p>首先，传入应用来实例化supertest,比如说实例化一个express：<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">var supertest</span> = require(<span class=\"string\">'supertest'</span>), </div><div class=\"line\">    express = require(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"attribute\">var app</span> = express();</div><div class=\"line\"><span class=\"attribute\">var request</span> = supertest(app);</div></pre></td></tr></table></figure></p>\n<p>接下来就可以在Mocha测试用例中直接使用request发出一个基于该web应用的http请求了。</p>\n<p>1、.set()<br>如果需要设置数据，supertest的API提供了 .set 来设置，比如：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe('GET /users', function()&#123;</div><div class=\"line\">  it('respond with json', function(<span class=\"name\">done</span>)&#123;</div><div class=\"line\">    request(<span class=\"name\">app</span>)</div><div class=\"line\">      .get('/user')</div><div class=\"line\">      .set('Accept', 'application/json')</div><div class=\"line\">      .expect(<span class=\"number\">200</span>)</div><div class=\"line\">      .end(<span class=\"name\">function</span>(<span class=\"name\">err</span>, res)&#123;</div><div class=\"line\">        should.not.exist(<span class=\"name\">err</span>)<span class=\"comment\">;</span></div><div class=\"line\">        res.text.should.containEql('success')<span class=\"comment\">;</span></div><div class=\"line\">        done()<span class=\"comment\">;</span></div><div class=\"line\">      &#125;)<span class=\"comment\">;</span></div><div class=\"line\">  &#125;)<span class=\"comment\">;</span></div><div class=\"line\">&#125;)<span class=\"comment\">;</span></div></pre></td></tr></table></figure></p>\n<p>2、.expect()<br>.expect 是一个断言，上述测试代码在执行之后期望的状态码是200(OK)。如果接收到的数据为html页面，.expect(‘Content-Type’, ‘text/html;charset=utf-8’)</p>\n<p>3、.end()<br>.end 是执行一个request请求，在回调函数里面根据业务逻辑的返回数据做断言分析。</p>\n<p>4、.send()<br>很多情况下，项目需要测试一个表单业务。supertest提供了.send()方法来发送表单域数据。比如一个登录模块，需要发送用户名密码：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe('test login', function()&#123;</div><div class=\"line\">    it('login sucessfully', function (<span class=\"name\">done</span>) &#123;</div><div class=\"line\">        request.post('/user')</div><div class=\"line\">        .send(&#123;</div><div class=\"line\">            username: 'username',</div><div class=\"line\">            password: '<span class=\"number\">123456</span>'</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .end(<span class=\"name\">function</span> (<span class=\"name\">err</span>, res) &#123;</div><div class=\"line\">            should.not.exists(<span class=\"name\">err</span>)<span class=\"comment\">;</span></div><div class=\"line\">            done()<span class=\"comment\">;</span></div><div class=\"line\">        &#125;)<span class=\"comment\">;</span></div><div class=\"line\">    &#125;)<span class=\"comment\">;</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>5、.attach()<br>.attach方法主要用来测试文件上传，由于.send()只能上传文本域，所以关于multipart -file的上传需要通过附件来绑定。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"title\">request</span><span class=\"params\">(app)</span></span></div><div class=\"line\">.post(<span class=\"string\">'/'</span>)</div><div class=\"line\">.field(<span class=\"string\">'name'</span>, <span class=\"string\">'my awesome avatar'</span>)</div><div class=\"line\">.attach(<span class=\"string\">'avatar'</span>, <span class=\"string\">'test/fixtures/homeboy.jpg'</span>)</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h4 id=\"持久化Cookie\"><a href=\"#持久化Cookie\" class=\"headerlink\" title=\"持久化Cookie\"></a>持久化Cookie</h4><p>在很多业务测试中，需要用户先登录才有权限执行操作。这个时候作为HTTP请求模拟，必须要可以保存一些Cookie数据，也就是Cookie的持久化。这一般有两种解决思路。<br>1、在 supertest 中，可以通过 var request = supertest.agent(app) 获取一个 agent 对象，这个对象的 API 跟直接在 superagent 上调用各种方法是一样的。这个request在被多次调用 get 和 post 之后，可以一路把 cookie 都保存下来。<br><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">var</span> supertest = <span class=\"keyword\">require</span>(<span class=\"string\">'supertest'</span>);</div><div class=\"line\">  <span class=\"built_in\">var</span> app = express();</div><div class=\"line\">  <span class=\"built_in\">var</span> request = supertest.agent(app);</div><div class=\"line\"></div><div class=\"line\">  request.post(<span class=\"string\">'login'</span>).end(<span class=\"params\">...</span>);</div><div class=\"line\">  <span class=\"comment\">// then ..</span></div><div class=\"line\">  request.post(<span class=\"string\">'create_topic'</span>).end(<span class=\"params\">...</span>); <span class=\"comment\">// 此时的request中有用户登陆后的 cookie</span></div></pre></td></tr></table></figure></p>\n<p>2、通过.set()，在发起请求时，调用 .set(‘Cookie’, ‘a cookie string’) 这样的方式。<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = require(<span class=\"string\">'supertest'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> userCookie;</div><div class=\"line\">request.post(<span class=\"string\">'login'</span>)</div><div class=\"line\">.<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> <span class=\"comment\">&#123;</span></span></div><div class=\"line\">    userCookie = res.headers['Cookie']</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">// then ..</span></div><div class=\"line\"></div><div class=\"line\">request.post(<span class=\"string\">'create_topic'</span>)</div><div class=\"line\">    .<span class=\"keyword\">set</span>(<span class=\"string\">'Cookie'</span>, userCookie)</div><div class=\"line\">    .<span class=\"keyword\">end</span>(...)</div></pre></td></tr></table></figure></p>\n<h3 id=\"2、实战demo\"><a href=\"#2、实战demo\" class=\"headerlink\" title=\"2、实战demo\"></a>2、实战demo</h3><p>为了更好地帮助理解SuperTest的强大功能，这里放上我的一个项目模块的测试demo。</p>\n<h4 id=\"项目源文件\"><a href=\"#项目源文件\" class=\"headerlink\" title=\"项目源文件\"></a>项目源文件</h4><p>首先，这是一个express应用的登录注册和用户信息修改模块，要测试的就是这个user模块。为了节省篇幅，这里只放上UserController和Router两个项目文件。<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div></pre></td><td class=\"code\"><pre><div class=\"line\">UserController.js</div><div class=\"line\">// 用户首页</div><div class=\"line\">exports.getUser = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!req.user) &#123;</div><div class=\"line\">        res.send(&#123;status: <span class=\"keyword\">false</span>, info: <span class=\"string\">'未登录'</span>&#125;);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        res.render(<span class=\"string\">'user'</span>, &#123;status: <span class=\"keyword\">true</span>, userdata: req.user&#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">exports.login =  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    req.session.save(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        res.redirect(<span class=\"string\">'/user/'</span> + req.user.username);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">exports.logout = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    req.logout();</div><div class=\"line\">    req.session.save(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span> (err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        res.redirect(<span class=\"string\">'/user'</span>);</div><div class=\"line\">        res.<span class=\"keyword\">end</span>();</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 用户注册</div><div class=\"line\">exports.addUser = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!req.body.username || !req.body.password) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> res.send(&#123;status: <span class=\"keyword\">false</span>, info: <span class=\"string\">'用户名或密码不能为空'</span>&#125;);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (req.body.password.length &lt; <span class=\"number\">6</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> res.send(&#123;status: <span class=\"keyword\">false</span>, info: <span class=\"string\">'密码长度太短'</span>&#125;);</div><div class=\"line\">    &#125; </div><div class=\"line\"></div><div class=\"line\">    User.register(new User(&#123;username: req.body.username&#125;), req.body.password, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, user)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> res.render(<span class=\"string\">'register'</span>, &#123;info: <span class=\"string\">'用户名已被使用'</span>&#125;);</div><div class=\"line\">        &#125; </div><div class=\"line\">        passport.authenticate(<span class=\"string\">'local'</span>)(req, res, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span> &#123;</div><div class=\"line\">            req.session.save(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                    log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">                &#125;</div><div class=\"line\">                res.redirect(<span class=\"string\">'/user/'</span> + req.body.username);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 更新用户信息文字资料</div><div class=\"line\">exports.updateInfo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    User.findOne(&#123;username: req.user.username&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, doc)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (doc) &#123;</div><div class=\"line\">            doc.update(req.body, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, data)</span></span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                    log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">                &#125;</div><div class=\"line\">                res.send(&#123;status: <span class=\"keyword\">true</span>&#125;);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">next</span>();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 更换头像</div><div class=\"line\">exports.updateAvator = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res,next)</span></span> &#123;</div><div class=\"line\">    upload(req, res, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        User.findOne(&#123;username: req.user.username&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, doc)</span></span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (doc) &#123;</div><div class=\"line\">                doc.update(&#123;avator: req.file.filename&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, data)</span></span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                        log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    res.<span class=\"built_in\">type</span>(<span class=\"string\">'html'</span>);</div><div class=\"line\">                    res.send(&#123;status: <span class=\"keyword\">true</span>, avator: req.file.filename&#125;);</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>Router文件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">router.get(<span class=\"string\">'/:uid'</span>, isAuthenticated, user.getUser);</div><div class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">    res.render(<span class=\"string\">'login'</span>, &#123;info: <span class=\"string\">''</span>&#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\">router.post(<span class=\"string\">'/'</span>,passport.authenticate(<span class=\"string\">'local'</span>), <span class=\"comment\">/*&#123;failureRedirect: '/user'&#125;),*/</span> user.login);</div><div class=\"line\"></div><div class=\"line\">router.post(<span class=\"string\">'/authenticate/logout'</span>, user.logout);</div><div class=\"line\"></div><div class=\"line\">router.get(<span class=\"string\">'/authenticate/register'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">    res.render(<span class=\"string\">'register'</span>, &#123;info: <span class=\"string\">''</span>&#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">router.post(<span class=\"string\">'/authenticate/register'</span>, user.addUser);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 用户相关的资料</span></div><div class=\"line\">router.post(<span class=\"string\">'/update/info'</span>, user.updateInfo);</div><div class=\"line\">router.post(<span class=\"string\">'/update/avator'</span>, user.updateAvator);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = router;</div></pre></td></tr></table></figure></p>\n<h4 id=\"测试脚本\"><a href=\"#测试脚本\" class=\"headerlink\" title=\"测试脚本\"></a>测试脚本</h4><p>首先，测试注册功能。为了防止用户名冲突，在测试用例之前设置钩子before块，清除User集合。<br><figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// user.test.js</span></div><div class=\"line\">describe(<span class=\"string\">'test user.addUser()'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> &#123;</span></div><div class=\"line\">       before(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           User.remove(&#123;&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span> &#123;</span></div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\"></div><div class=\"line\">       it(<span class=\"string\">'register sucessfully'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user/authenticate/register'</span>)</div><div class=\"line\">           .send(&#123;</div><div class=\"line\">               username: <span class=\"string\">'username'</span>,</div><div class=\"line\">               password: <span class=\"string\">'123456'</span></div><div class=\"line\">           &#125;)</div><div class=\"line\">           <span class=\"comment\">//注册成功之后重定向</span></div><div class=\"line\">           .expect(<span class=\"number\">302</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               should.not.<span class=\"built_in\">exists</span>(err);</div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\">       <span class=\"comment\">//测试用户名存在的用例</span></div><div class=\"line\">       it(<span class=\"string\">'username already exist'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user/authenticate/register'</span>)</div><div class=\"line\">           .send(&#123;</div><div class=\"line\">               username: <span class=\"string\">'username'</span>,</div><div class=\"line\">               password: <span class=\"string\">'123456'</span></div><div class=\"line\">           &#125;)</div><div class=\"line\">           .<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               should.not.<span class=\"built_in\">exists</span>(err);</div><div class=\"line\">               res.text.should.containEql(<span class=\"string\">'用户名已被使用'</span>);</div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\">   &#125;);</div><div class=\"line\">   <span class=\"comment\">// 测试头像上传</span></div><div class=\"line\">   describe(<span class=\"string\">'test user.updateAvator()'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> &#123;</span></div><div class=\"line\">       <span class=\"comment\">//bofore HOOKS，测试业务逻辑之前先登录，并持久化cookie</span></div><div class=\"line\">       before(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user'</span>)</div><div class=\"line\">           .send(&#123;</div><div class=\"line\">               username: <span class=\"string\">'username'</span>,</div><div class=\"line\">               password: <span class=\"string\">'123456'</span></div><div class=\"line\">           &#125;)</div><div class=\"line\">           .<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\"></div><div class=\"line\">       it(<span class=\"string\">'update avator upload sucessfully'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user/update/avator'</span>)</div><div class=\"line\">           .attach(<span class=\"string\">'avator'</span>,<span class=\"string\">'test/image/test.jpg'</span>)</div><div class=\"line\">           .<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               should.not.<span class=\"built_in\">exists</span>(err);</div><div class=\"line\">               res.text.should.containEql(<span class=\"string\">'\"</span>status<span class=\"string\">\":true'</span>);</div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;); </div><div class=\"line\">   &#125;);</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>毕业季，一堆乱七八糟的事情搞得已经整整两个月没有时间写写笔记了。最近进行着一个Node小项目，其中关于单元测试部分花了不少时间去踩坑。所以在这里简单总结一下关于Node开发测试框架Mocha(摩卡)的一些基础用法。由于本人是入门级别的Node开发者，所以这篇文章也是仅适用于和我一样的初级Node开发者，如有不正确的地方欢迎大神们指正！</p>\n<h2 id=\"一、Mocha\"><a href=\"#一、Mocha\" class=\"headerlink\" title=\"一、Mocha\"></a>一、Mocha</h2><p>Mocha是非常流行JavaScript测试框架之一，在浏览器和Node环境都可以使用。这里主要是针对Node环境。<br>","more":"</p>\n<h3 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h3><p>关于Mocha的安装当然是万能的npm了，直接npm install就OK，这里不再罗嗦了。</p>\n<h3 id=\"2、使用\"><a href=\"#2、使用\" class=\"headerlink\" title=\"2、使用\"></a>2、使用</h3><p>然后就是Mocha的语法了。首先来看一下最简单例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这是一个简单的加法函数</span></div><div class=\"line\"><span class=\"comment\">//add.js</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a+b;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = add;</div></pre></td></tr></table></figure></p>\n<p>现在用Mocha写一个测试脚本去测试这个函数。一般来说，测试脚本的命名要和测试的模块一致，后缀为.test.js。这里测试脚本的名称为add.test.js，表示对add模块进行测试。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//add.test.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"keyword\">require</span>(<span class=\"string\">'./add'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> should = <span class=\"keyword\">require</span>(<span class=\"string\">'should'</span>);</div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'test add'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    it(<span class=\"string\">'1 + 1 should be equal to 2'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(done)</span></span>&#123;</div><div class=\"line\">        (add(<span class=\"number\">1</span>,<span class=\"number\">1</span>) === <span class=\"number\">2</span>).should.be.<span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>然后保存代码之后进入终端，执行mocha add.test 即可。其中describe()函数是测试描述，表示一组相关测试用例是对哪个模块的测试。it()是一个测试用例，在一个describe块的内部可以执行对个测试用例(it块)。</p>\n<p>这是同步函数的测试。在Node环境中，绝大部分的业务逻辑都是异步的，所以测试结果的回调是JavaScript测试框架需要解决的首要问题。Mocha提供了一个回调函数done，在业务代码执行完毕之后调用done()结束测试用例，不然的话测试用例就会出现timeout的情况导致测试用例失败。Mocha默认的超时时间是2000毫秒，如果由于测试用例的执行时间比较长需要延长超时时间，可以在命令行添加 -t 参数，比如mocha -t 3000 add.test.js。当然还有其他命令行参数，比如 mocha -w 用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。查看更多的命令行参数可以通过 mocha -h 查找。</p>\n<p>那么接下来看一个异步测试例子：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe('test async function', function()&#123;</div><div class=\"line\">    it('supertest example', function(<span class=\"name\">done</span>)&#123;</div><div class=\"line\">        request.post('/')</div><div class=\"line\">        .expect(<span class=\"number\">200</span>)</div><div class=\"line\">        .end(<span class=\"name\">function</span>(<span class=\"name\">err</span>, res) &#123;</div><div class=\"line\">            should.not.exist(<span class=\"name\">err</span>)<span class=\"comment\">;</span></div><div class=\"line\">            done()<span class=\"comment\">;</span></div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>在request请求执行完毕end()之后，一定要调用done()，否则测试用例超时，那么这个用例就失败了。当然这里用到了断言库should，稍后再介绍它的语法。</p>\n<h3 id=\"3、钩子-hooks\"><a href=\"#3、钩子-hooks\" class=\"headerlink\" title=\"3、钩子(hooks)\"></a>3、钩子(hooks)</h3><p>Mocha的Hooks主要是用来设置前置条件和后置处理。比如说一个业务请求之前必须先登录，那个登录操作就在before()里面完成。Mocha提供了before,after,beforeEach,afterEach四个钩子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe(<span class=\"string\">'hooks'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  before(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs before all tests in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  after(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs after all tests in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  beforeEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs before each test in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  afterEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs after each test in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  it(<span class=\"string\">'test'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//test here</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>如果说某个测试需要跳过，使用it.skip()，Mocha跳过这个用例而不影响其他it块；只测试某个测试用例，使用it.only()，Mocha只执行.only用例，无视其他it块。</p>\n<h2 id=\"二、断言库should\"><a href=\"#二、断言库should\" class=\"headerlink\" title=\"二、断言库should\"></a>二、断言库should</h2><p>Mocha本身是不包含断言库的，所以我们需要自己选择断言库。should是一个很简单的、贴近自然语言的断言库。当然，Mocha是适配所有的断言库的，如果你喜欢其他的断言库比如expect之类的，你也可以把它包含进来使用。</p>\n<p>should的语法非常贴近自然语言，简单易懂，常见的should断言如下：<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 全等，相当于===</span></div><div class=\"line\">.exactly</div><div class=\"line\">(<span class=\"number\">5</span>).should.be.exactly(<span class=\"number\">5</span>)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 对象存在</span></div><div class=\"line\">.ok</div><div class=\"line\"><span class=\"literal\">true</span>.should.be.ok;</div><div class=\"line\"><span class=\"string\">'yay'</span>.should.be.ok;</div><div class=\"line\">(<span class=\"number\">1</span>).should.be.ok;</div><div class=\"line\">(&#123;&#125;).should.be.ok;</div><div class=\"line\"><span class=\"literal\">false</span>.should.not.be.ok;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 真</span></div><div class=\"line\">.<span class=\"literal\">true</span></div><div class=\"line\">(<span class=\"number\">5</span>===<span class=\"number\">5</span>).should.be.<span class=\"literal\">true</span></div><div class=\"line\">(err === <span class=\"literal\">null</span>).should.be.<span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 相等,相当于 ==</span></div><div class=\"line\">.eql</div><div class=\"line\">(&#123; <span class=\"string\">foo:</span> <span class=\"string\">'bar'</span> &#125;).should.eql(&#123; <span class=\"string\">foo:</span> <span class=\"string\">'bar'</span> &#125;);</div><div class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].should.eql([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]);</div><div class=\"line\"><span class=\"comment\">// see next example it is correct, even if it is different types, but actual content the same</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].should.eql(&#123; <span class=\"string\">'0'</span>: <span class=\"number\">1</span>, <span class=\"string\">'1'</span>: <span class=\"number\">2</span>, <span class=\"string\">'2'</span>: <span class=\"number\">3</span> &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 非数字</span></div><div class=\"line\">.NaN</div><div class=\"line\">(undefined + <span class=\"number\">0</span>).should.be.NaN;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 判断类型</span></div><div class=\"line\">.typeof</div><div class=\"line\">user.should.be.type(<span class=\"string\">'object'</span>);</div><div class=\"line\"><span class=\"string\">'test'</span>.should.be.type(<span class=\"string\">'string'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 构造函数的一个实例</span></div><div class=\"line\">.<span class=\"keyword\">instanceof</span></div><div class=\"line\">user.should.be.an.<span class=\"keyword\">instanceof</span>(User);</div><div class=\"line\">[].should.be.an.instanceOf(Array);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 存在</span></div><div class=\"line\">.exist()</div><div class=\"line\">should.not.exist(err)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//深度包含</span></div><div class=\"line\">.containDeep()</div><div class=\"line\">[[<span class=\"number\">1</span>],[<span class=\"number\">2</span>],[<span class=\"number\">3</span>]].should.containDeep([[<span class=\"number\">3</span>]]);</div><div class=\"line\">[[<span class=\"number\">1</span>],[<span class=\"number\">2</span>],[<span class=\"number\">3</span>, <span class=\"number\">4</span>]].should.containDeep([[<span class=\"number\">3</span>]]);</div><div class=\"line\">[&#123;<span class=\"string\">a:</span> <span class=\"string\">'a'</span>&#125;, &#123;<span class=\"string\">b:</span> <span class=\"string\">'b'</span>, <span class=\"string\">c:</span> <span class=\"string\">'c'</span>&#125;].should.containDeep([&#123;<span class=\"string\">a:</span> <span class=\"string\">'a'</span>&#125;]);</div><div class=\"line\">[&#123;<span class=\"string\">a:</span> <span class=\"string\">'a'</span>&#125;, &#123;<span class=\"string\">b:</span> <span class=\"string\">'b'</span>, <span class=\"string\">c:</span> <span class=\"string\">'c'</span>&#125;].should.containDeep([&#123;<span class=\"string\">b:</span> <span class=\"string\">'b'</span>&#125;]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 抛出异常</span></div><div class=\"line\">.<span class=\"keyword\">throw</span>()和throwError()</div><div class=\"line\">(function()&#123;</div><div class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">'fail'</span>);</div><div class=\"line\">&#125;).should.<span class=\"keyword\">throw</span>();</div><div class=\"line\">(function()&#123;</div><div class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">'fail'</span>);</div><div class=\"line\">&#125;).should.<span class=\"keyword\">throw</span>(<span class=\"string\">'fail'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// http响应的头部包含</span></div><div class=\"line\">.header</div><div class=\"line\">res.should.have.header(<span class=\"string\">'content-length'</span>);</div><div class=\"line\">res.should.have.header(<span class=\"string\">'Content-Length'</span>, <span class=\"string\">'123'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 包含或等价于</span></div><div class=\"line\">.containEql</div><div class=\"line\">(&#123; <span class=\"string\">b:</span> <span class=\"number\">10</span> &#125;).should.containEql(&#123; <span class=\"string\">b:</span> <span class=\"number\">10</span> &#125;);</div><div class=\"line\">([<span class=\"number\">1</span>, <span class=\"number\">2</span>, &#123; <span class=\"string\">a:</span> <span class=\"number\">10</span> &#125;]).should.containEql(&#123; <span class=\"string\">a:</span> <span class=\"number\">10</span> &#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"三、SuperTest\"><a href=\"#三、SuperTest\" class=\"headerlink\" title=\"三、SuperTest\"></a>三、SuperTest</h2><p>单单使用Mocha和should就几乎可以满足所有JavaScript函数的单元测试。但是对于Node应用而言，不仅仅是函数的集合，比如一个web应用的测试。这时候就需要配合一个http代理，完成Http请求和路由的测试。<br>Supertest是一个HTTP代理服务引擎，可以模拟一切HTTP请求行为。Supertest可以搭配任意的应用框架，从而进行应用的单元测试。</p>\n<h3 id=\"1、用法\"><a href=\"#1、用法\" class=\"headerlink\" title=\"1、用法\"></a>1、用法</h3><h4 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h4><p>首先，传入应用来实例化supertest,比如说实例化一个express：<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">var supertest</span> = require(<span class=\"string\">'supertest'</span>), </div><div class=\"line\">    express = require(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"attribute\">var app</span> = express();</div><div class=\"line\"><span class=\"attribute\">var request</span> = supertest(app);</div></pre></td></tr></table></figure></p>\n<p>接下来就可以在Mocha测试用例中直接使用request发出一个基于该web应用的http请求了。</p>\n<p>1、.set()<br>如果需要设置数据，supertest的API提供了 .set 来设置，比如：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe('GET /users', function()&#123;</div><div class=\"line\">  it('respond with json', function(<span class=\"name\">done</span>)&#123;</div><div class=\"line\">    request(<span class=\"name\">app</span>)</div><div class=\"line\">      .get('/user')</div><div class=\"line\">      .set('Accept', 'application/json')</div><div class=\"line\">      .expect(<span class=\"number\">200</span>)</div><div class=\"line\">      .end(<span class=\"name\">function</span>(<span class=\"name\">err</span>, res)&#123;</div><div class=\"line\">        should.not.exist(<span class=\"name\">err</span>)<span class=\"comment\">;</span></div><div class=\"line\">        res.text.should.containEql('success')<span class=\"comment\">;</span></div><div class=\"line\">        done()<span class=\"comment\">;</span></div><div class=\"line\">      &#125;)<span class=\"comment\">;</span></div><div class=\"line\">  &#125;)<span class=\"comment\">;</span></div><div class=\"line\">&#125;)<span class=\"comment\">;</span></div></pre></td></tr></table></figure></p>\n<p>2、.expect()<br>.expect 是一个断言，上述测试代码在执行之后期望的状态码是200(OK)。如果接收到的数据为html页面，.expect(‘Content-Type’, ‘text/html;charset=utf-8’)</p>\n<p>3、.end()<br>.end 是执行一个request请求，在回调函数里面根据业务逻辑的返回数据做断言分析。</p>\n<p>4、.send()<br>很多情况下，项目需要测试一个表单业务。supertest提供了.send()方法来发送表单域数据。比如一个登录模块，需要发送用户名密码：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe('test login', function()&#123;</div><div class=\"line\">    it('login sucessfully', function (<span class=\"name\">done</span>) &#123;</div><div class=\"line\">        request.post('/user')</div><div class=\"line\">        .send(&#123;</div><div class=\"line\">            username: 'username',</div><div class=\"line\">            password: '<span class=\"number\">123456</span>'</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .end(<span class=\"name\">function</span> (<span class=\"name\">err</span>, res) &#123;</div><div class=\"line\">            should.not.exists(<span class=\"name\">err</span>)<span class=\"comment\">;</span></div><div class=\"line\">            done()<span class=\"comment\">;</span></div><div class=\"line\">        &#125;)<span class=\"comment\">;</span></div><div class=\"line\">    &#125;)<span class=\"comment\">;</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>5、.attach()<br>.attach方法主要用来测试文件上传，由于.send()只能上传文本域，所以关于multipart -file的上传需要通过附件来绑定。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"title\">request</span><span class=\"params\">(app)</span></span></div><div class=\"line\">.post(<span class=\"string\">'/'</span>)</div><div class=\"line\">.field(<span class=\"string\">'name'</span>, <span class=\"string\">'my awesome avatar'</span>)</div><div class=\"line\">.attach(<span class=\"string\">'avatar'</span>, <span class=\"string\">'test/fixtures/homeboy.jpg'</span>)</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h4 id=\"持久化Cookie\"><a href=\"#持久化Cookie\" class=\"headerlink\" title=\"持久化Cookie\"></a>持久化Cookie</h4><p>在很多业务测试中，需要用户先登录才有权限执行操作。这个时候作为HTTP请求模拟，必须要可以保存一些Cookie数据，也就是Cookie的持久化。这一般有两种解决思路。<br>1、在 supertest 中，可以通过 var request = supertest.agent(app) 获取一个 agent 对象，这个对象的 API 跟直接在 superagent 上调用各种方法是一样的。这个request在被多次调用 get 和 post 之后，可以一路把 cookie 都保存下来。<br><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">var</span> supertest = <span class=\"keyword\">require</span>(<span class=\"string\">'supertest'</span>);</div><div class=\"line\">  <span class=\"built_in\">var</span> app = express();</div><div class=\"line\">  <span class=\"built_in\">var</span> request = supertest.agent(app);</div><div class=\"line\"></div><div class=\"line\">  request.post(<span class=\"string\">'login'</span>).end(<span class=\"params\">...</span>);</div><div class=\"line\">  <span class=\"comment\">// then ..</span></div><div class=\"line\">  request.post(<span class=\"string\">'create_topic'</span>).end(<span class=\"params\">...</span>); <span class=\"comment\">// 此时的request中有用户登陆后的 cookie</span></div></pre></td></tr></table></figure></p>\n<p>2、通过.set()，在发起请求时，调用 .set(‘Cookie’, ‘a cookie string’) 这样的方式。<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = require(<span class=\"string\">'supertest'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> userCookie;</div><div class=\"line\">request.post(<span class=\"string\">'login'</span>)</div><div class=\"line\">.<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> <span class=\"comment\">&#123;</div><div class=\"line\">    userCookie = res.headers['Cookie']</div><div class=\"line\">&#125;</span>);</span></div><div class=\"line\"><span class=\"comment\">// then ..</span></div><div class=\"line\"></div><div class=\"line\">request.post(<span class=\"string\">'create_topic'</span>)</div><div class=\"line\">    .<span class=\"keyword\">set</span>(<span class=\"string\">'Cookie'</span>, userCookie)</div><div class=\"line\">    .<span class=\"keyword\">end</span>(...)</div></pre></td></tr></table></figure></p>\n<h3 id=\"2、实战demo\"><a href=\"#2、实战demo\" class=\"headerlink\" title=\"2、实战demo\"></a>2、实战demo</h3><p>为了更好地帮助理解SuperTest的强大功能，这里放上我的一个项目模块的测试demo。</p>\n<h4 id=\"项目源文件\"><a href=\"#项目源文件\" class=\"headerlink\" title=\"项目源文件\"></a>项目源文件</h4><p>首先，这是一个express应用的登录注册和用户信息修改模块，要测试的就是这个user模块。为了节省篇幅，这里只放上UserController和Router两个项目文件。<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div></pre></td><td class=\"code\"><pre><div class=\"line\">UserController.js</div><div class=\"line\">// 用户首页</div><div class=\"line\">exports.getUser = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!req.user) &#123;</div><div class=\"line\">        res.send(&#123;status: <span class=\"keyword\">false</span>, info: <span class=\"string\">'未登录'</span>&#125;);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        res.render(<span class=\"string\">'user'</span>, &#123;status: <span class=\"keyword\">true</span>, userdata: req.user&#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">exports.login =  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    req.session.save(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        res.redirect(<span class=\"string\">'/user/'</span> + req.user.username);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">exports.logout = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    req.logout();</div><div class=\"line\">    req.session.save(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span> (err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        res.redirect(<span class=\"string\">'/user'</span>);</div><div class=\"line\">        res.<span class=\"keyword\">end</span>();</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 用户注册</div><div class=\"line\">exports.addUser = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!req.body.username || !req.body.password) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> res.send(&#123;status: <span class=\"keyword\">false</span>, info: <span class=\"string\">'用户名或密码不能为空'</span>&#125;);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (req.body.password.length &lt; <span class=\"number\">6</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> res.send(&#123;status: <span class=\"keyword\">false</span>, info: <span class=\"string\">'密码长度太短'</span>&#125;);</div><div class=\"line\">    &#125; </div><div class=\"line\"></div><div class=\"line\">    User.register(new User(&#123;username: req.body.username&#125;), req.body.password, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, user)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> res.render(<span class=\"string\">'register'</span>, &#123;info: <span class=\"string\">'用户名已被使用'</span>&#125;);</div><div class=\"line\">        &#125; </div><div class=\"line\">        passport.authenticate(<span class=\"string\">'local'</span>)(req, res, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span> &#123;</div><div class=\"line\">            req.session.save(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                    log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">                &#125;</div><div class=\"line\">                res.redirect(<span class=\"string\">'/user/'</span> + req.body.username);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 更新用户信息文字资料</div><div class=\"line\">exports.updateInfo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    User.findOne(&#123;username: req.user.username&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, doc)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (doc) &#123;</div><div class=\"line\">            doc.update(req.body, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, data)</span></span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                    log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">                &#125;</div><div class=\"line\">                res.send(&#123;status: <span class=\"keyword\">true</span>&#125;);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">next</span>();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 更换头像</div><div class=\"line\">exports.updateAvator = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res,next)</span></span> &#123;</div><div class=\"line\">    upload(req, res, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        User.findOne(&#123;username: req.user.username&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, doc)</span></span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (doc) &#123;</div><div class=\"line\">                doc.update(&#123;avator: req.file.filename&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, data)</span></span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                        log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    res.<span class=\"built_in\">type</span>(<span class=\"string\">'html'</span>);</div><div class=\"line\">                    res.send(&#123;status: <span class=\"keyword\">true</span>, avator: req.file.filename&#125;);</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>Router文件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">router.get(<span class=\"string\">'/:uid'</span>, isAuthenticated, user.getUser);</div><div class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">    res.render(<span class=\"string\">'login'</span>, &#123;info: <span class=\"string\">''</span>&#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\">router.post(<span class=\"string\">'/'</span>,passport.authenticate(<span class=\"string\">'local'</span>), <span class=\"comment\">/*&#123;failureRedirect: '/user'&#125;),*/</span> user.login);</div><div class=\"line\"></div><div class=\"line\">router.post(<span class=\"string\">'/authenticate/logout'</span>, user.logout);</div><div class=\"line\"></div><div class=\"line\">router.get(<span class=\"string\">'/authenticate/register'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">    res.render(<span class=\"string\">'register'</span>, &#123;info: <span class=\"string\">''</span>&#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">router.post(<span class=\"string\">'/authenticate/register'</span>, user.addUser);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 用户相关的资料</span></div><div class=\"line\">router.post(<span class=\"string\">'/update/info'</span>, user.updateInfo);</div><div class=\"line\">router.post(<span class=\"string\">'/update/avator'</span>, user.updateAvator);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = router;</div></pre></td></tr></table></figure></p>\n<h4 id=\"测试脚本\"><a href=\"#测试脚本\" class=\"headerlink\" title=\"测试脚本\"></a>测试脚本</h4><p>首先，测试注册功能。为了防止用户名冲突，在测试用例之前设置钩子before块，清除User集合。<br><figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// user.test.js</span></div><div class=\"line\">describe(<span class=\"string\">'test user.addUser()'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> &#123;</span></div><div class=\"line\">       before(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           User.remove(&#123;&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span> &#123;</span></div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\"></div><div class=\"line\">       it(<span class=\"string\">'register sucessfully'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user/authenticate/register'</span>)</div><div class=\"line\">           .send(&#123;</div><div class=\"line\">               username: <span class=\"string\">'username'</span>,</div><div class=\"line\">               password: <span class=\"string\">'123456'</span></div><div class=\"line\">           &#125;)</div><div class=\"line\">           <span class=\"comment\">//注册成功之后重定向</span></div><div class=\"line\">           .expect(<span class=\"number\">302</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               should.not.<span class=\"built_in\">exists</span>(err);</div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\">       <span class=\"comment\">//测试用户名存在的用例</span></div><div class=\"line\">       it(<span class=\"string\">'username already exist'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user/authenticate/register'</span>)</div><div class=\"line\">           .send(&#123;</div><div class=\"line\">               username: <span class=\"string\">'username'</span>,</div><div class=\"line\">               password: <span class=\"string\">'123456'</span></div><div class=\"line\">           &#125;)</div><div class=\"line\">           .<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               should.not.<span class=\"built_in\">exists</span>(err);</div><div class=\"line\">               res.text.should.containEql(<span class=\"string\">'用户名已被使用'</span>);</div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\">   &#125;);</div><div class=\"line\">   <span class=\"comment\">// 测试头像上传</span></div><div class=\"line\">   describe(<span class=\"string\">'test user.updateAvator()'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> &#123;</span></div><div class=\"line\">       <span class=\"comment\">//bofore HOOKS，测试业务逻辑之前先登录，并持久化cookie</span></div><div class=\"line\">       before(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user'</span>)</div><div class=\"line\">           .send(&#123;</div><div class=\"line\">               username: <span class=\"string\">'username'</span>,</div><div class=\"line\">               password: <span class=\"string\">'123456'</span></div><div class=\"line\">           &#125;)</div><div class=\"line\">           .<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\"></div><div class=\"line\">       it(<span class=\"string\">'update avator upload sucessfully'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user/update/avator'</span>)</div><div class=\"line\">           .attach(<span class=\"string\">'avator'</span>,<span class=\"string\">'test/image/test.jpg'</span>)</div><div class=\"line\">           .<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               should.not.<span class=\"built_in\">exists</span>(err);</div><div class=\"line\">               res.text.should.containEql(<span class=\"string\">'\"</span>status<span class=\"string\">\":true'</span>);</div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;); </div><div class=\"line\">   &#125;);</div></pre></td></tr></table></figure></p>"},{"title":"Flexbox 布局","date":"2015-09-02T03:57:07.000Z","_content":"\n# 1、简述\n\nFlex布局也叫“弹性盒子布局”，用来为盒状模型提供最大的灵活性。弹性布局的主要思想是让容器有能力来改变项目的宽度和高度，以填满可用空间（主要是为了容纳所有类型的显示设备和屏幕尺寸）的能力。\n最重要的是弹性盒子布局与方向无关，相对于常规的布局（块是垂直和内联水平为基础），很显然，这些工作以及网页设计缺乏灵活性，无法支持大型和复杂的应用程序（特别当它涉及到改变方向，缩放、拉伸和收缩等）。\n\n由于flexbox是一个整体模块，而不是单一的一个属性，它涉及到了很多东西，包括它的整个属性集。它们之中有一些是在父容器上设置，而有一些则是在子容器上设置。\n<!--more-->\n## 2、flexbox属性详解\n首先，需要看看整个弹性盒子的组成，先看下面一个图：\n![flexbox](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)\n\n采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称\"项目\"。\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n\n## 3、容器的flex属性\n\n首先，定义一个flex容器的方法:\n\n```css\n.container {\n  display: -webkit-flex;\n  display: flex; /* or inline-flex */\n}\n```\n容器的属性包括6个：\n* flex-direction\n* flex-wrap\n* flex-flow\n* justify-content\n* align-items\n* align-content\n### 3.1、flex-direction属性\n该属性决定主轴的方向，包括4个值：\n* row（默认值）：主轴为水平方向，起点在左端。\n* row-reverse：主轴为水平方向，起点在右端。\n* column：主轴为垂直方向，起点在上沿。\n* column-reverse：主轴为垂直方向，起点在下沿。\n![flex-direction](https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-direction1.svg)\n\n```css\n.container {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n```\n### 3.2、flex-wrap属性\n默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n一共3个值，\n* nowrap:(默认)不换行\n* wrap：换行\n* wrap-reverse：按照从左往右，换行之后从右到左，再换行从左到右这样的顺序排列\n![flex-wrap](https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-wrap.svg)\n```css\n.container{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n### 3.3、flex-flow属性\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n\n```css\n.container{\n    flex-flow: <‘flex-direction’> || <‘flex-wrap’>\n}\n```\n\n### 3.4、justify-content属性\n定义主轴上面的对齐方式，帮助灵活或者不灵活的元素在未占满整行的时候分布多余的空间。包括5个值：\n* flex-start（默认值）：主轴开始方向对齐\n* flex-end：主轴结束方向对齐\n* center： 居中\n* space-between：两端对齐，项目之间的间隔都相等。\n* space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n![justify-content](https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg)\n```css\n.container {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n\n### 3.5、align-items属性\nalign-items属性定义项目在交叉轴上如何对齐。包括5个值：\n* flex-start：交叉轴的起点对齐。\n* flex-end：交叉轴的终点对齐。\n* center：交叉轴的中点对齐。\n* baseline: 项目的第一行文字的基线对齐。\n* stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n![align-items](https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg)\n\n```css\n.container {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n### 3.6、align-content属性\n定义交叉抽上面有多余空间时的对齐方式。类似于主轴上面对齐的justify-content属性。如果项目只有一根轴线，该属性不起作用。\n该属性可以取6个值：\n* flex-start：与交叉轴的起点对齐。\n* flex-end：与交叉轴的终点对齐。\n* center：与交叉轴的中点对齐。\n* space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n* space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n* stretch（默认值）：轴线占满整个交叉轴。\n\n![align-content](https://cdn.css-tricks.com/wp-content/uploads/2013/04/align-content.svg)\n\n```css\n.container {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n\n## 4、子元素（项目）的属性\n弹性布局元素的子元素的属性包括6个：\n* order\n* flex-grow\n* flex-shrink\n* flex-basis\n* flex\n* align-self\n\n\n### 4.1、order属性\n子元素默认是按照代码声明的顺序铺层的，可以通过order值指定某个子元素的排序。order的取值为整数（可以是负数，默认0）\n![order](https://cdn.css-tricks.com/wp-content/uploads/2013/04/order-2.svg)\n\n```css\n.item {\n  order: <integer>;\n}\n```\n\n### 4.2、flex-grow属性\n该属性定义弹性布局子元素的“生长”能力。\n\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n![flex-grow](https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-grow.svg)\n\n```css\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n\n### 4.3、flex-shrink属性\nflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。不允许为负数。\n\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n```css\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n\n### 4.4、flex-basis属性\n定义剩余空间未分配之前的元素默认尺寸。\n```css\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n\n### 4.5、flex属性\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会自动推算其它相关值。\n```css\n.item {\n  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n}\n```\n\n### 4.6、align-self属性\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该元素包括6个值。\n![align-self](https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-self.svg)\n\n```css\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n本文参考CSS-TRICKS上的文章[A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)、还有阮一峰老师的文章[Flex 布局教程](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool)\n\n\n\n","source":"_posts/Flexbox-布局.md","raw":"title: Flexbox 布局\ndate: 2015-09-02 11:57:07\ntags: \n    - css\ncategories:\n    - 前端开发\n---\n\n# 1、简述\n\nFlex布局也叫“弹性盒子布局”，用来为盒状模型提供最大的灵活性。弹性布局的主要思想是让容器有能力来改变项目的宽度和高度，以填满可用空间（主要是为了容纳所有类型的显示设备和屏幕尺寸）的能力。\n最重要的是弹性盒子布局与方向无关，相对于常规的布局（块是垂直和内联水平为基础），很显然，这些工作以及网页设计缺乏灵活性，无法支持大型和复杂的应用程序（特别当它涉及到改变方向，缩放、拉伸和收缩等）。\n\n由于flexbox是一个整体模块，而不是单一的一个属性，它涉及到了很多东西，包括它的整个属性集。它们之中有一些是在父容器上设置，而有一些则是在子容器上设置。\n<!--more-->\n## 2、flexbox属性详解\n首先，需要看看整个弹性盒子的组成，先看下面一个图：\n![flexbox](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)\n\n采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称\"项目\"。\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n\n## 3、容器的flex属性\n\n首先，定义一个flex容器的方法:\n\n```css\n.container {\n  display: -webkit-flex;\n  display: flex; /* or inline-flex */\n}\n```\n容器的属性包括6个：\n* flex-direction\n* flex-wrap\n* flex-flow\n* justify-content\n* align-items\n* align-content\n### 3.1、flex-direction属性\n该属性决定主轴的方向，包括4个值：\n* row（默认值）：主轴为水平方向，起点在左端。\n* row-reverse：主轴为水平方向，起点在右端。\n* column：主轴为垂直方向，起点在上沿。\n* column-reverse：主轴为垂直方向，起点在下沿。\n![flex-direction](https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-direction1.svg)\n\n```css\n.container {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n```\n### 3.2、flex-wrap属性\n默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n一共3个值，\n* nowrap:(默认)不换行\n* wrap：换行\n* wrap-reverse：按照从左往右，换行之后从右到左，再换行从左到右这样的顺序排列\n![flex-wrap](https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-wrap.svg)\n```css\n.container{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n### 3.3、flex-flow属性\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n\n```css\n.container{\n    flex-flow: <‘flex-direction’> || <‘flex-wrap’>\n}\n```\n\n### 3.4、justify-content属性\n定义主轴上面的对齐方式，帮助灵活或者不灵活的元素在未占满整行的时候分布多余的空间。包括5个值：\n* flex-start（默认值）：主轴开始方向对齐\n* flex-end：主轴结束方向对齐\n* center： 居中\n* space-between：两端对齐，项目之间的间隔都相等。\n* space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n![justify-content](https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg)\n```css\n.container {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n\n### 3.5、align-items属性\nalign-items属性定义项目在交叉轴上如何对齐。包括5个值：\n* flex-start：交叉轴的起点对齐。\n* flex-end：交叉轴的终点对齐。\n* center：交叉轴的中点对齐。\n* baseline: 项目的第一行文字的基线对齐。\n* stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n![align-items](https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg)\n\n```css\n.container {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n### 3.6、align-content属性\n定义交叉抽上面有多余空间时的对齐方式。类似于主轴上面对齐的justify-content属性。如果项目只有一根轴线，该属性不起作用。\n该属性可以取6个值：\n* flex-start：与交叉轴的起点对齐。\n* flex-end：与交叉轴的终点对齐。\n* center：与交叉轴的中点对齐。\n* space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n* space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n* stretch（默认值）：轴线占满整个交叉轴。\n\n![align-content](https://cdn.css-tricks.com/wp-content/uploads/2013/04/align-content.svg)\n\n```css\n.container {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n\n## 4、子元素（项目）的属性\n弹性布局元素的子元素的属性包括6个：\n* order\n* flex-grow\n* flex-shrink\n* flex-basis\n* flex\n* align-self\n\n\n### 4.1、order属性\n子元素默认是按照代码声明的顺序铺层的，可以通过order值指定某个子元素的排序。order的取值为整数（可以是负数，默认0）\n![order](https://cdn.css-tricks.com/wp-content/uploads/2013/04/order-2.svg)\n\n```css\n.item {\n  order: <integer>;\n}\n```\n\n### 4.2、flex-grow属性\n该属性定义弹性布局子元素的“生长”能力。\n\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n![flex-grow](https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-grow.svg)\n\n```css\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n\n### 4.3、flex-shrink属性\nflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。不允许为负数。\n\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n```css\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n\n### 4.4、flex-basis属性\n定义剩余空间未分配之前的元素默认尺寸。\n```css\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n\n### 4.5、flex属性\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会自动推算其它相关值。\n```css\n.item {\n  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n}\n```\n\n### 4.6、align-self属性\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该元素包括6个值。\n![align-self](https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-self.svg)\n\n```css\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n本文参考CSS-TRICKS上的文章[A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)、还有阮一峰老师的文章[Flex 布局教程](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool)\n\n\n\n","slug":"Flexbox-布局","published":1,"updated":"2016-08-13T03:08:44.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtql00097kau18lmfrcf","content":"<h1 id=\"1、简述\"><a href=\"#1、简述\" class=\"headerlink\" title=\"1、简述\"></a>1、简述</h1><p>Flex布局也叫“弹性盒子布局”，用来为盒状模型提供最大的灵活性。弹性布局的主要思想是让容器有能力来改变项目的宽度和高度，以填满可用空间（主要是为了容纳所有类型的显示设备和屏幕尺寸）的能力。<br>最重要的是弹性盒子布局与方向无关，相对于常规的布局（块是垂直和内联水平为基础），很显然，这些工作以及网页设计缺乏灵活性，无法支持大型和复杂的应用程序（特别当它涉及到改变方向，缩放、拉伸和收缩等）。</p>\n<p>由于flexbox是一个整体模块，而不是单一的一个属性，它涉及到了很多东西，包括它的整个属性集。它们之中有一些是在父容器上设置，而有一些则是在子容器上设置。<br><a id=\"more\"></a></p>\n<h2 id=\"2、flexbox属性详解\"><a href=\"#2、flexbox属性详解\" class=\"headerlink\" title=\"2、flexbox属性详解\"></a>2、flexbox属性详解</h2><p>首先，需要看看整个弹性盒子的组成，先看下面一个图：<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png\" alt=\"flexbox\"></p>\n<p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>\n<h2 id=\"3、容器的flex属性\"><a href=\"#3、容器的flex属性\" class=\"headerlink\" title=\"3、容器的flex属性\"></a>3、容器的flex属性</h2><p>首先，定义一个flex容器的方法:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: -webkit-flex;</div><div class=\"line\">  <span class=\"attribute\">display</span>: flex; <span class=\"comment\">/* or inline-flex */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>容器的属性包括6个：</p>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content<h3 id=\"3-1、flex-direction属性\"><a href=\"#3-1、flex-direction属性\" class=\"headerlink\" title=\"3.1、flex-direction属性\"></a>3.1、flex-direction属性</h3>该属性决定主轴的方向，包括4个值：</li>\n<li>row（默认值）：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿。<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-direction1.svg\" alt=\"flex-direction\"></li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-direction</span>: row | row-reverse | column | column-reverse;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-2、flex-wrap属性\"><a href=\"#3-2、flex-wrap属性\" class=\"headerlink\" title=\"3.2、flex-wrap属性\"></a>3.2、flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br>一共3个值，</p>\n<ul>\n<li>nowrap:(默认)不换行</li>\n<li>wrap：换行</li>\n<li>wrap-reverse：按照从左往右，换行之后从右到左，再换行从左到右这样的顺序排列<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-wrap.svg\" alt=\"flex-wrap\"><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">flex-wrap</span>: nowrap | wrap | wrap-reverse;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"3-3、flex-flow属性\"><a href=\"#3-3、flex-flow属性\" class=\"headerlink\" title=\"3.3、flex-flow属性\"></a>3.3、flex-flow属性</h3><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">flex-flow</span>: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-4、justify-content属性\"><a href=\"#3-4、justify-content属性\" class=\"headerlink\" title=\"3.4、justify-content属性\"></a>3.4、justify-content属性</h3><p>定义主轴上面的对齐方式，帮助灵活或者不灵活的元素在未占满整行的时候分布多余的空间。包括5个值：</p>\n<ul>\n<li>flex-start（默认值）：主轴开始方向对齐</li>\n<li>flex-end：主轴结束方向对齐</li>\n<li>center： 居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n<p><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg\" alt=\"justify-content\"><br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-5、align-items属性\"><a href=\"#3-5、align-items属性\" class=\"headerlink\" title=\"3.5、align-items属性\"></a>3.5、align-items属性</h3><p>align-items属性定义项目在交叉轴上如何对齐。包括5个值：</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n<p><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg\" alt=\"align-items\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">align-items</span>: flex-start | flex-end | center | baseline | stretch;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-6、align-content属性\"><a href=\"#3-6、align-content属性\" class=\"headerlink\" title=\"3.6、align-content属性\"></a>3.6、align-content属性</h3><p>定义交叉抽上面有多余空间时的对齐方式。类似于主轴上面对齐的justify-content属性。如果项目只有一根轴线，该属性不起作用。<br>该属性可以取6个值：</p>\n<ul>\n<li>flex-start：与交叉轴的起点对齐。</li>\n<li>flex-end：与交叉轴的终点对齐。</li>\n<li>center：与交叉轴的中点对齐。</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li>stretch（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n<p><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2013/04/align-content.svg\" alt=\"align-content\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"4、子元素（项目）的属性\"><a href=\"#4、子元素（项目）的属性\" class=\"headerlink\" title=\"4、子元素（项目）的属性\"></a>4、子元素（项目）的属性</h2><p>弹性布局元素的子元素的属性包括6个：</p>\n<ul>\n<li>order</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h3 id=\"4-1、order属性\"><a href=\"#4-1、order属性\" class=\"headerlink\" title=\"4.1、order属性\"></a>4.1、order属性</h3><p>子元素默认是按照代码声明的顺序铺层的，可以通过order值指定某个子元素的排序。order的取值为整数（可以是负数，默认0）<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2013/04/order-2.svg\" alt=\"order\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">order</span>: &lt;integer&gt;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-2、flex-grow属性\"><a href=\"#4-2、flex-grow属性\" class=\"headerlink\" title=\"4.2、flex-grow属性\"></a>4.2、flex-grow属性</h3><p>该属性定义弹性布局子元素的“生长”能力。</p>\n<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-grow.svg\" alt=\"flex-grow\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-grow</span>: &lt;number&gt;; <span class=\"comment\">/* default 0 */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-3、flex-shrink属性\"><a href=\"#4-3、flex-shrink属性\" class=\"headerlink\" title=\"4.3、flex-shrink属性\"></a>4.3、flex-shrink属性</h3><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。不允许为负数。</p>\n<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-shrink</span>: &lt;number&gt;; <span class=\"comment\">/* default 1 */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-4、flex-basis属性\"><a href=\"#4-4、flex-basis属性\" class=\"headerlink\" title=\"4.4、flex-basis属性\"></a>4.4、flex-basis属性</h3><p>定义剩余空间未分配之前的元素默认尺寸。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-basis</span>: &lt;length&gt; | auto; <span class=\"comment\">/* default auto */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-5、flex属性\"><a href=\"#4-5、flex属性\" class=\"headerlink\" title=\"4.5、flex属性\"></a>4.5、flex属性</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会自动推算其它相关值。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex</span>: none | [ &lt;<span class=\"string\">'flex-grow'</span>&gt; &lt;<span class=\"string\">'flex-shrink'</span>&gt;? || &lt;<span class=\"string\">'flex-basis'</span>&gt; ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-6、align-self属性\"><a href=\"#4-6、align-self属性\" class=\"headerlink\" title=\"4.6、align-self属性\"></a>4.6、align-self属性</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该元素包括6个值。<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-self.svg\" alt=\"align-self\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>本文参考CSS-TRICKS上的文章<a href=\"https://css-tricks.com/snippets/css/a-guide-to-flexbox/\" target=\"_blank\" rel=\"external\">A Complete Guide to Flexbox</a>、还有阮一峰老师的文章<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool\" target=\"_blank\" rel=\"external\">Flex 布局教程</a></p>\n","excerpt":"<h1 id=\"1、简述\"><a href=\"#1、简述\" class=\"headerlink\" title=\"1、简述\"></a>1、简述</h1><p>Flex布局也叫“弹性盒子布局”，用来为盒状模型提供最大的灵活性。弹性布局的主要思想是让容器有能力来改变项目的宽度和高度，以填满可用空间（主要是为了容纳所有类型的显示设备和屏幕尺寸）的能力。<br>最重要的是弹性盒子布局与方向无关，相对于常规的布局（块是垂直和内联水平为基础），很显然，这些工作以及网页设计缺乏灵活性，无法支持大型和复杂的应用程序（特别当它涉及到改变方向，缩放、拉伸和收缩等）。</p>\n<p>由于flexbox是一个整体模块，而不是单一的一个属性，它涉及到了很多东西，包括它的整个属性集。它们之中有一些是在父容器上设置，而有一些则是在子容器上设置。<br>","more":"</p>\n<h2 id=\"2、flexbox属性详解\"><a href=\"#2、flexbox属性详解\" class=\"headerlink\" title=\"2、flexbox属性详解\"></a>2、flexbox属性详解</h2><p>首先，需要看看整个弹性盒子的组成，先看下面一个图：<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png\" alt=\"flexbox\"></p>\n<p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>\n<h2 id=\"3、容器的flex属性\"><a href=\"#3、容器的flex属性\" class=\"headerlink\" title=\"3、容器的flex属性\"></a>3、容器的flex属性</h2><p>首先，定义一个flex容器的方法:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: -webkit-flex;</div><div class=\"line\">  <span class=\"attribute\">display</span>: flex; <span class=\"comment\">/* or inline-flex */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>容器的属性包括6个：</p>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content<h3 id=\"3-1、flex-direction属性\"><a href=\"#3-1、flex-direction属性\" class=\"headerlink\" title=\"3.1、flex-direction属性\"></a>3.1、flex-direction属性</h3>该属性决定主轴的方向，包括4个值：</li>\n<li>row（默认值）：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿。<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-direction1.svg\" alt=\"flex-direction\"></li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-direction</span>: row | row-reverse | column | column-reverse;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-2、flex-wrap属性\"><a href=\"#3-2、flex-wrap属性\" class=\"headerlink\" title=\"3.2、flex-wrap属性\"></a>3.2、flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br>一共3个值，</p>\n<ul>\n<li>nowrap:(默认)不换行</li>\n<li>wrap：换行</li>\n<li>wrap-reverse：按照从左往右，换行之后从右到左，再换行从左到右这样的顺序排列<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-wrap.svg\" alt=\"flex-wrap\"><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">flex-wrap</span>: nowrap | wrap | wrap-reverse;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"3-3、flex-flow属性\"><a href=\"#3-3、flex-flow属性\" class=\"headerlink\" title=\"3.3、flex-flow属性\"></a>3.3、flex-flow属性</h3><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">flex-flow</span>: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-4、justify-content属性\"><a href=\"#3-4、justify-content属性\" class=\"headerlink\" title=\"3.4、justify-content属性\"></a>3.4、justify-content属性</h3><p>定义主轴上面的对齐方式，帮助灵活或者不灵活的元素在未占满整行的时候分布多余的空间。包括5个值：</p>\n<ul>\n<li>flex-start（默认值）：主轴开始方向对齐</li>\n<li>flex-end：主轴结束方向对齐</li>\n<li>center： 居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n<p><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg\" alt=\"justify-content\"><br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-5、align-items属性\"><a href=\"#3-5、align-items属性\" class=\"headerlink\" title=\"3.5、align-items属性\"></a>3.5、align-items属性</h3><p>align-items属性定义项目在交叉轴上如何对齐。包括5个值：</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n<p><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg\" alt=\"align-items\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">align-items</span>: flex-start | flex-end | center | baseline | stretch;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-6、align-content属性\"><a href=\"#3-6、align-content属性\" class=\"headerlink\" title=\"3.6、align-content属性\"></a>3.6、align-content属性</h3><p>定义交叉抽上面有多余空间时的对齐方式。类似于主轴上面对齐的justify-content属性。如果项目只有一根轴线，该属性不起作用。<br>该属性可以取6个值：</p>\n<ul>\n<li>flex-start：与交叉轴的起点对齐。</li>\n<li>flex-end：与交叉轴的终点对齐。</li>\n<li>center：与交叉轴的中点对齐。</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li>stretch（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n<p><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2013/04/align-content.svg\" alt=\"align-content\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.container</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"4、子元素（项目）的属性\"><a href=\"#4、子元素（项目）的属性\" class=\"headerlink\" title=\"4、子元素（项目）的属性\"></a>4、子元素（项目）的属性</h2><p>弹性布局元素的子元素的属性包括6个：</p>\n<ul>\n<li>order</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h3 id=\"4-1、order属性\"><a href=\"#4-1、order属性\" class=\"headerlink\" title=\"4.1、order属性\"></a>4.1、order属性</h3><p>子元素默认是按照代码声明的顺序铺层的，可以通过order值指定某个子元素的排序。order的取值为整数（可以是负数，默认0）<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2013/04/order-2.svg\" alt=\"order\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">order</span>: &lt;integer&gt;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-2、flex-grow属性\"><a href=\"#4-2、flex-grow属性\" class=\"headerlink\" title=\"4.2、flex-grow属性\"></a>4.2、flex-grow属性</h3><p>该属性定义弹性布局子元素的“生长”能力。</p>\n<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-grow.svg\" alt=\"flex-grow\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-grow</span>: &lt;number&gt;; <span class=\"comment\">/* default 0 */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-3、flex-shrink属性\"><a href=\"#4-3、flex-shrink属性\" class=\"headerlink\" title=\"4.3、flex-shrink属性\"></a>4.3、flex-shrink属性</h3><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。不允许为负数。</p>\n<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-shrink</span>: &lt;number&gt;; <span class=\"comment\">/* default 1 */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-4、flex-basis属性\"><a href=\"#4-4、flex-basis属性\" class=\"headerlink\" title=\"4.4、flex-basis属性\"></a>4.4、flex-basis属性</h3><p>定义剩余空间未分配之前的元素默认尺寸。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex-basis</span>: &lt;length&gt; | auto; <span class=\"comment\">/* default auto */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-5、flex属性\"><a href=\"#4-5、flex属性\" class=\"headerlink\" title=\"4.5、flex属性\"></a>4.5、flex属性</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会自动推算其它相关值。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">flex</span>: none | [ &lt;<span class=\"string\">'flex-grow'</span>&gt; &lt;<span class=\"string\">'flex-shrink'</span>&gt;? || &lt;<span class=\"string\">'flex-basis'</span>&gt; ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-6、align-self属性\"><a href=\"#4-6、align-self属性\" class=\"headerlink\" title=\"4.6、align-self属性\"></a>4.6、align-self属性</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该元素包括6个值。<br><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-self.svg\" alt=\"align-self\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>本文参考CSS-TRICKS上的文章<a href=\"https://css-tricks.com/snippets/css/a-guide-to-flexbox/\">A Complete Guide to Flexbox</a>、还有阮一峰老师的文章<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool\">Flex 布局教程</a></p>"},{"title":"JavaScript高阶函数之currying和uncurrying","date":"2016-01-26T09:27:49.000Z","_content":"在JavaScript高阶函数的应用里面，柯里化 （currying）和反柯里化（uncurrying）是两组比较有意思的应用例子。\n## 一、函数柯里化（function currying）\n### 1、什么是柯里化\n柯里化，俗称“部分求值”。一个柯里化函数首先是会接受一些参数，但是接受这些参数之后，该函数并不会立即求值，而是继续返回另一个函数<!--more-->，刚才传入的参数在函数形成的闭包中被保存起来。等到函数被真正需要求值的时候，之前传入的所有参数会被一次性用于求值(注：摘自AlloyTeam出版的《JavaScript设计模式与开发实践》)。也就是说，柯里化是函数式编程的一种技巧，用于把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数。\n听起来是比较抽象的，下面就拿一个具体的函数柯里化实际场景来做例子：\n假设有这样一个需求：小明去某著名旅游区玩，想吃一下小龙虾。小明是个吃货，一两只虾肯定是不够塞牙缝的，又不知道要买多少才能填饱胃口。于是打算先吃饱再结账。也就是说，小明在这个过程中不关心吃了多少虾，只关心吃饱了之后结账银行卡要减多少数字。这就是柯里化的场景！餐厅老板可能会选择使用下面的算法来结算：\n```\nvar money = 0;\nvar pay = function(oneLobster) {\n    money+=oneLobster;\n}\npay(38);\npay(38);\npay(38);\nconsole.log(money)\n// 小明吃了三只虾，money=114\n```\n上面的代码虽然也可以计算这次吃虾要花多少，但是小明每吃一次都要计算一次总价格，岂不是要累死？于是老板想要一个通用的curry函数，用来计算小明吃饱之后买单要花多少，函数如下：\n```\nvar curry = function (fn) {\n    var args = [];\n    return function() {\n        if (arguments.length === 0) {\n            return fn.apply(this, args);\n        } else {\n            args = args.concat([].slice.call(arguments));\n        }\n    }\n};\n```\n接下来就是用这个函数柯里化小明吃虾的函数了：\n```\nvar pay = (function(){\n    var money = 0;\n    return function(){\n        for (var i=0,l=arguments.length;i <l; i++) {\n            money+=arguments[i];\n        }\n        return money; \n    }\n})();\n\nvar pay = curry(pay)\npay(38);\npay(38);\npay(38);\npay(38);\n... //吃饱买单!\npay(); \n```\n最终小明吃了两盘虾，叫老板来结账。老板说：“上帝你好，您一共消费RMB 760块！”\n“What?我才吃了两盘，怎么算都是76块钱嘛。欺负我没读过书？”小明愤怒道。\n“不好意思，我们的虾来自火星，38块钱一只，您吃了两盘，一共20只”老板一边诡辩一边拿出餐牌，上面只标记“来自星星的虾 38”。\n小明当场吐血！！！\n...\n好吧，以上就是函数柯里化的一个应用场景，当调用pay()的时候，如果明确带上一个参数，那么本次不进行真正的求值计算，只是保存参数（每吃一只虾先记账），并返回一个函数。只有当老板要结算的时候调用不带参数的pay()，才会正真利用前面保存的所有参数进行计算求值（吃完虾结账）。\n但是，从买虾的例子来看，函数柯里化和第一个不使用柯里化的方案看起来并没有什么高端的地方，反而使得代码更复杂。那为什么要介绍柯里化呢？\n### 2、柯里化的作用\n柯里化的应用之一就是惰性加载函数（也有人叫“提前返回”）。很常见的一个例子就是跨浏览器的事件注册，为了兼容ie它老人家，我们一般会这么写事件注册：\n```\nvar addEvent = function(ele, type, fn) {\n    if (window.addEventListener) {\n        return ele.addEventListener(type,fn,false);\n    } else if (window.attachEvent) {\n        return ele.attachEvent(type, fn);\n    }\n};\n```\n那这么写的问题在哪里呢？我们每次使用addEvent为元素添加事件的时候，都会走一遍if...else if ...分支，其实只要一次判定就可以了，这就是惰性函数的用处了。此时函数在第一次进入分支之后，会在函数内部重写这个函数，重写的这个函数就是我们需要的addEvent函数了，下一次进入addEvent函数的时候，函数不再存在条件分支。详细实现如下：\n```\nvar addEvent = function(ele, type, fn) {\n    if (window.addEventListener) {\n        addEvent = function(ele, type, fn) {\n            ele.addEventListener(type,fn,false);\n        } \n\n    } else if (window.attachEvent) {\n        addEvent = function(ele, type, fn) {\n            ele.attachEvent(type,fn);\n        } \n    }\n    //执行\n    addEvent(ele, type, fn);\n}\n```\n## 二、反柯里化(uncurrying)\n个人觉得，其实“反柯里化”这种译法不是特别的贴切。从字面上看，它的作用好像是和柯里化的作用相反，事实上两者之间并没有存在这种关系。\nUncurrying的话题来自JavaScript之父 Brendan Eich在2011年发表的一篇推特，它解决的问题是让对象去借用一个原本不属于自己的方法。在JS的语言环境中，我们可以通过call和apply完成this的转化，同样，用uncurrying可以解决this的转化问题。\nuncurrying的实现非常地简单：\n```\nFunction.prototype.uncurrying = function() {\n    var self = this; //保存现场\n    return function() {\n        //截去第一个参数\n        var obj = Array.prototype.shift.call(arguments);\n        return self.apply(obj,arguments);\n    };\n};\n```\n这段代码的作用就是把属于数组原型对象的函数转化为一个普通的函数，实现相同的功能。比如说，实现一个slice()函数：\n```\nvar slice = Array.prototype.slice.uncurrying();\nvar a = [1,2,3];\nconsole.log(slice(a,1));// [2,3]\n```\n这样，我们就可以把很长的一坨Array.prototype.slice.call()转化为普通的slice函数给自己定义的对象使用，使得代码更加简洁明了。\nUncurrying的另一种实现方式：\n```\nFunction.prototype.uncurrying = function() {\n    var self = this;\n    return function() {\n        return Function.prototype.call.apply(self, arguments);\n    };\n};\n```\n## 结尾\n函数柯里化和反柯里化是高阶函数运用中比较有意思的技巧，在进行js代码编写的时候恰当地使用高阶函数可以使代码性能得到很大的提升。目前这些技巧在JavaScript的各种设计模式里面得到很好地使用。\n\n参考资料：\n《JavaScript设计模式与开发实践》\n[JS中的柯里化(currying)](http://www.zhangxinxu.com/wordpress/2013/02/js-currying/)\n[JavaScript中有趣的反柯里化](http://web.jobbole.com/32059/)\n","source":"_posts/JavaScript高阶函数之currying和uncurrying.md","raw":"title: JavaScript高阶函数之currying和uncurrying\ndate: 2016-01-26 17:27:49\ntags:\n    - js\n    - curring\n    - uncurrying\ncategories:\n    - 前端开发\n---\n在JavaScript高阶函数的应用里面，柯里化 （currying）和反柯里化（uncurrying）是两组比较有意思的应用例子。\n## 一、函数柯里化（function currying）\n### 1、什么是柯里化\n柯里化，俗称“部分求值”。一个柯里化函数首先是会接受一些参数，但是接受这些参数之后，该函数并不会立即求值，而是继续返回另一个函数<!--more-->，刚才传入的参数在函数形成的闭包中被保存起来。等到函数被真正需要求值的时候，之前传入的所有参数会被一次性用于求值(注：摘自AlloyTeam出版的《JavaScript设计模式与开发实践》)。也就是说，柯里化是函数式编程的一种技巧，用于把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数。\n听起来是比较抽象的，下面就拿一个具体的函数柯里化实际场景来做例子：\n假设有这样一个需求：小明去某著名旅游区玩，想吃一下小龙虾。小明是个吃货，一两只虾肯定是不够塞牙缝的，又不知道要买多少才能填饱胃口。于是打算先吃饱再结账。也就是说，小明在这个过程中不关心吃了多少虾，只关心吃饱了之后结账银行卡要减多少数字。这就是柯里化的场景！餐厅老板可能会选择使用下面的算法来结算：\n```\nvar money = 0;\nvar pay = function(oneLobster) {\n    money+=oneLobster;\n}\npay(38);\npay(38);\npay(38);\nconsole.log(money)\n// 小明吃了三只虾，money=114\n```\n上面的代码虽然也可以计算这次吃虾要花多少，但是小明每吃一次都要计算一次总价格，岂不是要累死？于是老板想要一个通用的curry函数，用来计算小明吃饱之后买单要花多少，函数如下：\n```\nvar curry = function (fn) {\n    var args = [];\n    return function() {\n        if (arguments.length === 0) {\n            return fn.apply(this, args);\n        } else {\n            args = args.concat([].slice.call(arguments));\n        }\n    }\n};\n```\n接下来就是用这个函数柯里化小明吃虾的函数了：\n```\nvar pay = (function(){\n    var money = 0;\n    return function(){\n        for (var i=0,l=arguments.length;i <l; i++) {\n            money+=arguments[i];\n        }\n        return money; \n    }\n})();\n\nvar pay = curry(pay)\npay(38);\npay(38);\npay(38);\npay(38);\n... //吃饱买单!\npay(); \n```\n最终小明吃了两盘虾，叫老板来结账。老板说：“上帝你好，您一共消费RMB 760块！”\n“What?我才吃了两盘，怎么算都是76块钱嘛。欺负我没读过书？”小明愤怒道。\n“不好意思，我们的虾来自火星，38块钱一只，您吃了两盘，一共20只”老板一边诡辩一边拿出餐牌，上面只标记“来自星星的虾 38”。\n小明当场吐血！！！\n...\n好吧，以上就是函数柯里化的一个应用场景，当调用pay()的时候，如果明确带上一个参数，那么本次不进行真正的求值计算，只是保存参数（每吃一只虾先记账），并返回一个函数。只有当老板要结算的时候调用不带参数的pay()，才会正真利用前面保存的所有参数进行计算求值（吃完虾结账）。\n但是，从买虾的例子来看，函数柯里化和第一个不使用柯里化的方案看起来并没有什么高端的地方，反而使得代码更复杂。那为什么要介绍柯里化呢？\n### 2、柯里化的作用\n柯里化的应用之一就是惰性加载函数（也有人叫“提前返回”）。很常见的一个例子就是跨浏览器的事件注册，为了兼容ie它老人家，我们一般会这么写事件注册：\n```\nvar addEvent = function(ele, type, fn) {\n    if (window.addEventListener) {\n        return ele.addEventListener(type,fn,false);\n    } else if (window.attachEvent) {\n        return ele.attachEvent(type, fn);\n    }\n};\n```\n那这么写的问题在哪里呢？我们每次使用addEvent为元素添加事件的时候，都会走一遍if...else if ...分支，其实只要一次判定就可以了，这就是惰性函数的用处了。此时函数在第一次进入分支之后，会在函数内部重写这个函数，重写的这个函数就是我们需要的addEvent函数了，下一次进入addEvent函数的时候，函数不再存在条件分支。详细实现如下：\n```\nvar addEvent = function(ele, type, fn) {\n    if (window.addEventListener) {\n        addEvent = function(ele, type, fn) {\n            ele.addEventListener(type,fn,false);\n        } \n\n    } else if (window.attachEvent) {\n        addEvent = function(ele, type, fn) {\n            ele.attachEvent(type,fn);\n        } \n    }\n    //执行\n    addEvent(ele, type, fn);\n}\n```\n## 二、反柯里化(uncurrying)\n个人觉得，其实“反柯里化”这种译法不是特别的贴切。从字面上看，它的作用好像是和柯里化的作用相反，事实上两者之间并没有存在这种关系。\nUncurrying的话题来自JavaScript之父 Brendan Eich在2011年发表的一篇推特，它解决的问题是让对象去借用一个原本不属于自己的方法。在JS的语言环境中，我们可以通过call和apply完成this的转化，同样，用uncurrying可以解决this的转化问题。\nuncurrying的实现非常地简单：\n```\nFunction.prototype.uncurrying = function() {\n    var self = this; //保存现场\n    return function() {\n        //截去第一个参数\n        var obj = Array.prototype.shift.call(arguments);\n        return self.apply(obj,arguments);\n    };\n};\n```\n这段代码的作用就是把属于数组原型对象的函数转化为一个普通的函数，实现相同的功能。比如说，实现一个slice()函数：\n```\nvar slice = Array.prototype.slice.uncurrying();\nvar a = [1,2,3];\nconsole.log(slice(a,1));// [2,3]\n```\n这样，我们就可以把很长的一坨Array.prototype.slice.call()转化为普通的slice函数给自己定义的对象使用，使得代码更加简洁明了。\nUncurrying的另一种实现方式：\n```\nFunction.prototype.uncurrying = function() {\n    var self = this;\n    return function() {\n        return Function.prototype.call.apply(self, arguments);\n    };\n};\n```\n## 结尾\n函数柯里化和反柯里化是高阶函数运用中比较有意思的技巧，在进行js代码编写的时候恰当地使用高阶函数可以使代码性能得到很大的提升。目前这些技巧在JavaScript的各种设计模式里面得到很好地使用。\n\n参考资料：\n《JavaScript设计模式与开发实践》\n[JS中的柯里化(currying)](http://www.zhangxinxu.com/wordpress/2013/02/js-currying/)\n[JavaScript中有趣的反柯里化](http://web.jobbole.com/32059/)\n","slug":"JavaScript高阶函数之currying和uncurrying","published":1,"updated":"2016-08-13T03:08:44.531Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtqm000b7kautrheecl5","content":"<p>在JavaScript高阶函数的应用里面，柯里化 （currying）和反柯里化（uncurrying）是两组比较有意思的应用例子。</p>\n<h2 id=\"一、函数柯里化（function-currying）\"><a href=\"#一、函数柯里化（function-currying）\" class=\"headerlink\" title=\"一、函数柯里化（function currying）\"></a>一、函数柯里化（function currying）</h2><h3 id=\"1、什么是柯里化\"><a href=\"#1、什么是柯里化\" class=\"headerlink\" title=\"1、什么是柯里化\"></a>1、什么是柯里化</h3><p>柯里化，俗称“部分求值”。一个柯里化函数首先是会接受一些参数，但是接受这些参数之后，该函数并不会立即求值，而是继续返回另一个函数<a id=\"more\"></a>，刚才传入的参数在函数形成的闭包中被保存起来。等到函数被真正需要求值的时候，之前传入的所有参数会被一次性用于求值(注：摘自AlloyTeam出版的《JavaScript设计模式与开发实践》)。也就是说，柯里化是函数式编程的一种技巧，用于把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数。<br>听起来是比较抽象的，下面就拿一个具体的函数柯里化实际场景来做例子：<br>假设有这样一个需求：小明去某著名旅游区玩，想吃一下小龙虾。小明是个吃货，一两只虾肯定是不够塞牙缝的，又不知道要买多少才能填饱胃口。于是打算先吃饱再结账。也就是说，小明在这个过程中不关心吃了多少虾，只关心吃饱了之后结账银行卡要减多少数字。这就是柯里化的场景！餐厅老板可能会选择使用下面的算法来结算：<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var <span class=\"section\">money</span> = <span class=\"number\">0</span>;</div><div class=\"line\">var pay = function(oneLobster) &#123;</div><div class=\"line\">    <span class=\"section\">money</span>+=oneLobster;</div><div class=\"line\">&#125;</div><div class=\"line\">pay(<span class=\"number\">38</span>);</div><div class=\"line\">pay(<span class=\"number\">38</span>);</div><div class=\"line\">pay(<span class=\"number\">38</span>);</div><div class=\"line\">console.log(<span class=\"section\">money</span>)</div><div class=\"line\"><span class=\"comment\">// 小明吃了三只虾，money=114</span></div></pre></td></tr></table></figure></p>\n<p>上面的代码虽然也可以计算这次吃虾要花多少，但是小明每吃一次都要计算一次总价格，岂不是要累死？于是老板想要一个通用的curry函数，用来计算小明吃饱之后买单要花多少，函数如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> curry = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> args = [];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length === <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, args);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            args = args.concat([].slice.call(<span class=\"built_in\">arguments</span>));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>接下来就是用这个函数柯里化小明吃虾的函数了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pay = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> money = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>,l=<span class=\"built_in\">arguments</span>.length;i &lt;l; i++) &#123;</div><div class=\"line\">            money+=<span class=\"built_in\">arguments</span>[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> money; </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> pay = curry(pay)</div><div class=\"line\">pay(<span class=\"number\">38</span>);</div><div class=\"line\">pay(<span class=\"number\">38</span>);</div><div class=\"line\">pay(<span class=\"number\">38</span>);</div><div class=\"line\">pay(<span class=\"number\">38</span>);</div><div class=\"line\">... <span class=\"comment\">//吃饱买单!</span></div><div class=\"line\">pay();</div></pre></td></tr></table></figure></p>\n<p>最终小明吃了两盘虾，叫老板来结账。老板说：“上帝你好，您一共消费RMB 760块！”<br>“What?我才吃了两盘，怎么算都是76块钱嘛。欺负我没读过书？”小明愤怒道。<br>“不好意思，我们的虾来自火星，38块钱一只，您吃了两盘，一共20只”老板一边诡辩一边拿出餐牌，上面只标记“来自星星的虾 38”。<br>小明当场吐血！！！<br>…<br>好吧，以上就是函数柯里化的一个应用场景，当调用pay()的时候，如果明确带上一个参数，那么本次不进行真正的求值计算，只是保存参数（每吃一只虾先记账），并返回一个函数。只有当老板要结算的时候调用不带参数的pay()，才会正真利用前面保存的所有参数进行计算求值（吃完虾结账）。<br>但是，从买虾的例子来看，函数柯里化和第一个不使用柯里化的方案看起来并没有什么高端的地方，反而使得代码更复杂。那为什么要介绍柯里化呢？</p>\n<h3 id=\"2、柯里化的作用\"><a href=\"#2、柯里化的作用\" class=\"headerlink\" title=\"2、柯里化的作用\"></a>2、柯里化的作用</h3><p>柯里化的应用之一就是惰性加载函数（也有人叫“提前返回”）。很常见的一个例子就是跨浏览器的事件注册，为了兼容ie它老人家，我们一般会这么写事件注册：<br><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var addEvent = function(ele, <span class=\"built_in\">type</span>, <span class=\"function\"><span class=\"keyword\">fn</span>) &#123;</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"params\">(<span class=\"built_in\">window</span>.addEventListener)</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> ele.addEventListener<span class=\"params\">(<span class=\"built_in\">type</span>,<span class=\"keyword\">fn</span>,false)</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.attachEvent) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> ele.attachEvent(<span class=\"built_in\">type</span>, <span class=\"function\"><span class=\"keyword\">fn</span>)</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>那这么写的问题在哪里呢？我们每次使用addEvent为元素添加事件的时候，都会走一遍if…else if …分支，其实只要一次判定就可以了，这就是惰性函数的用处了。此时函数在第一次进入分支之后，会在函数内部重写这个函数，重写的这个函数就是我们需要的addEvent函数了，下一次进入addEvent函数的时候，函数不再存在条件分支。详细实现如下：<br><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var addEvent = function(ele, <span class=\"built_in\">type</span>, <span class=\"function\"><span class=\"keyword\">fn</span>) &#123;</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"params\">(<span class=\"built_in\">window</span>.addEventListener)</span> &#123;</div><div class=\"line\">        <span class=\"title\">addEvent</span> = function<span class=\"params\">(ele, <span class=\"built_in\">type</span>, <span class=\"keyword\">fn</span>)</span> &#123;</div><div class=\"line\">            ele.addEventListener<span class=\"params\">(<span class=\"built_in\">type</span>,<span class=\"keyword\">fn</span>,false)</span>;</div><div class=\"line\">        &#125; </div><div class=\"line\"></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.attachEvent) &#123;</div><div class=\"line\">        addEvent = function(ele, <span class=\"built_in\">type</span>, <span class=\"function\"><span class=\"keyword\">fn</span>) &#123;</span></div><div class=\"line\">            ele.attachEvent<span class=\"params\">(<span class=\"built_in\">type</span>,<span class=\"keyword\">fn</span>)</span>;</div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//执行</span></div><div class=\"line\">    addEvent(ele, <span class=\"built_in\">type</span>, <span class=\"function\"><span class=\"keyword\">fn</span>)</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"二、反柯里化-uncurrying\"><a href=\"#二、反柯里化-uncurrying\" class=\"headerlink\" title=\"二、反柯里化(uncurrying)\"></a>二、反柯里化(uncurrying)</h2><p>个人觉得，其实“反柯里化”这种译法不是特别的贴切。从字面上看，它的作用好像是和柯里化的作用相反，事实上两者之间并没有存在这种关系。<br>Uncurrying的话题来自JavaScript之父 Brendan Eich在2011年发表的一篇推特，它解决的问题是让对象去借用一个原本不属于自己的方法。在JS的语言环境中，我们可以通过call和apply完成this的转化，同样，用uncurrying可以解决this的转化问题。<br>uncurrying的实现非常地简单：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Function</span>.prototype.uncurrying = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>; <span class=\"comment\">//保存现场</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//截去第一个参数</span></div><div class=\"line\">        <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Array</span>.prototype.shift.call(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> self.apply(obj,<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>这段代码的作用就是把属于数组原型对象的函数转化为一个普通的函数，实现相同的功能。比如说，实现一个slice()函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> slice = <span class=\"built_in\">Array</span>.prototype.slice.uncurrying();</div><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"built_in\">console</span>.log(slice(a,<span class=\"number\">1</span>));<span class=\"comment\">// [2,3]</span></div></pre></td></tr></table></figure></p>\n<p>这样，我们就可以把很长的一坨Array.prototype.slice.call()转化为普通的slice函数给自己定义的对象使用，使得代码更加简洁明了。<br>Uncurrying的另一种实现方式：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Function</span>.prototype.uncurrying = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Function</span>.prototype.call.apply(self, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>函数柯里化和反柯里化是高阶函数运用中比较有意思的技巧，在进行js代码编写的时候恰当地使用高阶函数可以使代码性能得到很大的提升。目前这些技巧在JavaScript的各种设计模式里面得到很好地使用。</p>\n<p>参考资料：<br>《JavaScript设计模式与开发实践》<br><a href=\"http://www.zhangxinxu.com/wordpress/2013/02/js-currying/\" target=\"_blank\" rel=\"external\">JS中的柯里化(currying)</a><br><a href=\"http://web.jobbole.com/32059/\" target=\"_blank\" rel=\"external\">JavaScript中有趣的反柯里化</a></p>\n","excerpt":"<p>在JavaScript高阶函数的应用里面，柯里化 （currying）和反柯里化（uncurrying）是两组比较有意思的应用例子。</p>\n<h2 id=\"一、函数柯里化（function-currying）\"><a href=\"#一、函数柯里化（function-currying）\" class=\"headerlink\" title=\"一、函数柯里化（function currying）\"></a>一、函数柯里化（function currying）</h2><h3 id=\"1、什么是柯里化\"><a href=\"#1、什么是柯里化\" class=\"headerlink\" title=\"1、什么是柯里化\"></a>1、什么是柯里化</h3><p>柯里化，俗称“部分求值”。一个柯里化函数首先是会接受一些参数，但是接受这些参数之后，该函数并不会立即求值，而是继续返回另一个函数","more":"，刚才传入的参数在函数形成的闭包中被保存起来。等到函数被真正需要求值的时候，之前传入的所有参数会被一次性用于求值(注：摘自AlloyTeam出版的《JavaScript设计模式与开发实践》)。也就是说，柯里化是函数式编程的一种技巧，用于把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数。<br>听起来是比较抽象的，下面就拿一个具体的函数柯里化实际场景来做例子：<br>假设有这样一个需求：小明去某著名旅游区玩，想吃一下小龙虾。小明是个吃货，一两只虾肯定是不够塞牙缝的，又不知道要买多少才能填饱胃口。于是打算先吃饱再结账。也就是说，小明在这个过程中不关心吃了多少虾，只关心吃饱了之后结账银行卡要减多少数字。这就是柯里化的场景！餐厅老板可能会选择使用下面的算法来结算：<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var <span class=\"section\">money</span> = <span class=\"number\">0</span>;</div><div class=\"line\">var pay = function(oneLobster) &#123;</div><div class=\"line\">    <span class=\"section\">money</span>+=oneLobster;</div><div class=\"line\">&#125;</div><div class=\"line\">pay(<span class=\"number\">38</span>);</div><div class=\"line\">pay(<span class=\"number\">38</span>);</div><div class=\"line\">pay(<span class=\"number\">38</span>);</div><div class=\"line\">console.log(<span class=\"section\">money</span>)</div><div class=\"line\"><span class=\"comment\">// 小明吃了三只虾，money=114</span></div></pre></td></tr></table></figure></p>\n<p>上面的代码虽然也可以计算这次吃虾要花多少，但是小明每吃一次都要计算一次总价格，岂不是要累死？于是老板想要一个通用的curry函数，用来计算小明吃饱之后买单要花多少，函数如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> curry = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> args = [];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length === <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, args);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            args = args.concat([].slice.call(<span class=\"built_in\">arguments</span>));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>接下来就是用这个函数柯里化小明吃虾的函数了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pay = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> money = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>,l=<span class=\"built_in\">arguments</span>.length;i &lt;l; i++) &#123;</div><div class=\"line\">            money+=<span class=\"built_in\">arguments</span>[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> money; </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> pay = curry(pay)</div><div class=\"line\">pay(<span class=\"number\">38</span>);</div><div class=\"line\">pay(<span class=\"number\">38</span>);</div><div class=\"line\">pay(<span class=\"number\">38</span>);</div><div class=\"line\">pay(<span class=\"number\">38</span>);</div><div class=\"line\">... <span class=\"comment\">//吃饱买单!</span></div><div class=\"line\">pay();</div></pre></td></tr></table></figure></p>\n<p>最终小明吃了两盘虾，叫老板来结账。老板说：“上帝你好，您一共消费RMB 760块！”<br>“What?我才吃了两盘，怎么算都是76块钱嘛。欺负我没读过书？”小明愤怒道。<br>“不好意思，我们的虾来自火星，38块钱一只，您吃了两盘，一共20只”老板一边诡辩一边拿出餐牌，上面只标记“来自星星的虾 38”。<br>小明当场吐血！！！<br>…<br>好吧，以上就是函数柯里化的一个应用场景，当调用pay()的时候，如果明确带上一个参数，那么本次不进行真正的求值计算，只是保存参数（每吃一只虾先记账），并返回一个函数。只有当老板要结算的时候调用不带参数的pay()，才会正真利用前面保存的所有参数进行计算求值（吃完虾结账）。<br>但是，从买虾的例子来看，函数柯里化和第一个不使用柯里化的方案看起来并没有什么高端的地方，反而使得代码更复杂。那为什么要介绍柯里化呢？</p>\n<h3 id=\"2、柯里化的作用\"><a href=\"#2、柯里化的作用\" class=\"headerlink\" title=\"2、柯里化的作用\"></a>2、柯里化的作用</h3><p>柯里化的应用之一就是惰性加载函数（也有人叫“提前返回”）。很常见的一个例子就是跨浏览器的事件注册，为了兼容ie它老人家，我们一般会这么写事件注册：<br><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var addEvent = function(ele, <span class=\"built_in\">type</span>, <span class=\"function\"><span class=\"keyword\">fn</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"params\">(<span class=\"built_in\">window</span>.addEventListener)</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> ele.addEventListener<span class=\"params\">(<span class=\"built_in\">type</span>,<span class=\"keyword\">fn</span>,false)</span></span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.attachEvent) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> ele.attachEvent(<span class=\"built_in\">type</span>, <span class=\"function\"><span class=\"keyword\">fn</span>)</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>那这么写的问题在哪里呢？我们每次使用addEvent为元素添加事件的时候，都会走一遍if…else if …分支，其实只要一次判定就可以了，这就是惰性函数的用处了。此时函数在第一次进入分支之后，会在函数内部重写这个函数，重写的这个函数就是我们需要的addEvent函数了，下一次进入addEvent函数的时候，函数不再存在条件分支。详细实现如下：<br><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var addEvent = function(ele, <span class=\"built_in\">type</span>, <span class=\"function\"><span class=\"keyword\">fn</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"params\">(<span class=\"built_in\">window</span>.addEventListener)</span> &#123;</div><div class=\"line\">        <span class=\"title\">addEvent</span> = function<span class=\"params\">(ele, <span class=\"built_in\">type</span>, <span class=\"keyword\">fn</span>)</span> &#123;</div><div class=\"line\">            ele.addEventListener<span class=\"params\">(<span class=\"built_in\">type</span>,<span class=\"keyword\">fn</span>,false)</span></span>;</div><div class=\"line\">        &#125; </div><div class=\"line\"></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.attachEvent) &#123;</div><div class=\"line\">        addEvent = function(ele, <span class=\"built_in\">type</span>, <span class=\"function\"><span class=\"keyword\">fn</span>) &#123;</div><div class=\"line\">            ele.attachEvent<span class=\"params\">(<span class=\"built_in\">type</span>,<span class=\"keyword\">fn</span>)</span></span>;</div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//执行</span></div><div class=\"line\">    addEvent(ele, <span class=\"built_in\">type</span>, <span class=\"function\"><span class=\"keyword\">fn</span>)</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"二、反柯里化-uncurrying\"><a href=\"#二、反柯里化-uncurrying\" class=\"headerlink\" title=\"二、反柯里化(uncurrying)\"></a>二、反柯里化(uncurrying)</h2><p>个人觉得，其实“反柯里化”这种译法不是特别的贴切。从字面上看，它的作用好像是和柯里化的作用相反，事实上两者之间并没有存在这种关系。<br>Uncurrying的话题来自JavaScript之父 Brendan Eich在2011年发表的一篇推特，它解决的问题是让对象去借用一个原本不属于自己的方法。在JS的语言环境中，我们可以通过call和apply完成this的转化，同样，用uncurrying可以解决this的转化问题。<br>uncurrying的实现非常地简单：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Function</span>.prototype.uncurrying = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>; <span class=\"comment\">//保存现场</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//截去第一个参数</span></div><div class=\"line\">        <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Array</span>.prototype.shift.call(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> self.apply(obj,<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>这段代码的作用就是把属于数组原型对象的函数转化为一个普通的函数，实现相同的功能。比如说，实现一个slice()函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> slice = <span class=\"built_in\">Array</span>.prototype.slice.uncurrying();</div><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"built_in\">console</span>.log(slice(a,<span class=\"number\">1</span>));<span class=\"comment\">// [2,3]</span></div></pre></td></tr></table></figure></p>\n<p>这样，我们就可以把很长的一坨Array.prototype.slice.call()转化为普通的slice函数给自己定义的对象使用，使得代码更加简洁明了。<br>Uncurrying的另一种实现方式：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Function</span>.prototype.uncurrying = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Function</span>.prototype.call.apply(self, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>函数柯里化和反柯里化是高阶函数运用中比较有意思的技巧，在进行js代码编写的时候恰当地使用高阶函数可以使代码性能得到很大的提升。目前这些技巧在JavaScript的各种设计模式里面得到很好地使用。</p>\n<p>参考资料：<br>《JavaScript设计模式与开发实践》<br><a href=\"http://www.zhangxinxu.com/wordpress/2013/02/js-currying/\">JS中的柯里化(currying)</a><br><a href=\"http://web.jobbole.com/32059/\">JavaScript中有趣的反柯里化</a></p>"},{"title":"React.js那些事(core篇)","date":"2015-10-07T08:03:42.000Z","_content":"\n这一篇主要讲讲React.js虚拟DOM的底层相关，主要是自己学习官方文档的Reconciliation部分的一些总结。我们都知道，React的虚拟DOM是非常高效的。那么，React底层是使用什么样的算法实现DOM的高效渲染呢？\n<!--more-->\n# 机制\nReact.js在内存里的DOM树操作是子树的替换，也就是用变化之后的子树整个代替原来的子树，而不是在内存里面调整子树。从算法的角度来说，生成最少的将一颗树形结构转换成另一颗树形结构的操作，其最优算法的复杂度是 O(n3)，n是树中节点的总数。所以React尝试从另一个方面入手，使用试探的方法。首先需要达成两点假设：\n1、拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。\n2、可以为元素提供一个唯一的标志，该元素在不同的渲染过程中保持不变。实际上，这些假设会使在几乎所有的应用场景下，应用变得出奇地快。\n\n# 详细\n## diffing算法\n为了实现子树的替换，首先必须要检查两棵树的差异。React的处理机制分三种类型处理。\n![示例1](http://huguozhi-media.stor.sinaapp.com/mygitio%2F1.png)\n### 不同的节点类型\n节点类型不同，React 将会把它们当做两个不同的子树，移除之前的那棵子树，然后创建并插入第二棵子树。React不会尝试计算出该渲染什么，仅会从 DOM中移除之前的节点，然后插入新的节点。碰到不一样的组件结构，React将重新创建树形结构，而不是耗费时间去尝试匹配这两个树形结构。所以，React的虚拟DOM是非常高效的。\n\n### DOM节点\nDOM节点是相同类型的，比较两个DOM节点的时候，首先查看属性。对随着时间发生了变化的属性进行更新，然后递归检查所有子级的属性。\n\n### 自定义组件\n我们决定两个自定义组件是相同的。因为组件是状态化的，不可能每次状态改变都要创建一个新的组件实例。React 利用新组件上的所有属性，然后在之前的组件实例上调用 component[Will/Did]ReceiveProps()。现在，之前的组件就是可操作了的。它的 render() 方法被调用，然后差异算法重新比较新的状态和上一次的状态。\n\n## 子级优化差异\nReact采用的方法是同时遍历两个子级列表，当发现差异的时候，就产生一次 DOM 修改。例如我们如果需要在组件末尾添加一个元素，那么如果两个子级（原有的和新添加的）是相同元素，则直接修改已有子级元素的文本内容，然后在后面插入一个新的子级节点。\n另外，React引入一个唯一的key属性，给每一个子级一个键值，用于和以后变化的组件进行比较。这样，React就能够检测出节点插入、移除和替换，并且借助哈希表使节点移动复杂度为 O(n)。\n![示例1](http://huguozhi-media.stor.sinaapp.com/mygitio%2F2.png)\n\n# 本篇结语\n这一篇主要是介绍React的渲染机制，虚拟dom是React.js的核心。想要更多地了解React.js的朋友可以进入[官方文档](http://reactjs.cn/)进行深入学习。\n\n","source":"_posts/React-js那些事-core篇.md","raw":"title: React.js那些事(core篇)\ndate: 2015-10-07 16:03:42\ntags:\n    - React\n    - virtual dom\ncategories:\n    - 前端开发\n---\n\n这一篇主要讲讲React.js虚拟DOM的底层相关，主要是自己学习官方文档的Reconciliation部分的一些总结。我们都知道，React的虚拟DOM是非常高效的。那么，React底层是使用什么样的算法实现DOM的高效渲染呢？\n<!--more-->\n# 机制\nReact.js在内存里的DOM树操作是子树的替换，也就是用变化之后的子树整个代替原来的子树，而不是在内存里面调整子树。从算法的角度来说，生成最少的将一颗树形结构转换成另一颗树形结构的操作，其最优算法的复杂度是 O(n3)，n是树中节点的总数。所以React尝试从另一个方面入手，使用试探的方法。首先需要达成两点假设：\n1、拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。\n2、可以为元素提供一个唯一的标志，该元素在不同的渲染过程中保持不变。实际上，这些假设会使在几乎所有的应用场景下，应用变得出奇地快。\n\n# 详细\n## diffing算法\n为了实现子树的替换，首先必须要检查两棵树的差异。React的处理机制分三种类型处理。\n![示例1](http://huguozhi-media.stor.sinaapp.com/mygitio%2F1.png)\n### 不同的节点类型\n节点类型不同，React 将会把它们当做两个不同的子树，移除之前的那棵子树，然后创建并插入第二棵子树。React不会尝试计算出该渲染什么，仅会从 DOM中移除之前的节点，然后插入新的节点。碰到不一样的组件结构，React将重新创建树形结构，而不是耗费时间去尝试匹配这两个树形结构。所以，React的虚拟DOM是非常高效的。\n\n### DOM节点\nDOM节点是相同类型的，比较两个DOM节点的时候，首先查看属性。对随着时间发生了变化的属性进行更新，然后递归检查所有子级的属性。\n\n### 自定义组件\n我们决定两个自定义组件是相同的。因为组件是状态化的，不可能每次状态改变都要创建一个新的组件实例。React 利用新组件上的所有属性，然后在之前的组件实例上调用 component[Will/Did]ReceiveProps()。现在，之前的组件就是可操作了的。它的 render() 方法被调用，然后差异算法重新比较新的状态和上一次的状态。\n\n## 子级优化差异\nReact采用的方法是同时遍历两个子级列表，当发现差异的时候，就产生一次 DOM 修改。例如我们如果需要在组件末尾添加一个元素，那么如果两个子级（原有的和新添加的）是相同元素，则直接修改已有子级元素的文本内容，然后在后面插入一个新的子级节点。\n另外，React引入一个唯一的key属性，给每一个子级一个键值，用于和以后变化的组件进行比较。这样，React就能够检测出节点插入、移除和替换，并且借助哈希表使节点移动复杂度为 O(n)。\n![示例1](http://huguozhi-media.stor.sinaapp.com/mygitio%2F2.png)\n\n# 本篇结语\n这一篇主要是介绍React的渲染机制，虚拟dom是React.js的核心。想要更多地了解React.js的朋友可以进入[官方文档](http://reactjs.cn/)进行深入学习。\n\n","slug":"React-js那些事-core篇","published":1,"updated":"2016-08-13T03:08:44.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtqq000g7kauvl12dnkv","content":"<p>这一篇主要讲讲React.js虚拟DOM的底层相关，主要是自己学习官方文档的Reconciliation部分的一些总结。我们都知道，React的虚拟DOM是非常高效的。那么，React底层是使用什么样的算法实现DOM的高效渲染呢？<br><a id=\"more\"></a></p>\n<h1 id=\"机制\"><a href=\"#机制\" class=\"headerlink\" title=\"机制\"></a>机制</h1><p>React.js在内存里的DOM树操作是子树的替换，也就是用变化之后的子树整个代替原来的子树，而不是在内存里面调整子树。从算法的角度来说，生成最少的将一颗树形结构转换成另一颗树形结构的操作，其最优算法的复杂度是 O(n3)，n是树中节点的总数。所以React尝试从另一个方面入手，使用试探的方法。首先需要达成两点假设：<br>1、拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。<br>2、可以为元素提供一个唯一的标志，该元素在不同的渲染过程中保持不变。实际上，这些假设会使在几乎所有的应用场景下，应用变得出奇地快。</p>\n<h1 id=\"详细\"><a href=\"#详细\" class=\"headerlink\" title=\"详细\"></a>详细</h1><h2 id=\"diffing算法\"><a href=\"#diffing算法\" class=\"headerlink\" title=\"diffing算法\"></a>diffing算法</h2><p>为了实现子树的替换，首先必须要检查两棵树的差异。React的处理机制分三种类型处理。<br><img src=\"http://huguozhi-media.stor.sinaapp.com/mygitio%2F1.png\" alt=\"示例1\"></p>\n<h3 id=\"不同的节点类型\"><a href=\"#不同的节点类型\" class=\"headerlink\" title=\"不同的节点类型\"></a>不同的节点类型</h3><p>节点类型不同，React 将会把它们当做两个不同的子树，移除之前的那棵子树，然后创建并插入第二棵子树。React不会尝试计算出该渲染什么，仅会从 DOM中移除之前的节点，然后插入新的节点。碰到不一样的组件结构，React将重新创建树形结构，而不是耗费时间去尝试匹配这两个树形结构。所以，React的虚拟DOM是非常高效的。</p>\n<h3 id=\"DOM节点\"><a href=\"#DOM节点\" class=\"headerlink\" title=\"DOM节点\"></a>DOM节点</h3><p>DOM节点是相同类型的，比较两个DOM节点的时候，首先查看属性。对随着时间发生了变化的属性进行更新，然后递归检查所有子级的属性。</p>\n<h3 id=\"自定义组件\"><a href=\"#自定义组件\" class=\"headerlink\" title=\"自定义组件\"></a>自定义组件</h3><p>我们决定两个自定义组件是相同的。因为组件是状态化的，不可能每次状态改变都要创建一个新的组件实例。React 利用新组件上的所有属性，然后在之前的组件实例上调用 component[Will/Did]ReceiveProps()。现在，之前的组件就是可操作了的。它的 render() 方法被调用，然后差异算法重新比较新的状态和上一次的状态。</p>\n<h2 id=\"子级优化差异\"><a href=\"#子级优化差异\" class=\"headerlink\" title=\"子级优化差异\"></a>子级优化差异</h2><p>React采用的方法是同时遍历两个子级列表，当发现差异的时候，就产生一次 DOM 修改。例如我们如果需要在组件末尾添加一个元素，那么如果两个子级（原有的和新添加的）是相同元素，则直接修改已有子级元素的文本内容，然后在后面插入一个新的子级节点。<br>另外，React引入一个唯一的key属性，给每一个子级一个键值，用于和以后变化的组件进行比较。这样，React就能够检测出节点插入、移除和替换，并且借助哈希表使节点移动复杂度为 O(n)。<br><img src=\"http://huguozhi-media.stor.sinaapp.com/mygitio%2F2.png\" alt=\"示例1\"></p>\n<h1 id=\"本篇结语\"><a href=\"#本篇结语\" class=\"headerlink\" title=\"本篇结语\"></a>本篇结语</h1><p>这一篇主要是介绍React的渲染机制，虚拟dom是React.js的核心。想要更多地了解React.js的朋友可以进入<a href=\"http://reactjs.cn/\" target=\"_blank\" rel=\"external\">官方文档</a>进行深入学习。</p>\n","excerpt":"<p>这一篇主要讲讲React.js虚拟DOM的底层相关，主要是自己学习官方文档的Reconciliation部分的一些总结。我们都知道，React的虚拟DOM是非常高效的。那么，React底层是使用什么样的算法实现DOM的高效渲染呢？<br>","more":"</p>\n<h1 id=\"机制\"><a href=\"#机制\" class=\"headerlink\" title=\"机制\"></a>机制</h1><p>React.js在内存里的DOM树操作是子树的替换，也就是用变化之后的子树整个代替原来的子树，而不是在内存里面调整子树。从算法的角度来说，生成最少的将一颗树形结构转换成另一颗树形结构的操作，其最优算法的复杂度是 O(n3)，n是树中节点的总数。所以React尝试从另一个方面入手，使用试探的方法。首先需要达成两点假设：<br>1、拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。<br>2、可以为元素提供一个唯一的标志，该元素在不同的渲染过程中保持不变。实际上，这些假设会使在几乎所有的应用场景下，应用变得出奇地快。</p>\n<h1 id=\"详细\"><a href=\"#详细\" class=\"headerlink\" title=\"详细\"></a>详细</h1><h2 id=\"diffing算法\"><a href=\"#diffing算法\" class=\"headerlink\" title=\"diffing算法\"></a>diffing算法</h2><p>为了实现子树的替换，首先必须要检查两棵树的差异。React的处理机制分三种类型处理。<br><img src=\"http://huguozhi-media.stor.sinaapp.com/mygitio%2F1.png\" alt=\"示例1\"></p>\n<h3 id=\"不同的节点类型\"><a href=\"#不同的节点类型\" class=\"headerlink\" title=\"不同的节点类型\"></a>不同的节点类型</h3><p>节点类型不同，React 将会把它们当做两个不同的子树，移除之前的那棵子树，然后创建并插入第二棵子树。React不会尝试计算出该渲染什么，仅会从 DOM中移除之前的节点，然后插入新的节点。碰到不一样的组件结构，React将重新创建树形结构，而不是耗费时间去尝试匹配这两个树形结构。所以，React的虚拟DOM是非常高效的。</p>\n<h3 id=\"DOM节点\"><a href=\"#DOM节点\" class=\"headerlink\" title=\"DOM节点\"></a>DOM节点</h3><p>DOM节点是相同类型的，比较两个DOM节点的时候，首先查看属性。对随着时间发生了变化的属性进行更新，然后递归检查所有子级的属性。</p>\n<h3 id=\"自定义组件\"><a href=\"#自定义组件\" class=\"headerlink\" title=\"自定义组件\"></a>自定义组件</h3><p>我们决定两个自定义组件是相同的。因为组件是状态化的，不可能每次状态改变都要创建一个新的组件实例。React 利用新组件上的所有属性，然后在之前的组件实例上调用 component[Will/Did]ReceiveProps()。现在，之前的组件就是可操作了的。它的 render() 方法被调用，然后差异算法重新比较新的状态和上一次的状态。</p>\n<h2 id=\"子级优化差异\"><a href=\"#子级优化差异\" class=\"headerlink\" title=\"子级优化差异\"></a>子级优化差异</h2><p>React采用的方法是同时遍历两个子级列表，当发现差异的时候，就产生一次 DOM 修改。例如我们如果需要在组件末尾添加一个元素，那么如果两个子级（原有的和新添加的）是相同元素，则直接修改已有子级元素的文本内容，然后在后面插入一个新的子级节点。<br>另外，React引入一个唯一的key属性，给每一个子级一个键值，用于和以后变化的组件进行比较。这样，React就能够检测出节点插入、移除和替换，并且借助哈希表使节点移动复杂度为 O(n)。<br><img src=\"http://huguozhi-media.stor.sinaapp.com/mygitio%2F2.png\" alt=\"示例1\"></p>\n<h1 id=\"本篇结语\"><a href=\"#本篇结语\" class=\"headerlink\" title=\"本篇结语\"></a>本篇结语</h1><p>这一篇主要是介绍React的渲染机制，虚拟dom是React.js的核心。想要更多地了解React.js的朋友可以进入<a href=\"http://reactjs.cn/\">官方文档</a>进行深入学习。</p>"},{"title":"React.js那些事(介绍篇)","date":"2015-09-11T05:28:05.000Z","_content":"\n# 引言\nWEB前端开发的发展历史大概经过了“原始时代——类库时代——工程构建时代——模块化时代”。目前前端领域的发展正处在一个空前繁荣的阶段——“模块化/组件化时代”。\n\n## 原始时代\n曾几何时，前端开发在软件工程的技术栈里面只被视为设计类岗位，甚至现在为止也有一些小企业依然把前端的职责视为简单的编写html+css页面。早期的前端开发完全依赖于后端技术，所有的数据渲染都由后端开发者进行，界面源码和后台逻辑代码混在一起。这个时代的前端无疑是非常薄的，薄到“网页开发人员”的入门门槛几乎低至为零。\n<!--more-->\n## 类库时代\n这一阶段出现了对js封装的各种类库，代表作当然就是前端领域从业者无所不知的jquery库啦。类库时代的开发者承担了很大一部分数据交互的工作。借鉴于AJAX，开发过程可以实现很好的前后端分离，MVC开发框架日益盛行。这个时代，前端开发者在一定程度上摆脱了对后端的严重依赖，使得前后端开发依赖于接口，大大加快了开发效率。\n\n## 工程构建时代\n基于各种自动化构建工具部署前端代码是这一时代的基本特征，前端发展到今天，自动化构建依然是当前的技术主流，Grunt,gulp.js以及国内的Fis等都是自动化代码优化和部署的热门工具。\n\n## 模块化时代\n模块化时代标志着前端开发正式进入工程化阶段，“前端工程师”正式成为名副其实的“工程师”。我之所以这样认为是因为这一阶段前端开发可以完全实现代码的重用，实现模块化开发，系统化、规范化的软件开发就是“软件工程”。所以前端工程师也就是在这一阶段日渐活跃，需求量也迅猛增长。前端模块时代的技术代表就是Require.js以及国内的sea.js这样的模块加载器。在MVC开发模式的基础上实现了对视图层的模块化开发，MVC框架至此达到一个鼎盛阶段。\n然而前端之所以迷人在于新的开发模式和技术不会停止出现，不同的应用需求催生了新的开发技术的诞生。最近几年，组件化开发正成为前端领域的潮流，组件开发减少了代码的耦合，非常适合大型网站应用的开发（这类大型网站的特点就是大量的模块类似或者重复）。可实现代码高度重用的MVVM框架开发进入开发者眼中——这就是React.js的诞生背景\n\n# React.js\n## React是什么东西？\n来自官网的介绍：\n* 仅仅是UI\n许多人使用React作为MVC架构的V层。尽管React并没有假设过你的其余技术栈，但它仍可以作为一个小特征轻易地在已有项目中使用。\n* 虚拟DOM\nReact为了更高超的性能而使用虚拟DOM作为其不同的实现。它同时也可以由服务端Node.js渲染而不需要过重的浏览器DOM支持。\n* 数据流\nReact实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。\n\n也就是说，React是一个视图层的应用，并且是一个高效的视图。React提供了和以往不一样的方式来看待视图，它以组件开发为基础。对React应用而言，你需要分割你的页面，使其成为一个个的组件。也就是说，你的应用是由这些组件组合而成的。组件本身可以实现数据流的的单向流动，实现独立开发。这就是我们所说的“组件驱动开发”。\n\n## 虚拟DOM\nReact的一大特点是其所拥有的虚拟DOM，它让页面渲染变得非常的高效，并且比直接操纵DOM变得更为可控。由于虚拟DOM的绘制是在内存里面进行的，高效是它的特征。这两大特点的组合使得React具有强大的自上而下的页面渲染能力。\n\nReact提供了一个观察者模型用于替代传统的脏检查（dirty checking）， 也就是持续的检查模型的变化。这也就是解释了为什么React不需要计算哪些发生了改变的原因，因为它根据state的变化会立即知道。这个过程减少了DOM操作，并让应用程序变得更平滑。我们知道DOM操作是非常耗性能的，更少的DOM操作意味着更高效的渲染。React在底层实现了一个diffing算法，该算法使用DOM的树形表示法，当某个 节点发生变化（标记为dirty）时它会重新计算整个子树，你会注意到你的模型发生了改变，因为整个子树在之后会被重新渲染。\n\n## JSX\nJSX是什么鬼？？？JSX是一个看起来很像XML的JavaScript语法扩展。React可以用来做简单的JSX句法转换。React提供了（也是建议使用）JSX代替JS进行组件绘制，然后运行的时候使用一个JSX编译器进行转换。JSX的使用还是比较简单的：\n要渲染 HTML 标签，只需在 JSX 里使用小写字母开头的标签名。\n```jsx\n    var myDivElement = <div className=\"foo\" />;\n    React.render(myDivElement, document.body);\n```\n要渲染 React 组件，只需创建一个大写字母开头的本地变量。\n```jsx\n    var MyComponent = React.createClass({/*一些代码*/});\n    var myElement = <MyComponent someProperty={true} />;\n    React.render(myElement, document.body);\n```\n\n# 本节结语\n关于React.js的入门介绍暂时到这里，想要更多地了解React.js的朋友可以进入[官方文档](http://reactjs.cn/)进行学习。\n\n\n\n\n\n","source":"_posts/React-js那些事-介绍篇.md","raw":"title: React.js那些事(介绍篇)\ndate: 2015-09-11 13:28:05\ntags:\n    - React\n    - virtual dom\ncategories:\n    - 前端开发\n---\n\n# 引言\nWEB前端开发的发展历史大概经过了“原始时代——类库时代——工程构建时代——模块化时代”。目前前端领域的发展正处在一个空前繁荣的阶段——“模块化/组件化时代”。\n\n## 原始时代\n曾几何时，前端开发在软件工程的技术栈里面只被视为设计类岗位，甚至现在为止也有一些小企业依然把前端的职责视为简单的编写html+css页面。早期的前端开发完全依赖于后端技术，所有的数据渲染都由后端开发者进行，界面源码和后台逻辑代码混在一起。这个时代的前端无疑是非常薄的，薄到“网页开发人员”的入门门槛几乎低至为零。\n<!--more-->\n## 类库时代\n这一阶段出现了对js封装的各种类库，代表作当然就是前端领域从业者无所不知的jquery库啦。类库时代的开发者承担了很大一部分数据交互的工作。借鉴于AJAX，开发过程可以实现很好的前后端分离，MVC开发框架日益盛行。这个时代，前端开发者在一定程度上摆脱了对后端的严重依赖，使得前后端开发依赖于接口，大大加快了开发效率。\n\n## 工程构建时代\n基于各种自动化构建工具部署前端代码是这一时代的基本特征，前端发展到今天，自动化构建依然是当前的技术主流，Grunt,gulp.js以及国内的Fis等都是自动化代码优化和部署的热门工具。\n\n## 模块化时代\n模块化时代标志着前端开发正式进入工程化阶段，“前端工程师”正式成为名副其实的“工程师”。我之所以这样认为是因为这一阶段前端开发可以完全实现代码的重用，实现模块化开发，系统化、规范化的软件开发就是“软件工程”。所以前端工程师也就是在这一阶段日渐活跃，需求量也迅猛增长。前端模块时代的技术代表就是Require.js以及国内的sea.js这样的模块加载器。在MVC开发模式的基础上实现了对视图层的模块化开发，MVC框架至此达到一个鼎盛阶段。\n然而前端之所以迷人在于新的开发模式和技术不会停止出现，不同的应用需求催生了新的开发技术的诞生。最近几年，组件化开发正成为前端领域的潮流，组件开发减少了代码的耦合，非常适合大型网站应用的开发（这类大型网站的特点就是大量的模块类似或者重复）。可实现代码高度重用的MVVM框架开发进入开发者眼中——这就是React.js的诞生背景\n\n# React.js\n## React是什么东西？\n来自官网的介绍：\n* 仅仅是UI\n许多人使用React作为MVC架构的V层。尽管React并没有假设过你的其余技术栈，但它仍可以作为一个小特征轻易地在已有项目中使用。\n* 虚拟DOM\nReact为了更高超的性能而使用虚拟DOM作为其不同的实现。它同时也可以由服务端Node.js渲染而不需要过重的浏览器DOM支持。\n* 数据流\nReact实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。\n\n也就是说，React是一个视图层的应用，并且是一个高效的视图。React提供了和以往不一样的方式来看待视图，它以组件开发为基础。对React应用而言，你需要分割你的页面，使其成为一个个的组件。也就是说，你的应用是由这些组件组合而成的。组件本身可以实现数据流的的单向流动，实现独立开发。这就是我们所说的“组件驱动开发”。\n\n## 虚拟DOM\nReact的一大特点是其所拥有的虚拟DOM，它让页面渲染变得非常的高效，并且比直接操纵DOM变得更为可控。由于虚拟DOM的绘制是在内存里面进行的，高效是它的特征。这两大特点的组合使得React具有强大的自上而下的页面渲染能力。\n\nReact提供了一个观察者模型用于替代传统的脏检查（dirty checking）， 也就是持续的检查模型的变化。这也就是解释了为什么React不需要计算哪些发生了改变的原因，因为它根据state的变化会立即知道。这个过程减少了DOM操作，并让应用程序变得更平滑。我们知道DOM操作是非常耗性能的，更少的DOM操作意味着更高效的渲染。React在底层实现了一个diffing算法，该算法使用DOM的树形表示法，当某个 节点发生变化（标记为dirty）时它会重新计算整个子树，你会注意到你的模型发生了改变，因为整个子树在之后会被重新渲染。\n\n## JSX\nJSX是什么鬼？？？JSX是一个看起来很像XML的JavaScript语法扩展。React可以用来做简单的JSX句法转换。React提供了（也是建议使用）JSX代替JS进行组件绘制，然后运行的时候使用一个JSX编译器进行转换。JSX的使用还是比较简单的：\n要渲染 HTML 标签，只需在 JSX 里使用小写字母开头的标签名。\n```jsx\n    var myDivElement = <div className=\"foo\" />;\n    React.render(myDivElement, document.body);\n```\n要渲染 React 组件，只需创建一个大写字母开头的本地变量。\n```jsx\n    var MyComponent = React.createClass({/*一些代码*/});\n    var myElement = <MyComponent someProperty={true} />;\n    React.render(myElement, document.body);\n```\n\n# 本节结语\n关于React.js的入门介绍暂时到这里，想要更多地了解React.js的朋友可以进入[官方文档](http://reactjs.cn/)进行学习。\n\n\n\n\n\n","slug":"React-js那些事-介绍篇","published":1,"updated":"2016-08-13T03:08:44.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtqr000j7kaufpjo136o","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>WEB前端开发的发展历史大概经过了“原始时代——类库时代——工程构建时代——模块化时代”。目前前端领域的发展正处在一个空前繁荣的阶段——“模块化/组件化时代”。</p>\n<h2 id=\"原始时代\"><a href=\"#原始时代\" class=\"headerlink\" title=\"原始时代\"></a>原始时代</h2><p>曾几何时，前端开发在软件工程的技术栈里面只被视为设计类岗位，甚至现在为止也有一些小企业依然把前端的职责视为简单的编写html+css页面。早期的前端开发完全依赖于后端技术，所有的数据渲染都由后端开发者进行，界面源码和后台逻辑代码混在一起。这个时代的前端无疑是非常薄的，薄到“网页开发人员”的入门门槛几乎低至为零。<br><a id=\"more\"></a></p>\n<h2 id=\"类库时代\"><a href=\"#类库时代\" class=\"headerlink\" title=\"类库时代\"></a>类库时代</h2><p>这一阶段出现了对js封装的各种类库，代表作当然就是前端领域从业者无所不知的jquery库啦。类库时代的开发者承担了很大一部分数据交互的工作。借鉴于AJAX，开发过程可以实现很好的前后端分离，MVC开发框架日益盛行。这个时代，前端开发者在一定程度上摆脱了对后端的严重依赖，使得前后端开发依赖于接口，大大加快了开发效率。</p>\n<h2 id=\"工程构建时代\"><a href=\"#工程构建时代\" class=\"headerlink\" title=\"工程构建时代\"></a>工程构建时代</h2><p>基于各种自动化构建工具部署前端代码是这一时代的基本特征，前端发展到今天，自动化构建依然是当前的技术主流，Grunt,gulp.js以及国内的Fis等都是自动化代码优化和部署的热门工具。</p>\n<h2 id=\"模块化时代\"><a href=\"#模块化时代\" class=\"headerlink\" title=\"模块化时代\"></a>模块化时代</h2><p>模块化时代标志着前端开发正式进入工程化阶段，“前端工程师”正式成为名副其实的“工程师”。我之所以这样认为是因为这一阶段前端开发可以完全实现代码的重用，实现模块化开发，系统化、规范化的软件开发就是“软件工程”。所以前端工程师也就是在这一阶段日渐活跃，需求量也迅猛增长。前端模块时代的技术代表就是Require.js以及国内的sea.js这样的模块加载器。在MVC开发模式的基础上实现了对视图层的模块化开发，MVC框架至此达到一个鼎盛阶段。<br>然而前端之所以迷人在于新的开发模式和技术不会停止出现，不同的应用需求催生了新的开发技术的诞生。最近几年，组件化开发正成为前端领域的潮流，组件开发减少了代码的耦合，非常适合大型网站应用的开发（这类大型网站的特点就是大量的模块类似或者重复）。可实现代码高度重用的MVVM框架开发进入开发者眼中——这就是React.js的诞生背景</p>\n<h1 id=\"React-js\"><a href=\"#React-js\" class=\"headerlink\" title=\"React.js\"></a>React.js</h1><h2 id=\"React是什么东西？\"><a href=\"#React是什么东西？\" class=\"headerlink\" title=\"React是什么东西？\"></a>React是什么东西？</h2><p>来自官网的介绍：</p>\n<ul>\n<li>仅仅是UI<br>许多人使用React作为MVC架构的V层。尽管React并没有假设过你的其余技术栈，但它仍可以作为一个小特征轻易地在已有项目中使用。</li>\n<li>虚拟DOM<br>React为了更高超的性能而使用虚拟DOM作为其不同的实现。它同时也可以由服务端Node.js渲染而不需要过重的浏览器DOM支持。</li>\n<li>数据流<br>React实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。</li>\n</ul>\n<p>也就是说，React是一个视图层的应用，并且是一个高效的视图。React提供了和以往不一样的方式来看待视图，它以组件开发为基础。对React应用而言，你需要分割你的页面，使其成为一个个的组件。也就是说，你的应用是由这些组件组合而成的。组件本身可以实现数据流的的单向流动，实现独立开发。这就是我们所说的“组件驱动开发”。</p>\n<h2 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h2><p>React的一大特点是其所拥有的虚拟DOM，它让页面渲染变得非常的高效，并且比直接操纵DOM变得更为可控。由于虚拟DOM的绘制是在内存里面进行的，高效是它的特征。这两大特点的组合使得React具有强大的自上而下的页面渲染能力。</p>\n<p>React提供了一个观察者模型用于替代传统的脏检查（dirty checking）， 也就是持续的检查模型的变化。这也就是解释了为什么React不需要计算哪些发生了改变的原因，因为它根据state的变化会立即知道。这个过程减少了DOM操作，并让应用程序变得更平滑。我们知道DOM操作是非常耗性能的，更少的DOM操作意味着更高效的渲染。React在底层实现了一个diffing算法，该算法使用DOM的树形表示法，当某个 节点发生变化（标记为dirty）时它会重新计算整个子树，你会注意到你的模型发生了改变，因为整个子树在之后会被重新渲染。</p>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><p>JSX是什么鬼？？？JSX是一个看起来很像XML的JavaScript语法扩展。React可以用来做简单的JSX句法转换。React提供了（也是建议使用）JSX代替JS进行组件绘制，然后运行的时候使用一个JSX编译器进行转换。JSX的使用还是比较简单的：<br>要渲染 HTML 标签，只需在 JSX 里使用小写字母开头的标签名。<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myDivElement = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"foo\"</span> /&gt;</span>;</span></div><div class=\"line\">React.render(myDivElement, document.body);</div></pre></td></tr></table></figure></p>\n<p>要渲染 React 组件，只需创建一个大写字母开头的本地变量。<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> MyComponent = React.createClass(&#123;<span class=\"comment\">/*一些代码*/</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> myElement = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">MyComponent</span> <span class=\"attr\">someProperty</span>=<span class=\"string\">&#123;true&#125;</span> /&gt;</span>;</span></div><div class=\"line\">React.render(myElement, document.body);</div></pre></td></tr></table></figure></p>\n<h1 id=\"本节结语\"><a href=\"#本节结语\" class=\"headerlink\" title=\"本节结语\"></a>本节结语</h1><p>关于React.js的入门介绍暂时到这里，想要更多地了解React.js的朋友可以进入<a href=\"http://reactjs.cn/\" target=\"_blank\" rel=\"external\">官方文档</a>进行学习。</p>\n","excerpt":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>WEB前端开发的发展历史大概经过了“原始时代——类库时代——工程构建时代——模块化时代”。目前前端领域的发展正处在一个空前繁荣的阶段——“模块化/组件化时代”。</p>\n<h2 id=\"原始时代\"><a href=\"#原始时代\" class=\"headerlink\" title=\"原始时代\"></a>原始时代</h2><p>曾几何时，前端开发在软件工程的技术栈里面只被视为设计类岗位，甚至现在为止也有一些小企业依然把前端的职责视为简单的编写html+css页面。早期的前端开发完全依赖于后端技术，所有的数据渲染都由后端开发者进行，界面源码和后台逻辑代码混在一起。这个时代的前端无疑是非常薄的，薄到“网页开发人员”的入门门槛几乎低至为零。<br>","more":"</p>\n<h2 id=\"类库时代\"><a href=\"#类库时代\" class=\"headerlink\" title=\"类库时代\"></a>类库时代</h2><p>这一阶段出现了对js封装的各种类库，代表作当然就是前端领域从业者无所不知的jquery库啦。类库时代的开发者承担了很大一部分数据交互的工作。借鉴于AJAX，开发过程可以实现很好的前后端分离，MVC开发框架日益盛行。这个时代，前端开发者在一定程度上摆脱了对后端的严重依赖，使得前后端开发依赖于接口，大大加快了开发效率。</p>\n<h2 id=\"工程构建时代\"><a href=\"#工程构建时代\" class=\"headerlink\" title=\"工程构建时代\"></a>工程构建时代</h2><p>基于各种自动化构建工具部署前端代码是这一时代的基本特征，前端发展到今天，自动化构建依然是当前的技术主流，Grunt,gulp.js以及国内的Fis等都是自动化代码优化和部署的热门工具。</p>\n<h2 id=\"模块化时代\"><a href=\"#模块化时代\" class=\"headerlink\" title=\"模块化时代\"></a>模块化时代</h2><p>模块化时代标志着前端开发正式进入工程化阶段，“前端工程师”正式成为名副其实的“工程师”。我之所以这样认为是因为这一阶段前端开发可以完全实现代码的重用，实现模块化开发，系统化、规范化的软件开发就是“软件工程”。所以前端工程师也就是在这一阶段日渐活跃，需求量也迅猛增长。前端模块时代的技术代表就是Require.js以及国内的sea.js这样的模块加载器。在MVC开发模式的基础上实现了对视图层的模块化开发，MVC框架至此达到一个鼎盛阶段。<br>然而前端之所以迷人在于新的开发模式和技术不会停止出现，不同的应用需求催生了新的开发技术的诞生。最近几年，组件化开发正成为前端领域的潮流，组件开发减少了代码的耦合，非常适合大型网站应用的开发（这类大型网站的特点就是大量的模块类似或者重复）。可实现代码高度重用的MVVM框架开发进入开发者眼中——这就是React.js的诞生背景</p>\n<h1 id=\"React-js\"><a href=\"#React-js\" class=\"headerlink\" title=\"React.js\"></a>React.js</h1><h2 id=\"React是什么东西？\"><a href=\"#React是什么东西？\" class=\"headerlink\" title=\"React是什么东西？\"></a>React是什么东西？</h2><p>来自官网的介绍：</p>\n<ul>\n<li>仅仅是UI<br>许多人使用React作为MVC架构的V层。尽管React并没有假设过你的其余技术栈，但它仍可以作为一个小特征轻易地在已有项目中使用。</li>\n<li>虚拟DOM<br>React为了更高超的性能而使用虚拟DOM作为其不同的实现。它同时也可以由服务端Node.js渲染而不需要过重的浏览器DOM支持。</li>\n<li>数据流<br>React实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。</li>\n</ul>\n<p>也就是说，React是一个视图层的应用，并且是一个高效的视图。React提供了和以往不一样的方式来看待视图，它以组件开发为基础。对React应用而言，你需要分割你的页面，使其成为一个个的组件。也就是说，你的应用是由这些组件组合而成的。组件本身可以实现数据流的的单向流动，实现独立开发。这就是我们所说的“组件驱动开发”。</p>\n<h2 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h2><p>React的一大特点是其所拥有的虚拟DOM，它让页面渲染变得非常的高效，并且比直接操纵DOM变得更为可控。由于虚拟DOM的绘制是在内存里面进行的，高效是它的特征。这两大特点的组合使得React具有强大的自上而下的页面渲染能力。</p>\n<p>React提供了一个观察者模型用于替代传统的脏检查（dirty checking）， 也就是持续的检查模型的变化。这也就是解释了为什么React不需要计算哪些发生了改变的原因，因为它根据state的变化会立即知道。这个过程减少了DOM操作，并让应用程序变得更平滑。我们知道DOM操作是非常耗性能的，更少的DOM操作意味着更高效的渲染。React在底层实现了一个diffing算法，该算法使用DOM的树形表示法，当某个 节点发生变化（标记为dirty）时它会重新计算整个子树，你会注意到你的模型发生了改变，因为整个子树在之后会被重新渲染。</p>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><p>JSX是什么鬼？？？JSX是一个看起来很像XML的JavaScript语法扩展。React可以用来做简单的JSX句法转换。React提供了（也是建议使用）JSX代替JS进行组件绘制，然后运行的时候使用一个JSX编译器进行转换。JSX的使用还是比较简单的：<br>要渲染 HTML 标签，只需在 JSX 里使用小写字母开头的标签名。<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myDivElement = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"foo\"</span> /&gt;</span>;</div><div class=\"line\">React.render(myDivElement, document.body);</span></div></pre></td></tr></table></figure></p>\n<p>要渲染 React 组件，只需创建一个大写字母开头的本地变量。<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> MyComponent = React.createClass(&#123;<span class=\"comment\">/*一些代码*/</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> myElement = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">MyComponent</span> <span class=\"attr\">someProperty</span>=<span class=\"string\">&#123;true&#125;</span> /&gt;</span>;</div><div class=\"line\">React.render(myElement, document.body);</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"本节结语\"><a href=\"#本节结语\" class=\"headerlink\" title=\"本节结语\"></a>本节结语</h1><p>关于React.js的入门介绍暂时到这里，想要更多地了解React.js的朋友可以进入<a href=\"http://reactjs.cn/\">官方文档</a>进行学习。</p>"},{"title":"React.js那些事(入门篇)","date":"2015-09-14T10:59:50.000Z","_content":"\n关于React.js的相关背景知识以及它的核心概念已经在[上一篇文章](http://hugzh.github.io/2015/09/11/React-js%E9%82%A3%E4%BA%9B%E4%BA%8B-%E4%BB%8B%E7%BB%8D%E7%AF%87/)里面说过。在这一篇里面，我通过一个组件开发的实例简单介绍如何使用React进行web组件开发。\n\n先来介绍一下这个打算实现的组件的功能：这是一个简单的三列表格，包含用户id，用户名，电话号码三列。当用户点击表头thead的单元时，表格会根据点中的列的字段进行升序排序。\n<!--more-->\n三军未动，先上demo：\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/hugzh/6jzz77de/3/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n## 第一步：划分组件\n首先，我们需要将整个组件划分为几个子组件，这是组件开发的重要思想——拆分组合。这是实现组件重用的关键技术。根据案例的原型，我将组件划分如下：\n![table partion](http://huguozhi-media.stor.sinaapp.com/mygitio%2Ftable.JPG)\n最外层的组件是我需要的目标组件 ——TableComponent，由绿色部分和黄色部分组成;\n绿色部分为组件Thead，由三个相同的组件TheadCell构成(红色);\n黄色部分为组件Tbody,每一行是一个组件Cell(蓝色)；\n红色部分—— TheadCell;\n蓝色部分—— Cell;\n\n\n## 第二步：组件绘制\n组件绘制非常简单，首先需要引入react.js文件以及TSX转换器文件JSXTransformer.js。然后，创建一个组件只需要调用一个函数React.createClass()即可，可以从外层到里层构件或者从里层到外层构件。比如，我先构造组件TheadCell:\n\n```\nvar  TheadCell = React.createClass({\n    render: function (){\n        return (\n            <th ref=\"getSortKey\" title=\"点击此键进行排序\">{this.props.content}</th>\n        );\n    }\n}) \n```\n这样就可以构造出一个Thead组件了，它的UI表现就是一个表头的 th 元素。一个组件的数据内容由该组件的父级传递过来，父级传递给子级的数据是通过 props 对象来传递的。然后子级组件通过this.props来读取数据对象的内容。父级组件传递数据对象给子级组件的方法也很简单，只要在组件传入一个属性值即可。在这里，TheadCell的父级组件为Thead，创建它并传递数据给TheadCell：\n```\nvar  Thead = React.createClass({\n    render: function (){\n        return (\n            <thead>\n                <caption>点击表格头部进行排序</caption>\n                <tr>\n                    <TheadCell content={this.props.uid} />\n                    <TheadCell content={this.props.name} />\n                    <TheadCell content={this.props.tel} />\n                </tr>\n            </thead>\n        );\n    }\n});\n```\n这样，Thead包含了三个子组件TheadCell，然后类似XML的标签语法定义组件的“属性”——content。在这里，content的值来自Thead的父级组件TableComponent。\n同样的道理，创建剩下的所有静态组件：\n\n创建Cell：\n```\nvar Cell  = React.createClass({\n    render: function(){\n        return (\n            <tr>\n                <td>{this.props.userItem.uid}</td>\n                <td>{this.props.userItem.name}</td>\n                <td>{this.props.userItem.tel}</td>\n            </tr>\n        );\n    }\n});\n```\n创建Tbody:\n```\nvar Tbody = React.createClass({\n    render: function (){\n        var row = [],\n            userlist = this.props.items;\n        for(var item in userlist){\n            row.push(<Cell userItem={this.props.items[item]} key={item}/>);\n        }\n\n        return(\n            <tbody>\n                {row}\n            </tbody>\n        );\n    }\n});\n```\n创建TableComponent:\n```\nvar TableComponent = React.createClass({\n    render: function (){\n        return (\n            <table>\n                <Thead  uid=\"uid\" name=\"name\" tel=\"tel\"/>\n                <Tbody items={this.props.data}/>\n            </table>\n        );\n    }\n});\n```\n在这个地方，为了方便，我省略了从服务器加载数据的步骤，直接声明一个静态数据：\n```\nvar USERS = [\n    {\"uid\":4,\"name\":\"zhut\",\"tel\":\"13899994567\"},\n    {\"uid\":2,\"name\":\"xiaom\",\"tel\":\"13580889999\"},\n    {\"uid\":3,\"name\":\"Brand\",\"tel\":\"15918446402\"},\n    {\"uid\":1,\"name\":\"defan\",\"tel\":\"18913145678\"}\n ];\n```\n最后，把组件渲染到html页面上。静态组件也就绘制完成了：\n```\nReact.render(<TableComponent data={USERS} />,document.getElementById(\"content\"));\n```\n\n## 第三步：识别UI的state\nstate是组件私有的，可以通过调用 this.setState() 来改变它。当状态更新之后，组件重新渲染自己。也就是说每当state改变之后，React的虚拟DOM机制就会感知到变化然后重新绘制UI。由于虚拟DOM操作是在内存里面，这就使得UI的重新绘制非常地高效快捷。这是React的精髓所在。\n好了，寻找state的三步法：\n* 是否是从父级通过 props 传入的？如果是，可能不是 state 。\n* 是否会随着时间改变？如果不是，可能不是 state 。\n* 能根据组件中其它 state 数据或者 props 计算出来吗？如果是，就不是 state 。\n\n在这里，我们的组件是随着TheadCell被点击，整个组件重新排序。所以Thead组件的变化必须影响到Tbody的状态。所以我们把state设置在Thead和Tbody的父级组件TableComponent上。\n```\nvar TableComponent = React.createClass({\n    getInitialState: function (){\n        return {\n            sortBy:''\n        };\n    },\n    render: function (){\n        return (\n            <table>\n                <Thead uid=\"uid\" name=\"name\" tel=\"tel\"/>\n                <Tbody items={this.props.data} sortBy={this.state.sortBy}/>\n            </table>\n        );\n    }\n});\n```\ngetInitialState 初始化组件的state，然后传递给子级Tbody。\n\n## 第四步：添加反向数据流\nstate的动态变化才会导致组件重新绘制，所以发生在组件点击事件必须要能改变组件的state，组件树中层级很深的表单组件TheadCell需要更新 TableComponent 中的 state 。\n```\nvar TableComponent = React.createClass({\n    getInitialState: function (){\n        return {\n            sortBy:''\n        };\n    },\n    handleClick: function(value){\n        this.setState({\n            sortBy:value\n        });\n    },\n    render: function (){\n        return (\n            <table>\n                <Thead  sort={this.handleClick} uid=\"uid\" name=\"name\" tel=\"tel\"/>\n                <Tbody items={this.props.data} sortBy={this.state.sortBy}/>\n            </table>\n        );\n    }\n});\n```\n这里，传递给子级组件Thead一个回调函数handleClick，回调函数触发时调用this.setState()来改变组件的state。由于点击事件是绑定在Thead的子级TheadCell上的，所以我这里的处理方法就是让Thead把回调函数handleClick再传递给下一子级TheadCell。Thead是这样子处理的：\n```\nvar  Thead = React.createClass({\n    returnSort: function(v){\n        this.props.sort(v);\n    },\n    render: function (){\n        return (\n            <thead>\n                <caption>点击表格头部进行排序</caption>\n                <tr>\n                    <TheadCell bubbleClick={this.returnSort} content={this.props.uid} />\n                    <TheadCell bubbleClick={this.returnSort} content={this.props.name} />\n                    <TheadCell bubbleClick={this.returnSort} content={this.props.tel} />\n                </tr>\n            </thead>\n        );\n    }\n});\n```\n把TheadCell的回调作为回调sort的一个过渡。\n\n最后，需要知道鼠标点击的是哪一个表头字段（uid,name还是tel）。React提供的获取标签值得方法是refs，所以 th 标签需要知道一个ref属性，我把它的值叫做getSortKey，也就是用来排序的字段。通过getDOMNode获取到UI的具体节点。在这里需要说明的一点就是，React里面给标签对象注册事件必须使用基于元素的DOM0级事件注册，而且是用驼峰格式。比如注册点击事件onClick。\n```\nvar  TheadCell = React.createClass({\n    handler: function(){\n        this.props.bubbleClick(this.refs.getSortKey.getDOMNode().innerHTML);\n    },\n    render: function (){\n        return (\n            <th ref=\"getSortKey\" title=\"点击此键进行排序\" onClick={this.handler}>{this.props.content}</th>\n        );\n    }\n}) \n```\n\n接下来就是双向数据流绑定的重要一步，也就是组件state改变之后UI如何实时响应并重新渲染绘制。这一步是发生在Tbody组件上面的，关键的地方在于表格tbody的绘制必须要由state计算而来，这样state的改变才会导致UI的重新绘制：\n```\nvar Tbody = React.createClass({\n    render: function (){\n        var row = [],\n            userlist = this.props.items,\n                cmpKey = \"\",\n                    sortBy = this.props.sortBy;\n        // 获取需要拿来比较的字段\n        for (it in userlist[0]){\n            if(sortBy == it){\n                cmpKey = it;\n            }\n        }\n\n        // 如果有排序键，进行排序\n        if (cmpKey){\n            userlist.sort(function (a,b){\n                if(a[cmpKey] < b[cmpKey]){\n                    return -1;\n                }\n                if(a[cmpKey] > b[cmpKey]){\n                    return 1;\n                }\n                return 0;\n            });\n        }\n        \n        // 排序后的table\n        for(var item in userlist){\n            row.push(<Cell userItem={this.props.items[item]} key={item}/>);\n        }\n\n        return(\n            <tbody>\n                {row}\n            </tbody>\n        );\n    }\n});\n```\n\n# 本篇结语\n这一篇主要是介绍怎么样去使用React制作组件，这是入门级别的说明。想要更多地了解React.js的朋友可以进入[官方文档](http://reactjs.cn/)进行深入学习。\n\n","source":"_posts/React-js那些事-入门篇.md","raw":"title: React.js那些事(入门篇)\ndate: 2015-09-14 18:59:50\ntags:\n    - React\n    - 组件化开发\ncategories:\n    - 前端开发\n---\n\n关于React.js的相关背景知识以及它的核心概念已经在[上一篇文章](http://hugzh.github.io/2015/09/11/React-js%E9%82%A3%E4%BA%9B%E4%BA%8B-%E4%BB%8B%E7%BB%8D%E7%AF%87/)里面说过。在这一篇里面，我通过一个组件开发的实例简单介绍如何使用React进行web组件开发。\n\n先来介绍一下这个打算实现的组件的功能：这是一个简单的三列表格，包含用户id，用户名，电话号码三列。当用户点击表头thead的单元时，表格会根据点中的列的字段进行升序排序。\n<!--more-->\n三军未动，先上demo：\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/hugzh/6jzz77de/3/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n## 第一步：划分组件\n首先，我们需要将整个组件划分为几个子组件，这是组件开发的重要思想——拆分组合。这是实现组件重用的关键技术。根据案例的原型，我将组件划分如下：\n![table partion](http://huguozhi-media.stor.sinaapp.com/mygitio%2Ftable.JPG)\n最外层的组件是我需要的目标组件 ——TableComponent，由绿色部分和黄色部分组成;\n绿色部分为组件Thead，由三个相同的组件TheadCell构成(红色);\n黄色部分为组件Tbody,每一行是一个组件Cell(蓝色)；\n红色部分—— TheadCell;\n蓝色部分—— Cell;\n\n\n## 第二步：组件绘制\n组件绘制非常简单，首先需要引入react.js文件以及TSX转换器文件JSXTransformer.js。然后，创建一个组件只需要调用一个函数React.createClass()即可，可以从外层到里层构件或者从里层到外层构件。比如，我先构造组件TheadCell:\n\n```\nvar  TheadCell = React.createClass({\n    render: function (){\n        return (\n            <th ref=\"getSortKey\" title=\"点击此键进行排序\">{this.props.content}</th>\n        );\n    }\n}) \n```\n这样就可以构造出一个Thead组件了，它的UI表现就是一个表头的 th 元素。一个组件的数据内容由该组件的父级传递过来，父级传递给子级的数据是通过 props 对象来传递的。然后子级组件通过this.props来读取数据对象的内容。父级组件传递数据对象给子级组件的方法也很简单，只要在组件传入一个属性值即可。在这里，TheadCell的父级组件为Thead，创建它并传递数据给TheadCell：\n```\nvar  Thead = React.createClass({\n    render: function (){\n        return (\n            <thead>\n                <caption>点击表格头部进行排序</caption>\n                <tr>\n                    <TheadCell content={this.props.uid} />\n                    <TheadCell content={this.props.name} />\n                    <TheadCell content={this.props.tel} />\n                </tr>\n            </thead>\n        );\n    }\n});\n```\n这样，Thead包含了三个子组件TheadCell，然后类似XML的标签语法定义组件的“属性”——content。在这里，content的值来自Thead的父级组件TableComponent。\n同样的道理，创建剩下的所有静态组件：\n\n创建Cell：\n```\nvar Cell  = React.createClass({\n    render: function(){\n        return (\n            <tr>\n                <td>{this.props.userItem.uid}</td>\n                <td>{this.props.userItem.name}</td>\n                <td>{this.props.userItem.tel}</td>\n            </tr>\n        );\n    }\n});\n```\n创建Tbody:\n```\nvar Tbody = React.createClass({\n    render: function (){\n        var row = [],\n            userlist = this.props.items;\n        for(var item in userlist){\n            row.push(<Cell userItem={this.props.items[item]} key={item}/>);\n        }\n\n        return(\n            <tbody>\n                {row}\n            </tbody>\n        );\n    }\n});\n```\n创建TableComponent:\n```\nvar TableComponent = React.createClass({\n    render: function (){\n        return (\n            <table>\n                <Thead  uid=\"uid\" name=\"name\" tel=\"tel\"/>\n                <Tbody items={this.props.data}/>\n            </table>\n        );\n    }\n});\n```\n在这个地方，为了方便，我省略了从服务器加载数据的步骤，直接声明一个静态数据：\n```\nvar USERS = [\n    {\"uid\":4,\"name\":\"zhut\",\"tel\":\"13899994567\"},\n    {\"uid\":2,\"name\":\"xiaom\",\"tel\":\"13580889999\"},\n    {\"uid\":3,\"name\":\"Brand\",\"tel\":\"15918446402\"},\n    {\"uid\":1,\"name\":\"defan\",\"tel\":\"18913145678\"}\n ];\n```\n最后，把组件渲染到html页面上。静态组件也就绘制完成了：\n```\nReact.render(<TableComponent data={USERS} />,document.getElementById(\"content\"));\n```\n\n## 第三步：识别UI的state\nstate是组件私有的，可以通过调用 this.setState() 来改变它。当状态更新之后，组件重新渲染自己。也就是说每当state改变之后，React的虚拟DOM机制就会感知到变化然后重新绘制UI。由于虚拟DOM操作是在内存里面，这就使得UI的重新绘制非常地高效快捷。这是React的精髓所在。\n好了，寻找state的三步法：\n* 是否是从父级通过 props 传入的？如果是，可能不是 state 。\n* 是否会随着时间改变？如果不是，可能不是 state 。\n* 能根据组件中其它 state 数据或者 props 计算出来吗？如果是，就不是 state 。\n\n在这里，我们的组件是随着TheadCell被点击，整个组件重新排序。所以Thead组件的变化必须影响到Tbody的状态。所以我们把state设置在Thead和Tbody的父级组件TableComponent上。\n```\nvar TableComponent = React.createClass({\n    getInitialState: function (){\n        return {\n            sortBy:''\n        };\n    },\n    render: function (){\n        return (\n            <table>\n                <Thead uid=\"uid\" name=\"name\" tel=\"tel\"/>\n                <Tbody items={this.props.data} sortBy={this.state.sortBy}/>\n            </table>\n        );\n    }\n});\n```\ngetInitialState 初始化组件的state，然后传递给子级Tbody。\n\n## 第四步：添加反向数据流\nstate的动态变化才会导致组件重新绘制，所以发生在组件点击事件必须要能改变组件的state，组件树中层级很深的表单组件TheadCell需要更新 TableComponent 中的 state 。\n```\nvar TableComponent = React.createClass({\n    getInitialState: function (){\n        return {\n            sortBy:''\n        };\n    },\n    handleClick: function(value){\n        this.setState({\n            sortBy:value\n        });\n    },\n    render: function (){\n        return (\n            <table>\n                <Thead  sort={this.handleClick} uid=\"uid\" name=\"name\" tel=\"tel\"/>\n                <Tbody items={this.props.data} sortBy={this.state.sortBy}/>\n            </table>\n        );\n    }\n});\n```\n这里，传递给子级组件Thead一个回调函数handleClick，回调函数触发时调用this.setState()来改变组件的state。由于点击事件是绑定在Thead的子级TheadCell上的，所以我这里的处理方法就是让Thead把回调函数handleClick再传递给下一子级TheadCell。Thead是这样子处理的：\n```\nvar  Thead = React.createClass({\n    returnSort: function(v){\n        this.props.sort(v);\n    },\n    render: function (){\n        return (\n            <thead>\n                <caption>点击表格头部进行排序</caption>\n                <tr>\n                    <TheadCell bubbleClick={this.returnSort} content={this.props.uid} />\n                    <TheadCell bubbleClick={this.returnSort} content={this.props.name} />\n                    <TheadCell bubbleClick={this.returnSort} content={this.props.tel} />\n                </tr>\n            </thead>\n        );\n    }\n});\n```\n把TheadCell的回调作为回调sort的一个过渡。\n\n最后，需要知道鼠标点击的是哪一个表头字段（uid,name还是tel）。React提供的获取标签值得方法是refs，所以 th 标签需要知道一个ref属性，我把它的值叫做getSortKey，也就是用来排序的字段。通过getDOMNode获取到UI的具体节点。在这里需要说明的一点就是，React里面给标签对象注册事件必须使用基于元素的DOM0级事件注册，而且是用驼峰格式。比如注册点击事件onClick。\n```\nvar  TheadCell = React.createClass({\n    handler: function(){\n        this.props.bubbleClick(this.refs.getSortKey.getDOMNode().innerHTML);\n    },\n    render: function (){\n        return (\n            <th ref=\"getSortKey\" title=\"点击此键进行排序\" onClick={this.handler}>{this.props.content}</th>\n        );\n    }\n}) \n```\n\n接下来就是双向数据流绑定的重要一步，也就是组件state改变之后UI如何实时响应并重新渲染绘制。这一步是发生在Tbody组件上面的，关键的地方在于表格tbody的绘制必须要由state计算而来，这样state的改变才会导致UI的重新绘制：\n```\nvar Tbody = React.createClass({\n    render: function (){\n        var row = [],\n            userlist = this.props.items,\n                cmpKey = \"\",\n                    sortBy = this.props.sortBy;\n        // 获取需要拿来比较的字段\n        for (it in userlist[0]){\n            if(sortBy == it){\n                cmpKey = it;\n            }\n        }\n\n        // 如果有排序键，进行排序\n        if (cmpKey){\n            userlist.sort(function (a,b){\n                if(a[cmpKey] < b[cmpKey]){\n                    return -1;\n                }\n                if(a[cmpKey] > b[cmpKey]){\n                    return 1;\n                }\n                return 0;\n            });\n        }\n        \n        // 排序后的table\n        for(var item in userlist){\n            row.push(<Cell userItem={this.props.items[item]} key={item}/>);\n        }\n\n        return(\n            <tbody>\n                {row}\n            </tbody>\n        );\n    }\n});\n```\n\n# 本篇结语\n这一篇主要是介绍怎么样去使用React制作组件，这是入门级别的说明。想要更多地了解React.js的朋友可以进入[官方文档](http://reactjs.cn/)进行深入学习。\n\n","slug":"React-js那些事-入门篇","published":1,"updated":"2016-08-13T03:08:44.533Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtqt000n7kaur42e0w3v","content":"<p>关于React.js的相关背景知识以及它的核心概念已经在<a href=\"http://hugzh.github.io/2015/09/11/React-js%E9%82%A3%E4%BA%9B%E4%BA%8B-%E4%BB%8B%E7%BB%8D%E7%AF%87/\" target=\"_blank\" rel=\"external\">上一篇文章</a>里面说过。在这一篇里面，我通过一个组件开发的实例简单介绍如何使用React进行web组件开发。</p>\n<p>先来介绍一下这个打算实现的组件的功能：这是一个简单的三列表格，包含用户id，用户名，电话号码三列。当用户点击表头thead的单元时，表格会根据点中的列的字段进行升序排序。<br><a id=\"more\"></a><br>三军未动，先上demo：</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/hugzh/6jzz77de/3/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<h2 id=\"第一步：划分组件\"><a href=\"#第一步：划分组件\" class=\"headerlink\" title=\"第一步：划分组件\"></a>第一步：划分组件</h2><p>首先，我们需要将整个组件划分为几个子组件，这是组件开发的重要思想——拆分组合。这是实现组件重用的关键技术。根据案例的原型，我将组件划分如下：<br><img src=\"http://huguozhi-media.stor.sinaapp.com/mygitio%2Ftable.JPG\" alt=\"table partion\"><br>最外层的组件是我需要的目标组件 ——TableComponent，由绿色部分和黄色部分组成;<br>绿色部分为组件Thead，由三个相同的组件TheadCell构成(红色);<br>黄色部分为组件Tbody,每一行是一个组件Cell(蓝色)；<br>红色部分—— TheadCell;<br>蓝色部分—— Cell;</p>\n<h2 id=\"第二步：组件绘制\"><a href=\"#第二步：组件绘制\" class=\"headerlink\" title=\"第二步：组件绘制\"></a>第二步：组件绘制</h2><p>组件绘制非常简单，首先需要引入react.js文件以及TSX转换器文件JSXTransformer.js。然后，创建一个组件只需要调用一个函数React.createClass()即可，可以从外层到里层构件或者从里层到外层构件。比如，我先构造组件TheadCell:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span>  TheadCell = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"getSortKey\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"点击此键进行排序\"</span>&gt;</span>&#123;this.props.content&#125;<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样就可以构造出一个Thead组件了，它的UI表现就是一个表头的 th 元素。一个组件的数据内容由该组件的父级传递过来，父级传递给子级的数据是通过 props 对象来传递的。然后子级组件通过this.props来读取数据对象的内容。父级组件传递数据对象给子级组件的方法也很简单，只要在组件传入一个属性值即可。在这里，TheadCell的父级组件为Thead，创建它并传递数据给TheadCell：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var  Thead = React.createClass(&#123;</div><div class=\"line\">    render: function ()&#123;</div><div class=\"line\">        return (</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">caption</span>&gt;</span>点击表格头部进行排序<span class=\"tag\">&lt;/<span class=\"name\">caption</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">TheadCell</span> <span class=\"attr\">content</span>=<span class=\"string\">&#123;this.props.uid&#125;</span> /&gt;</span></div><div class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">TheadCell</span> <span class=\"attr\">content</span>=<span class=\"string\">&#123;this.props.name&#125;</span> /&gt;</span></div><div class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">TheadCell</span> <span class=\"attr\">content</span>=<span class=\"string\">&#123;this.props.tel&#125;</span> /&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这样，Thead包含了三个子组件TheadCell，然后类似XML的标签语法定义组件的“属性”——content。在这里，content的值来自Thead的父级组件TableComponent。<br>同样的道理，创建剩下的所有静态组件：</p>\n<p>创建Cell：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Cell  = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>&#123;this.props.userItem.uid&#125;<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>&#123;this.props.userItem.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>&#123;this.props.userItem.tel&#125;<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>创建Tbody:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Tbody = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> row = [],</div><div class=\"line\">            userlist = <span class=\"keyword\">this</span>.props.items;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> userlist)&#123;</div><div class=\"line\">            row.push(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Cell</span> <span class=\"attr\">userItem</span>=<span class=\"string\">&#123;this.props.items[item]&#125;</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;item&#125;/</span>&gt;</span>);</span></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return(</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">                &#123;row&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>创建TableComponent:<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> TableComponent = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;table&gt;</div><div class=\"line\">                &lt;Thead  uid=<span class=\"string\">\"uid\"</span> name=<span class=\"string\">\"name\"</span> tel=<span class=\"string\">\"tel\"</span>/&gt;</div><div class=\"line\">                &lt;Tbody items=&#123;<span class=\"keyword\">this</span>.props.data&#125;/&gt;</div><div class=\"line\">            &lt;/table&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>在这个地方，为了方便，我省略了从服务器加载数据的步骤，直接声明一个静态数据：<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var USERS = [</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">4</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"zhut\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"13899994567\"</span>&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">2</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"xiaom\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"13580889999\"</span>&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">3</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Brand\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"15918446402\"</span>&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"defan\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"18913145678\"</span>&#125;</div><div class=\"line\"> ];</div></pre></td></tr></table></figure></p>\n<p>最后，把组件渲染到html页面上。静态组件也就绘制完成了：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">React</span><span class=\"selector-class\">.render</span>(&lt;TableComponent data=&#123;USERS&#125; /&gt;,document.getElementById(<span class=\"string\">\"content\"</span>));</div></pre></td></tr></table></figure></p>\n<h2 id=\"第三步：识别UI的state\"><a href=\"#第三步：识别UI的state\" class=\"headerlink\" title=\"第三步：识别UI的state\"></a>第三步：识别UI的state</h2><p>state是组件私有的，可以通过调用 this.setState() 来改变它。当状态更新之后，组件重新渲染自己。也就是说每当state改变之后，React的虚拟DOM机制就会感知到变化然后重新绘制UI。由于虚拟DOM操作是在内存里面，这就使得UI的重新绘制非常地高效快捷。这是React的精髓所在。<br>好了，寻找state的三步法：</p>\n<ul>\n<li>是否是从父级通过 props 传入的？如果是，可能不是 state 。</li>\n<li>是否会随着时间改变？如果不是，可能不是 state 。</li>\n<li>能根据组件中其它 state 数据或者 props 计算出来吗？如果是，就不是 state 。</li>\n</ul>\n<p>在这里，我们的组件是随着TheadCell被点击，整个组件重新排序。所以Thead组件的变化必须影响到Tbody的状态。所以我们把state设置在Thead和Tbody的父级组件TableComponent上。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> TableComponent = React.createClass(&#123;</div><div class=\"line\">    getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            sortBy:<span class=\"string\">''</span></div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;table&gt;</div><div class=\"line\">                &lt;Thead uid=<span class=\"string\">\"uid\"</span> name=<span class=\"string\">\"name\"</span> tel=<span class=\"string\">\"tel\"</span>/&gt;</div><div class=\"line\">                &lt;Tbody items=&#123;<span class=\"keyword\">this</span>.props.data&#125; sortBy=&#123;<span class=\"keyword\">this</span>.state.sortBy&#125;/&gt;</div><div class=\"line\">            &lt;/table&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>getInitialState 初始化组件的state，然后传递给子级Tbody。</p>\n<h2 id=\"第四步：添加反向数据流\"><a href=\"#第四步：添加反向数据流\" class=\"headerlink\" title=\"第四步：添加反向数据流\"></a>第四步：添加反向数据流</h2><p>state的动态变化才会导致组件重新绘制，所以发生在组件点击事件必须要能改变组件的state，组件树中层级很深的表单组件TheadCell需要更新 TableComponent 中的 state 。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> TableComponent = React.createClass(&#123;</div><div class=\"line\">    getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            sortBy:<span class=\"string\">''</span></div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    handleClick: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(value)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</div><div class=\"line\">            sortBy:value</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;table&gt;</div><div class=\"line\">                &lt;Thead  sort=&#123;<span class=\"keyword\">this</span>.handleClick&#125; uid=<span class=\"string\">\"uid\"</span> name=<span class=\"string\">\"name\"</span> tel=<span class=\"string\">\"tel\"</span>/&gt;</div><div class=\"line\">                &lt;Tbody items=&#123;<span class=\"keyword\">this</span>.props.data&#125; sortBy=&#123;<span class=\"keyword\">this</span>.state.sortBy&#125;/&gt;</div><div class=\"line\">            &lt;/table&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这里，传递给子级组件Thead一个回调函数handleClick，回调函数触发时调用this.setState()来改变组件的state。由于点击事件是绑定在Thead的子级TheadCell上的，所以我这里的处理方法就是让Thead把回调函数handleClick再传递给下一子级TheadCell。Thead是这样子处理的：<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span>  Thead = React.createClass(&#123;</div><div class=\"line\">    returnSort: function(v)&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.props.sort(v);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: function ()&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;thead&gt;</div><div class=\"line\">                &lt;caption&gt;点击表格头部进行排序&lt;/caption&gt;</div><div class=\"line\">                &lt;tr&gt;</div><div class=\"line\">                    &lt;TheadCell bubbleClick=&#123;<span class=\"keyword\">this</span>.returnSort&#125; content=&#123;<span class=\"keyword\">this</span>.props.uid&#125; /&gt;</div><div class=\"line\">                    &lt;TheadCell bubbleClick=&#123;<span class=\"keyword\">this</span>.returnSort&#125; content=&#123;<span class=\"keyword\">this</span>.props.name&#125; /&gt;</div><div class=\"line\">                    &lt;TheadCell bubbleClick=&#123;<span class=\"keyword\">this</span>.returnSort&#125; content=&#123;<span class=\"keyword\">this</span>.props.tel&#125; /&gt;</div><div class=\"line\">                &lt;/tr&gt;</div><div class=\"line\">            &lt;/thead&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>把TheadCell的回调作为回调sort的一个过渡。</p>\n<p>最后，需要知道鼠标点击的是哪一个表头字段（uid,name还是tel）。React提供的获取标签值得方法是refs，所以 th 标签需要知道一个ref属性，我把它的值叫做getSortKey，也就是用来排序的字段。通过getDOMNode获取到UI的具体节点。在这里需要说明的一点就是，React里面给标签对象注册事件必须使用基于元素的DOM0级事件注册，而且是用驼峰格式。比如注册点击事件onClick。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span>  TheadCell = React.createClass(&#123;</div><div class=\"line\">    handler: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.props.bubbleClick(<span class=\"keyword\">this</span>.refs.getSortKey.getDOMNode().innerHTML);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"getSortKey\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"点击此键进行排序\"</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handler&#125;</span>&gt;</span>&#123;this.props.content&#125;<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>接下来就是双向数据流绑定的重要一步，也就是组件state改变之后UI如何实时响应并重新渲染绘制。这一步是发生在Tbody组件上面的，关键的地方在于表格tbody的绘制必须要由state计算而来，这样state的改变才会导致UI的重新绘制：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Tbody = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> row = [],</div><div class=\"line\">            userlist = <span class=\"keyword\">this</span>.props.items,</div><div class=\"line\">                cmpKey = <span class=\"string\">\"\"</span>,</div><div class=\"line\">                    sortBy = <span class=\"keyword\">this</span>.props.sortBy;</div><div class=\"line\">        <span class=\"comment\">// 获取需要拿来比较的字段</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (it <span class=\"keyword\">in</span> userlist[<span class=\"number\">0</span>])&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(sortBy == it)&#123;</div><div class=\"line\">                cmpKey = it;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果有排序键，进行排序</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (cmpKey)&#123;</div><div class=\"line\">            userlist.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a,b</span>)</span>&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>(a[cmpKey] &lt; b[cmpKey])&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span>(a[cmpKey] &gt; b[cmpKey])&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 排序后的table</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> userlist)&#123;</div><div class=\"line\">            row.push(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Cell</span> <span class=\"attr\">userItem</span>=<span class=\"string\">&#123;this.props.items[item]&#125;</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;item&#125;/</span>&gt;</span>);</span></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return(</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">                &#123;row&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h1 id=\"本篇结语\"><a href=\"#本篇结语\" class=\"headerlink\" title=\"本篇结语\"></a>本篇结语</h1><p>这一篇主要是介绍怎么样去使用React制作组件，这是入门级别的说明。想要更多地了解React.js的朋友可以进入<a href=\"http://reactjs.cn/\" target=\"_blank\" rel=\"external\">官方文档</a>进行深入学习。</p>\n","excerpt":"<p>关于React.js的相关背景知识以及它的核心概念已经在<a href=\"http://hugzh.github.io/2015/09/11/React-js%E9%82%A3%E4%BA%9B%E4%BA%8B-%E4%BB%8B%E7%BB%8D%E7%AF%87/\">上一篇文章</a>里面说过。在这一篇里面，我通过一个组件开发的实例简单介绍如何使用React进行web组件开发。</p>\n<p>先来介绍一下这个打算实现的组件的功能：这是一个简单的三列表格，包含用户id，用户名，电话号码三列。当用户点击表头thead的单元时，表格会根据点中的列的字段进行升序排序。<br>","more":"<br>三军未动，先上demo：</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/hugzh/6jzz77de/3/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<h2 id=\"第一步：划分组件\"><a href=\"#第一步：划分组件\" class=\"headerlink\" title=\"第一步：划分组件\"></a>第一步：划分组件</h2><p>首先，我们需要将整个组件划分为几个子组件，这是组件开发的重要思想——拆分组合。这是实现组件重用的关键技术。根据案例的原型，我将组件划分如下：<br><img src=\"http://huguozhi-media.stor.sinaapp.com/mygitio%2Ftable.JPG\" alt=\"table partion\"><br>最外层的组件是我需要的目标组件 ——TableComponent，由绿色部分和黄色部分组成;<br>绿色部分为组件Thead，由三个相同的组件TheadCell构成(红色);<br>黄色部分为组件Tbody,每一行是一个组件Cell(蓝色)；<br>红色部分—— TheadCell;<br>蓝色部分—— Cell;</p>\n<h2 id=\"第二步：组件绘制\"><a href=\"#第二步：组件绘制\" class=\"headerlink\" title=\"第二步：组件绘制\"></a>第二步：组件绘制</h2><p>组件绘制非常简单，首先需要引入react.js文件以及TSX转换器文件JSXTransformer.js。然后，创建一个组件只需要调用一个函数React.createClass()即可，可以从外层到里层构件或者从里层到外层构件。比如，我先构造组件TheadCell:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span>  TheadCell = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"getSortKey\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"点击此键进行排序\"</span>&gt;</span>&#123;this.props.content&#125;<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样就可以构造出一个Thead组件了，它的UI表现就是一个表头的 th 元素。一个组件的数据内容由该组件的父级传递过来，父级传递给子级的数据是通过 props 对象来传递的。然后子级组件通过this.props来读取数据对象的内容。父级组件传递数据对象给子级组件的方法也很简单，只要在组件传入一个属性值即可。在这里，TheadCell的父级组件为Thead，创建它并传递数据给TheadCell：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var  Thead = React.createClass(&#123;</div><div class=\"line\">    render: function ()&#123;</div><div class=\"line\">        return (</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">caption</span>&gt;</span>点击表格头部进行排序<span class=\"tag\">&lt;/<span class=\"name\">caption</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">TheadCell</span> <span class=\"attr\">content</span>=<span class=\"string\">&#123;this.props.uid&#125;</span> /&gt;</span></div><div class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">TheadCell</span> <span class=\"attr\">content</span>=<span class=\"string\">&#123;this.props.name&#125;</span> /&gt;</span></div><div class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">TheadCell</span> <span class=\"attr\">content</span>=<span class=\"string\">&#123;this.props.tel&#125;</span> /&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这样，Thead包含了三个子组件TheadCell，然后类似XML的标签语法定义组件的“属性”——content。在这里，content的值来自Thead的父级组件TableComponent。<br>同样的道理，创建剩下的所有静态组件：</p>\n<p>创建Cell：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Cell  = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>&#123;this.props.userItem.uid&#125;<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>&#123;this.props.userItem.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>&#123;this.props.userItem.tel&#125;<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>创建Tbody:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Tbody = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> row = [],</div><div class=\"line\">            userlist = <span class=\"keyword\">this</span>.props.items;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> userlist)&#123;</div><div class=\"line\">            row.push(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Cell</span> <span class=\"attr\">userItem</span>=<span class=\"string\">&#123;this.props.items[item]&#125;</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;item&#125;/</span>&gt;</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return(</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">                &#123;row&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</span></div></pre></td></tr></table></figure></p>\n<p>创建TableComponent:<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> TableComponent = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;table&gt;</div><div class=\"line\">                &lt;Thead  uid=<span class=\"string\">\"uid\"</span> name=<span class=\"string\">\"name\"</span> tel=<span class=\"string\">\"tel\"</span>/&gt;</div><div class=\"line\">                &lt;Tbody items=&#123;<span class=\"keyword\">this</span>.props.data&#125;/&gt;</div><div class=\"line\">            &lt;/table&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>在这个地方，为了方便，我省略了从服务器加载数据的步骤，直接声明一个静态数据：<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var USERS = [</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">4</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"zhut\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"13899994567\"</span>&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">2</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"xiaom\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"13580889999\"</span>&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">3</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Brand\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"15918446402\"</span>&#125;,</div><div class=\"line\">    &#123;<span class=\"string\">\"uid\"</span>:<span class=\"number\">1</span>,<span class=\"string\">\"name\"</span>:<span class=\"string\">\"defan\"</span>,<span class=\"string\">\"tel\"</span>:<span class=\"string\">\"18913145678\"</span>&#125;</div><div class=\"line\"> ];</div></pre></td></tr></table></figure></p>\n<p>最后，把组件渲染到html页面上。静态组件也就绘制完成了：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">React</span><span class=\"selector-class\">.render</span>(&lt;TableComponent data=&#123;USERS&#125; /&gt;,document.getElementById(<span class=\"string\">\"content\"</span>));</div></pre></td></tr></table></figure></p>\n<h2 id=\"第三步：识别UI的state\"><a href=\"#第三步：识别UI的state\" class=\"headerlink\" title=\"第三步：识别UI的state\"></a>第三步：识别UI的state</h2><p>state是组件私有的，可以通过调用 this.setState() 来改变它。当状态更新之后，组件重新渲染自己。也就是说每当state改变之后，React的虚拟DOM机制就会感知到变化然后重新绘制UI。由于虚拟DOM操作是在内存里面，这就使得UI的重新绘制非常地高效快捷。这是React的精髓所在。<br>好了，寻找state的三步法：</p>\n<ul>\n<li>是否是从父级通过 props 传入的？如果是，可能不是 state 。</li>\n<li>是否会随着时间改变？如果不是，可能不是 state 。</li>\n<li>能根据组件中其它 state 数据或者 props 计算出来吗？如果是，就不是 state 。</li>\n</ul>\n<p>在这里，我们的组件是随着TheadCell被点击，整个组件重新排序。所以Thead组件的变化必须影响到Tbody的状态。所以我们把state设置在Thead和Tbody的父级组件TableComponent上。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> TableComponent = React.createClass(&#123;</div><div class=\"line\">    getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            sortBy:<span class=\"string\">''</span></div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;table&gt;</div><div class=\"line\">                &lt;Thead uid=<span class=\"string\">\"uid\"</span> name=<span class=\"string\">\"name\"</span> tel=<span class=\"string\">\"tel\"</span>/&gt;</div><div class=\"line\">                &lt;Tbody items=&#123;<span class=\"keyword\">this</span>.props.data&#125; sortBy=&#123;<span class=\"keyword\">this</span>.state.sortBy&#125;/&gt;</div><div class=\"line\">            &lt;/table&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>getInitialState 初始化组件的state，然后传递给子级Tbody。</p>\n<h2 id=\"第四步：添加反向数据流\"><a href=\"#第四步：添加反向数据流\" class=\"headerlink\" title=\"第四步：添加反向数据流\"></a>第四步：添加反向数据流</h2><p>state的动态变化才会导致组件重新绘制，所以发生在组件点击事件必须要能改变组件的state，组件树中层级很深的表单组件TheadCell需要更新 TableComponent 中的 state 。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> TableComponent = React.createClass(&#123;</div><div class=\"line\">    getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            sortBy:<span class=\"string\">''</span></div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    handleClick: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(value)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</div><div class=\"line\">            sortBy:value</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;table&gt;</div><div class=\"line\">                &lt;Thead  sort=&#123;<span class=\"keyword\">this</span>.handleClick&#125; uid=<span class=\"string\">\"uid\"</span> name=<span class=\"string\">\"name\"</span> tel=<span class=\"string\">\"tel\"</span>/&gt;</div><div class=\"line\">                &lt;Tbody items=&#123;<span class=\"keyword\">this</span>.props.data&#125; sortBy=&#123;<span class=\"keyword\">this</span>.state.sortBy&#125;/&gt;</div><div class=\"line\">            &lt;/table&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这里，传递给子级组件Thead一个回调函数handleClick，回调函数触发时调用this.setState()来改变组件的state。由于点击事件是绑定在Thead的子级TheadCell上的，所以我这里的处理方法就是让Thead把回调函数handleClick再传递给下一子级TheadCell。Thead是这样子处理的：<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span>  Thead = React.createClass(&#123;</div><div class=\"line\">    returnSort: function(v)&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.props.sort(v);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: function ()&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            &lt;thead&gt;</div><div class=\"line\">                &lt;caption&gt;点击表格头部进行排序&lt;/caption&gt;</div><div class=\"line\">                &lt;tr&gt;</div><div class=\"line\">                    &lt;TheadCell bubbleClick=&#123;<span class=\"keyword\">this</span>.returnSort&#125; content=&#123;<span class=\"keyword\">this</span>.props.uid&#125; /&gt;</div><div class=\"line\">                    &lt;TheadCell bubbleClick=&#123;<span class=\"keyword\">this</span>.returnSort&#125; content=&#123;<span class=\"keyword\">this</span>.props.name&#125; /&gt;</div><div class=\"line\">                    &lt;TheadCell bubbleClick=&#123;<span class=\"keyword\">this</span>.returnSort&#125; content=&#123;<span class=\"keyword\">this</span>.props.tel&#125; /&gt;</div><div class=\"line\">                &lt;/tr&gt;</div><div class=\"line\">            &lt;/thead&gt;</div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>把TheadCell的回调作为回调sort的一个过渡。</p>\n<p>最后，需要知道鼠标点击的是哪一个表头字段（uid,name还是tel）。React提供的获取标签值得方法是refs，所以 th 标签需要知道一个ref属性，我把它的值叫做getSortKey，也就是用来排序的字段。通过getDOMNode获取到UI的具体节点。在这里需要说明的一点就是，React里面给标签对象注册事件必须使用基于元素的DOM0级事件注册，而且是用驼峰格式。比如注册点击事件onClick。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span>  TheadCell = React.createClass(&#123;</div><div class=\"line\">    handler: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.props.bubbleClick(<span class=\"keyword\">this</span>.refs.getSortKey.getDOMNode().innerHTML);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"getSortKey\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"点击此键进行排序\"</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handler&#125;</span>&gt;</span>&#123;this.props.content&#125;<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>接下来就是双向数据流绑定的重要一步，也就是组件state改变之后UI如何实时响应并重新渲染绘制。这一步是发生在Tbody组件上面的，关键的地方在于表格tbody的绘制必须要由state计算而来，这样state的改变才会导致UI的重新绘制：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Tbody = React.createClass(&#123;</div><div class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> row = [],</div><div class=\"line\">            userlist = <span class=\"keyword\">this</span>.props.items,</div><div class=\"line\">                cmpKey = <span class=\"string\">\"\"</span>,</div><div class=\"line\">                    sortBy = <span class=\"keyword\">this</span>.props.sortBy;</div><div class=\"line\">        <span class=\"comment\">// 获取需要拿来比较的字段</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (it <span class=\"keyword\">in</span> userlist[<span class=\"number\">0</span>])&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(sortBy == it)&#123;</div><div class=\"line\">                cmpKey = it;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 如果有排序键，进行排序</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (cmpKey)&#123;</div><div class=\"line\">            userlist.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a,b</span>)</span>&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>(a[cmpKey] &lt; b[cmpKey])&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span>(a[cmpKey] &gt; b[cmpKey])&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 排序后的table</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> userlist)&#123;</div><div class=\"line\">            row.push(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Cell</span> <span class=\"attr\">userItem</span>=<span class=\"string\">&#123;this.props.items[item]&#125;</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;item&#125;/</span>&gt;</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return(</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">                &#123;row&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">        );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"本篇结语\"><a href=\"#本篇结语\" class=\"headerlink\" title=\"本篇结语\"></a>本篇结语</h1><p>这一篇主要是介绍怎么样去使用React制作组件，这是入门级别的说明。想要更多地了解React.js的朋友可以进入<a href=\"http://reactjs.cn/\">官方文档</a>进行深入学习。</p>"},{"title":"Vue初接触实战之账单组件","date":"2016-08-13T03:20:36.000Z","_content":"\nVue作为一个构建数据驱动web界面的库，是去年最火的MVVM风格库之一。Vue的用起来有Angular的影子，把很多自定义指令注入html，又吸收了React的优点和精华。比如与Vue的配套使用的Vuex就是从Redux和Flux中借鉴了不少思路。<!-- more -->\nVue从去年的下半年开始火起来，目前在Awesomes前端资源库的热度排行里面处于Top2的位置。得益于更加简洁的语法和易用性，Vue目前在社区的受欢迎度不在React之下。很多公司纷纷上手Vue了，我厂的前端团队也已经在使用Vue进行业务重构了。即将发布的Vue2.0版本也采用了和React一样的Virtual Dom技术,而且推出了前后端同构的服务端渲染框架vue-hackernews-2.0，这将会使得Vue在技术社区更加受追捧。目前[Vue2.0的RC文档](http://rc.vuejs.org/guide/)也已经出来了，可以预期，它的使用前景将会非常非常不错。\n\n## 这里要讲的是啥？\n这篇文章不是普及Vue的内部实现原理，也不是要比较MVVM三大法器Angular、React和Vue的优劣。这里主要是对自己最近上手学习Vue，进行SPA开发过程中的思路总结。希望通过展示一个分期账单组件，可以对像我一样的Vue初学者提供一丁点的帮助。因为是Vue新手,如有错误之处，也欢迎各位大神批评指正。\n\n## Vuex\n首先要介绍的是[Vuex](http://vuex.vuejs.org/en/index.html)这个神器。关于Vue的基本语法，可以直接打开[官方1.0文档](https://vuejs.org.cn/guide/)学习。当然，如果你想直接上手Vue2.0，也可以直接[访问这里](http://rc.vuejs.org/guide/)。\n>Vuex 是一个专门为 Vue.js 应用所设计的集中式状态管理架构。它借鉴了 Flux 和 Redux 的设计思想，但简化了概念，并且采用了一种为能更好发挥 Vue.js 数据响应机制而专门设计的实现。\n\n也就是说，Vuex将父组件与子组件之间的props传递，组件与组件之间的消息传递集中起来管理。在一个小型应用中，我们可能不会用到Vuex，这样会把原本很简单的任务复杂化了。但是，企业级的项目都是多条业务线交叉的，如果单纯使用Vue本身的组件通信，业务组件之间复杂的关系网会让项目后期的调试和Bug跟踪非常困难，尤其是当你在构建一个SPA项目的时候。\n> 为了更好的解决在大型应用中状态的共用问题，我们需要对组件的 组件本地状态(component local state) 和 应用层级状态(application level state) 进行区分。应用级的状态不属于任何特定的组件，但每一个组件仍然可以监视(Observe)其变化从而响应式地更新 DOM。通过汇总应用的状态管理于一处，我们就不必到处传递事件。\n\nVuex的数据流模型如下图所示：\n![vuex数据流模型](http://vuex.vuejs.org/en/vuex.png)\n1. 用户在组件中的输入操作触发 action 调用；\n2. Actions 通过分发 mutations 来修改 store 实例的状态；\n3. Store 实例的状态变化反过来又通过 getters 被组件获知，组件获悉状态变更之后就是数据驱动的魔法——实时更新DOM状态。\n\n需要注意的一点是，mutation本身是一个事件系统，通过定义事件来触发Store的状态变更。mutation里面定义的函数必须是同步函数，涉及到API调用的逻辑要放到Action进行，因为Action是可以定义异步函数的。\n\n## Vue-route\n介绍完Vuex，我们来说说[vue-router](http://router.vuejs.org/zh-cn/index.html)。vue-router是Vue官方提供的路由插件，通过vue-router配合Vuex，我们可以非常高效地开发大型SPA。vue-router最基本的作用是做SPA路由映射。\n```\nrouter.map({\n    '/foo': {\n        component: Foo\n    },\n    '/bar': {\n        component: Bar\n    }\n})\n```\n上面的配置中，当访问路径\"/foo\"的时候，SPA就会在<router-view>挂载组件Foo，改变访问路径为 \"/bar\"，Bar组件就会切换到主视口。这就是一个最基本的SAP路由配置。\n\n## 一步一步使用Vue构建S一个PA账单组件\n在简单了解了Vuex和Vue-router的基本概念之后，我们可以进入实践环节。如果还没有完全理解清楚Vue的语法和Vuex数据流的概念，可以继续多看几次官方文档，尤其是对刚接触MVVM的人来说，可能要多看几次才能对数据驱动的编程理念有更好的理解。\n### 1、项目目录\n```\n|-vue-demo\n    |-node_modules\n\n    |-order\n        |-app\n            |-components\n                |-All.vue\n\n                |-Latest.vue\n\n                |-Nav.vue\n\n                |-Order.vue\n            |-vuex\n                |-modules\n                    |-orderList.js\n                |-action.js\n\n                |-mutation.js\n\n                |-mutation-type.js\n\n                |-store.js\n            |-App.vue\n\n            |-main.js\n\n            |-router.js\n        |-index.html\n\n        |-webpack.config.js\n    |-package.json\n\n    |-README.md\n\n```\n这个是比较推荐的项目目录结构。其中order是我们要展示的账单组件的根目录，组件目录划分为入口index.html、webpack配置文件和app文件夹。在app目录内：\n\n* App.vue - 组件的根节点;\n* main.js - 组件入口;\n* router.js - 路由相关配置;\n* component - 组件根节点下的各个子组件;\n* vuex - 顾名思义，数据流架构vuex相关的文件，包括action、mutation和store。\n\n在大型项目中，组件数量多，涉及的数据流是比较复杂的。为了更好地管理store，我们又把store定义在不同的模块中，比如modules目录下的orderList就是账单列表相关的数据流。事件类型比较多的情况下，我们把事件名称定义在mutation-type中。\n### 2、创建组件入口\n组件入口需要做的事情包括创建Vue组件实例、挂载插件、配置路由，main.js如下:\n```\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport ConfigRouter from './router'\nimport App from './App.vue'\n// import './style/order.css'\nVue.config.devtools = true\n\nVue.use(VueRouter)\n\n// 创建vue-router实例\nvar router = new VueRouter()\n//配置路由\nConfigRouter(router)\n\n// 滚动到页面顶部\nrouter.beforeEach(function() {\n  window.scrollTo(0, 0)\n})\n\n//全路径匹配，防止出现404\nrouter.redirect({\n  '*': '/'\n})\n//启动APP\nrouter.start(App, '#root')\n```\n\n### 3、使用vue-router配置SPA路由\n账单组件的路由包括“最近7天待还”以及“全部待还”，router.js:\n\n```\nexport default function(router) {\n  router.map({\n    '/': {\n      component: require(\"./components/Latest.vue\"),\n      linkActiveClass: 'active'\n    },\n    '/latest': {\n      component: require(\"./components/Latest.vue\"),\n      linkActiveClass: 'active'\n    },\n    '/all': {\n      component: require(\"./components/All.vue\"),\n      linkActiveClass: 'active'\n    }\n  })\n}\n```\n\n### 4、创建 Vuex Store\n尝试列出组件用到的所有数据，在vuex目录下创建store.js文件：\n```\n// vuex/store.js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n// 导入各个模块的初始状态和 mutations\nimport orderList from './modules/orderList'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n  // 组合各个模块\n  modules: {\n    orderList\n  }\n})\n```\n由于我们把store拆分到不同的模块，所以创建store实例的时候需要引入orderList模块，它包括账单列表orders对象和当前被激活的账单对象activeOrder。需要定义的mutation只有一个\"SHOW_DETAIL\",当用户点击账单列表的某一个账单的时候，SHOW_DETAIL更新store的activeOrder，表示当前被展开的账单对象。modules/orderList.js如下：\n\n```\n// vuex/modules/index.js\nimport {\n  SHOW_DETAIL,\n} from '../mutation-types'\n\n// 该模块的初始状态\nconst state = {\n  orders: [{\n    id: 'aedf9c25',\n    tradeDate: '2016.04.08',\n    name: 'Nike跑步鞋青年版',\n    totalPrice: 888,\n    repayDate: '2016.08.08',\n    capital: '880',\n    interest: '5.5',\n    extra: '2.5',\n    type: '消费',\n    currentTerm: 1,\n    totalTerms: 1\n  }, {\n    id: 'cves9chs',\n    tradeDate: '2016.04.10',\n    name: '支付宝提现',\n    totalPrice: 773.5,\n    repayDate: '2016.08.10',\n    capital: '769',\n    interest: '4.5',\n    extra: '0',\n    type: '现金',\n    currentTerm: 1,\n    totalTerms: 4\n  }, {\n    id: 'deef1d3g',\n    tradeDate: '2016.05.15',\n    name: '喜洋洋抱枕',\n    totalPrice: 204.8,\n    repayDate: '2016.08.15',\n    capital: '203.5',\n    interest: '1.3',\n    extra: '0',\n    type: '消费',\n    currentTerm: 2,\n    totalTerms: 3\n  }],\n  activeOrder: {}\n}\n\n// 相关的 mutations\nconst mutations = {\n  [SHOW_DETAIL](state, id) {\n    state.activeOrder = state.orders.find(function(ele) {\n      return ele.id == id;\n    });\n  }\n}\n\nexport default {\n  state,\n  mutations\n}\n```\nmutation-types.js:\n```\nexport const SHOW_DETAIL = 'SHOW_DETAIL'\n```\n\n###  5、Action\nActions 是组件内用来分发 mutations 的函数。第一个参数固定为store。在这里，当用户点击账单列表的某一个账单区域的时候，要调用dispatch('SHOW_DETAIL')。这里的demo只涉及到一个简单的用户事件，所以action.js也比较简单：\n```\n// index actions\nexport const showDetail = makeAction('SHOW_DETAIL')\n\nfunction makeAction(type) {\n  return ({\n    dispatch\n  }, ...args) => dispatch(type, ...args)\n}\n```\n\n###  6、Vue组件\n我们在第一步，创建入口文件main.js的时候import进来App.vue这个根组件：\n```\nimport App from './App.vue'\n...\nrouter.start(App, '#root')\n```\n定义App.vue也很简单，创建一个Vue实例，把vuex的store注入到根实例即可，这样组件内的所有子组件都能访问到store：\n```\n// App.vue\n<script>\n  import Nav from './components/Nav.vue'\n  import store from './vuex/store'\n\n  export default {\n    name: 'App',\n    // 注入store到根组件\n    store,\n    data() {\n      return {}\n    },\n\n    components: {\n      //子组件order-nav\n      'order-nav': Nav\n    }\n  }\n</script>\n<template>\n  <div id=\"app\">\n    <order-nav></order-nav>\n    <router-view></router-view>\n  </div>\n</template>\n```\n\n这里的order-nav是一个导航栏组件，包括“最近7天待还”和“全部待还”两个，由于\"全部待还”的展示和“最近7天待还”基本一样，demo里面就没有再做实现，只提供一个占位方便展示router切换。Latest.vue就是最近7天待还子组件，它获取近7天待还账单列表，并在下一级子组件(order)中渲染组件列表。组件获取store的数据是通过getter来实现的。\n\n```\n// Latest.vue\n<script>\n  import { showDetail} from '../vuex/actions';\n  import Order from './Order.vue';\n\n  export default {\n    name: 'Latest',\n\n    data() {\n      return {\n      }\n    },\n    components:{\n      'order':Order\n    },\n    vuex: {\n     //解构函数，{orderList}对象指的是store的orderList模块的state.orderList\n      getters: {\n        orders: ({orderList}) => orderList.orders\n      },\n      //注入actoin\n      actions: {\n        showDetail\n      },\n      computed:{\n      }\n    }\n  }\n</script>\n<template>\n  <div class=\"container-fluid\">\n    <ul class=\"list-unstyled row\">\n      <order></order>\n    </ul>\n  </div>\n</template>\n```\n\nOrder.vue是这个账单组件中负责内容显示和用户事件分发的组件模块。Order组件中包括比较详细的Vue指令语法，比如v-for,v-show,track-by等。为了增强用户体验，Order组件在用户点击账单展示详情的时候，通过定义trasitoin属性达到简单的动画切换效果。\n\n```\n// Order.vue\n<script>\n  import {fold,showDetail} from '../vuex/actions'\n  export default {\n    name: 'Order',\n    vuex: {\n      getters: {\n        orders: ({orderList}) => orderList.orders,\n        activeOrder:({orderList})=>orderList.activeOrder\n      },\n      actions:{\n        showDetail\n      }\n    }\n  }\n</script>\n<template>\n  <li  class=\"bill\" v-for=\"order in orders\" @click=\"showDetail(order.id)\" track-by=\"id\">\n   <div>\n      <h4>{{order.name}}</h4>\n      <p>待还\n      <span class=\"text-danger\">{{order.totalPrice}}</span>元&nbsp;&nbsp;\n      <span><small>[{{order.currentTerm}}/{{order.totalTerms}}]</small></span>\n      </p>\n    </div>\n    <div class=\"bill-detail\" v-show=\"order.id==activeOrder.id\" transition=\"fade\">\n        <p>\n        <div class=\"order-item\">最后还款日期：{{order.repayDate}}</div>\n        <div class=\"order-item\">交易类型期：{{order.type}}</div>\n        <div class=\"order-item\">应还本金：{{order.capital}}元</div>\n        <div class=\"order-item\">应还利息：{{order.interest}}元</div>\n        <div class=\"order-item\">手续费：{{order.extra}}元</div>\n        <div class=\"order-item\">交易日期：{{order.tradeDate}}</div>\n        </p> \n    </div>\n  </li>\n</template>\n\n<style media=\"screen\">\n.bill {\n  border-top:2px solid #e7e7e7;\n  border-bottom: 2px solid #e7e7e7;\n  margin: 5px; \n  padding: 10px;\n  cursor: pointer;\n}\n.bill-detail {\n  padding: 0 10px;\n}\n.order-item {\n  display: inline-block;\n  width: 45%;\n}\n/* 过渡效果 */\n.fade-transition {\n  transition: all .8s ease;\n}\n.fade-enter,\n.fade-leave {\n  height: 0;\n  opacity: 0;\n}\n</style>\n\n```\n最后附上的是组件导航子组件，主要是负责router路由切换的Nav.vue:\n\n```\n// Nav.vue\n<script>\n  export default {\n    name: 'nav',\n    vuex: {\n      getters: {\n        current: ({orderList}) => orderList.activeOrder\n      }\n    }\n  }\n</script>\n<template>\n  <nav class=\"navbar navbar-default\">\n    <div class=\"container-fluid\">\n      <div class=\"navbar-header\">\n        <a class=\"navbar-brand\" href=\"#\" v-link=\"{ path: '/' }\">Vue-订单demo</a>\n      </div>\n      <div class=\"collapse navbar-collapse\">\n        <ul class=\"nav navbar-nav\">\n          <li v-link=\"{ path: '/latest',activeClass:'active'}\"><a href=\"#!\">近7天待还 <span class=\"sr-only\">(current)</span></a></li>\n          <li v-link=\"{ path: '/all',activeClass:'active'}\"><a href=\"#!\"> 全部待还 </a></li>\n        </ul>\n      </div>\n    </div>\n  </nav>\n</template>\n```\n\n至此，我们已经一步步实现了一个基于Vue+Vuex+vue-router搭建的SPA组件demo，如果大家还没学会，可以直接去把完整的demo看一遍，喜欢的话也麻烦给个star。[点击这里](https://github.com/hugzh/vue-demo)进入账单组件的github地址。\n\n\n","source":"_posts/Vue初接触实战之账单组件.md","raw":"title: Vue初接触实战之账单组件\ndate: 2016-08-13 11:20:36\ntags: \n    - Vue \n    - MVVM\n    - Vuex\ncategories:\n    - 前端开发\n---\n\nVue作为一个构建数据驱动web界面的库，是去年最火的MVVM风格库之一。Vue的用起来有Angular的影子，把很多自定义指令注入html，又吸收了React的优点和精华。比如与Vue的配套使用的Vuex就是从Redux和Flux中借鉴了不少思路。<!-- more -->\nVue从去年的下半年开始火起来，目前在Awesomes前端资源库的热度排行里面处于Top2的位置。得益于更加简洁的语法和易用性，Vue目前在社区的受欢迎度不在React之下。很多公司纷纷上手Vue了，我厂的前端团队也已经在使用Vue进行业务重构了。即将发布的Vue2.0版本也采用了和React一样的Virtual Dom技术,而且推出了前后端同构的服务端渲染框架vue-hackernews-2.0，这将会使得Vue在技术社区更加受追捧。目前[Vue2.0的RC文档](http://rc.vuejs.org/guide/)也已经出来了，可以预期，它的使用前景将会非常非常不错。\n\n## 这里要讲的是啥？\n这篇文章不是普及Vue的内部实现原理，也不是要比较MVVM三大法器Angular、React和Vue的优劣。这里主要是对自己最近上手学习Vue，进行SPA开发过程中的思路总结。希望通过展示一个分期账单组件，可以对像我一样的Vue初学者提供一丁点的帮助。因为是Vue新手,如有错误之处，也欢迎各位大神批评指正。\n\n## Vuex\n首先要介绍的是[Vuex](http://vuex.vuejs.org/en/index.html)这个神器。关于Vue的基本语法，可以直接打开[官方1.0文档](https://vuejs.org.cn/guide/)学习。当然，如果你想直接上手Vue2.0，也可以直接[访问这里](http://rc.vuejs.org/guide/)。\n>Vuex 是一个专门为 Vue.js 应用所设计的集中式状态管理架构。它借鉴了 Flux 和 Redux 的设计思想，但简化了概念，并且采用了一种为能更好发挥 Vue.js 数据响应机制而专门设计的实现。\n\n也就是说，Vuex将父组件与子组件之间的props传递，组件与组件之间的消息传递集中起来管理。在一个小型应用中，我们可能不会用到Vuex，这样会把原本很简单的任务复杂化了。但是，企业级的项目都是多条业务线交叉的，如果单纯使用Vue本身的组件通信，业务组件之间复杂的关系网会让项目后期的调试和Bug跟踪非常困难，尤其是当你在构建一个SPA项目的时候。\n> 为了更好的解决在大型应用中状态的共用问题，我们需要对组件的 组件本地状态(component local state) 和 应用层级状态(application level state) 进行区分。应用级的状态不属于任何特定的组件，但每一个组件仍然可以监视(Observe)其变化从而响应式地更新 DOM。通过汇总应用的状态管理于一处，我们就不必到处传递事件。\n\nVuex的数据流模型如下图所示：\n![vuex数据流模型](http://vuex.vuejs.org/en/vuex.png)\n1. 用户在组件中的输入操作触发 action 调用；\n2. Actions 通过分发 mutations 来修改 store 实例的状态；\n3. Store 实例的状态变化反过来又通过 getters 被组件获知，组件获悉状态变更之后就是数据驱动的魔法——实时更新DOM状态。\n\n需要注意的一点是，mutation本身是一个事件系统，通过定义事件来触发Store的状态变更。mutation里面定义的函数必须是同步函数，涉及到API调用的逻辑要放到Action进行，因为Action是可以定义异步函数的。\n\n## Vue-route\n介绍完Vuex，我们来说说[vue-router](http://router.vuejs.org/zh-cn/index.html)。vue-router是Vue官方提供的路由插件，通过vue-router配合Vuex，我们可以非常高效地开发大型SPA。vue-router最基本的作用是做SPA路由映射。\n```\nrouter.map({\n    '/foo': {\n        component: Foo\n    },\n    '/bar': {\n        component: Bar\n    }\n})\n```\n上面的配置中，当访问路径\"/foo\"的时候，SPA就会在<router-view>挂载组件Foo，改变访问路径为 \"/bar\"，Bar组件就会切换到主视口。这就是一个最基本的SAP路由配置。\n\n## 一步一步使用Vue构建S一个PA账单组件\n在简单了解了Vuex和Vue-router的基本概念之后，我们可以进入实践环节。如果还没有完全理解清楚Vue的语法和Vuex数据流的概念，可以继续多看几次官方文档，尤其是对刚接触MVVM的人来说，可能要多看几次才能对数据驱动的编程理念有更好的理解。\n### 1、项目目录\n```\n|-vue-demo\n    |-node_modules\n\n    |-order\n        |-app\n            |-components\n                |-All.vue\n\n                |-Latest.vue\n\n                |-Nav.vue\n\n                |-Order.vue\n            |-vuex\n                |-modules\n                    |-orderList.js\n                |-action.js\n\n                |-mutation.js\n\n                |-mutation-type.js\n\n                |-store.js\n            |-App.vue\n\n            |-main.js\n\n            |-router.js\n        |-index.html\n\n        |-webpack.config.js\n    |-package.json\n\n    |-README.md\n\n```\n这个是比较推荐的项目目录结构。其中order是我们要展示的账单组件的根目录，组件目录划分为入口index.html、webpack配置文件和app文件夹。在app目录内：\n\n* App.vue - 组件的根节点;\n* main.js - 组件入口;\n* router.js - 路由相关配置;\n* component - 组件根节点下的各个子组件;\n* vuex - 顾名思义，数据流架构vuex相关的文件，包括action、mutation和store。\n\n在大型项目中，组件数量多，涉及的数据流是比较复杂的。为了更好地管理store，我们又把store定义在不同的模块中，比如modules目录下的orderList就是账单列表相关的数据流。事件类型比较多的情况下，我们把事件名称定义在mutation-type中。\n### 2、创建组件入口\n组件入口需要做的事情包括创建Vue组件实例、挂载插件、配置路由，main.js如下:\n```\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport ConfigRouter from './router'\nimport App from './App.vue'\n// import './style/order.css'\nVue.config.devtools = true\n\nVue.use(VueRouter)\n\n// 创建vue-router实例\nvar router = new VueRouter()\n//配置路由\nConfigRouter(router)\n\n// 滚动到页面顶部\nrouter.beforeEach(function() {\n  window.scrollTo(0, 0)\n})\n\n//全路径匹配，防止出现404\nrouter.redirect({\n  '*': '/'\n})\n//启动APP\nrouter.start(App, '#root')\n```\n\n### 3、使用vue-router配置SPA路由\n账单组件的路由包括“最近7天待还”以及“全部待还”，router.js:\n\n```\nexport default function(router) {\n  router.map({\n    '/': {\n      component: require(\"./components/Latest.vue\"),\n      linkActiveClass: 'active'\n    },\n    '/latest': {\n      component: require(\"./components/Latest.vue\"),\n      linkActiveClass: 'active'\n    },\n    '/all': {\n      component: require(\"./components/All.vue\"),\n      linkActiveClass: 'active'\n    }\n  })\n}\n```\n\n### 4、创建 Vuex Store\n尝试列出组件用到的所有数据，在vuex目录下创建store.js文件：\n```\n// vuex/store.js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n// 导入各个模块的初始状态和 mutations\nimport orderList from './modules/orderList'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n  // 组合各个模块\n  modules: {\n    orderList\n  }\n})\n```\n由于我们把store拆分到不同的模块，所以创建store实例的时候需要引入orderList模块，它包括账单列表orders对象和当前被激活的账单对象activeOrder。需要定义的mutation只有一个\"SHOW_DETAIL\",当用户点击账单列表的某一个账单的时候，SHOW_DETAIL更新store的activeOrder，表示当前被展开的账单对象。modules/orderList.js如下：\n\n```\n// vuex/modules/index.js\nimport {\n  SHOW_DETAIL,\n} from '../mutation-types'\n\n// 该模块的初始状态\nconst state = {\n  orders: [{\n    id: 'aedf9c25',\n    tradeDate: '2016.04.08',\n    name: 'Nike跑步鞋青年版',\n    totalPrice: 888,\n    repayDate: '2016.08.08',\n    capital: '880',\n    interest: '5.5',\n    extra: '2.5',\n    type: '消费',\n    currentTerm: 1,\n    totalTerms: 1\n  }, {\n    id: 'cves9chs',\n    tradeDate: '2016.04.10',\n    name: '支付宝提现',\n    totalPrice: 773.5,\n    repayDate: '2016.08.10',\n    capital: '769',\n    interest: '4.5',\n    extra: '0',\n    type: '现金',\n    currentTerm: 1,\n    totalTerms: 4\n  }, {\n    id: 'deef1d3g',\n    tradeDate: '2016.05.15',\n    name: '喜洋洋抱枕',\n    totalPrice: 204.8,\n    repayDate: '2016.08.15',\n    capital: '203.5',\n    interest: '1.3',\n    extra: '0',\n    type: '消费',\n    currentTerm: 2,\n    totalTerms: 3\n  }],\n  activeOrder: {}\n}\n\n// 相关的 mutations\nconst mutations = {\n  [SHOW_DETAIL](state, id) {\n    state.activeOrder = state.orders.find(function(ele) {\n      return ele.id == id;\n    });\n  }\n}\n\nexport default {\n  state,\n  mutations\n}\n```\nmutation-types.js:\n```\nexport const SHOW_DETAIL = 'SHOW_DETAIL'\n```\n\n###  5、Action\nActions 是组件内用来分发 mutations 的函数。第一个参数固定为store。在这里，当用户点击账单列表的某一个账单区域的时候，要调用dispatch('SHOW_DETAIL')。这里的demo只涉及到一个简单的用户事件，所以action.js也比较简单：\n```\n// index actions\nexport const showDetail = makeAction('SHOW_DETAIL')\n\nfunction makeAction(type) {\n  return ({\n    dispatch\n  }, ...args) => dispatch(type, ...args)\n}\n```\n\n###  6、Vue组件\n我们在第一步，创建入口文件main.js的时候import进来App.vue这个根组件：\n```\nimport App from './App.vue'\n...\nrouter.start(App, '#root')\n```\n定义App.vue也很简单，创建一个Vue实例，把vuex的store注入到根实例即可，这样组件内的所有子组件都能访问到store：\n```\n// App.vue\n<script>\n  import Nav from './components/Nav.vue'\n  import store from './vuex/store'\n\n  export default {\n    name: 'App',\n    // 注入store到根组件\n    store,\n    data() {\n      return {}\n    },\n\n    components: {\n      //子组件order-nav\n      'order-nav': Nav\n    }\n  }\n</script>\n<template>\n  <div id=\"app\">\n    <order-nav></order-nav>\n    <router-view></router-view>\n  </div>\n</template>\n```\n\n这里的order-nav是一个导航栏组件，包括“最近7天待还”和“全部待还”两个，由于\"全部待还”的展示和“最近7天待还”基本一样，demo里面就没有再做实现，只提供一个占位方便展示router切换。Latest.vue就是最近7天待还子组件，它获取近7天待还账单列表，并在下一级子组件(order)中渲染组件列表。组件获取store的数据是通过getter来实现的。\n\n```\n// Latest.vue\n<script>\n  import { showDetail} from '../vuex/actions';\n  import Order from './Order.vue';\n\n  export default {\n    name: 'Latest',\n\n    data() {\n      return {\n      }\n    },\n    components:{\n      'order':Order\n    },\n    vuex: {\n     //解构函数，{orderList}对象指的是store的orderList模块的state.orderList\n      getters: {\n        orders: ({orderList}) => orderList.orders\n      },\n      //注入actoin\n      actions: {\n        showDetail\n      },\n      computed:{\n      }\n    }\n  }\n</script>\n<template>\n  <div class=\"container-fluid\">\n    <ul class=\"list-unstyled row\">\n      <order></order>\n    </ul>\n  </div>\n</template>\n```\n\nOrder.vue是这个账单组件中负责内容显示和用户事件分发的组件模块。Order组件中包括比较详细的Vue指令语法，比如v-for,v-show,track-by等。为了增强用户体验，Order组件在用户点击账单展示详情的时候，通过定义trasitoin属性达到简单的动画切换效果。\n\n```\n// Order.vue\n<script>\n  import {fold,showDetail} from '../vuex/actions'\n  export default {\n    name: 'Order',\n    vuex: {\n      getters: {\n        orders: ({orderList}) => orderList.orders,\n        activeOrder:({orderList})=>orderList.activeOrder\n      },\n      actions:{\n        showDetail\n      }\n    }\n  }\n</script>\n<template>\n  <li  class=\"bill\" v-for=\"order in orders\" @click=\"showDetail(order.id)\" track-by=\"id\">\n   <div>\n      <h4>{{order.name}}</h4>\n      <p>待还\n      <span class=\"text-danger\">{{order.totalPrice}}</span>元&nbsp;&nbsp;\n      <span><small>[{{order.currentTerm}}/{{order.totalTerms}}]</small></span>\n      </p>\n    </div>\n    <div class=\"bill-detail\" v-show=\"order.id==activeOrder.id\" transition=\"fade\">\n        <p>\n        <div class=\"order-item\">最后还款日期：{{order.repayDate}}</div>\n        <div class=\"order-item\">交易类型期：{{order.type}}</div>\n        <div class=\"order-item\">应还本金：{{order.capital}}元</div>\n        <div class=\"order-item\">应还利息：{{order.interest}}元</div>\n        <div class=\"order-item\">手续费：{{order.extra}}元</div>\n        <div class=\"order-item\">交易日期：{{order.tradeDate}}</div>\n        </p> \n    </div>\n  </li>\n</template>\n\n<style media=\"screen\">\n.bill {\n  border-top:2px solid #e7e7e7;\n  border-bottom: 2px solid #e7e7e7;\n  margin: 5px; \n  padding: 10px;\n  cursor: pointer;\n}\n.bill-detail {\n  padding: 0 10px;\n}\n.order-item {\n  display: inline-block;\n  width: 45%;\n}\n/* 过渡效果 */\n.fade-transition {\n  transition: all .8s ease;\n}\n.fade-enter,\n.fade-leave {\n  height: 0;\n  opacity: 0;\n}\n</style>\n\n```\n最后附上的是组件导航子组件，主要是负责router路由切换的Nav.vue:\n\n```\n// Nav.vue\n<script>\n  export default {\n    name: 'nav',\n    vuex: {\n      getters: {\n        current: ({orderList}) => orderList.activeOrder\n      }\n    }\n  }\n</script>\n<template>\n  <nav class=\"navbar navbar-default\">\n    <div class=\"container-fluid\">\n      <div class=\"navbar-header\">\n        <a class=\"navbar-brand\" href=\"#\" v-link=\"{ path: '/' }\">Vue-订单demo</a>\n      </div>\n      <div class=\"collapse navbar-collapse\">\n        <ul class=\"nav navbar-nav\">\n          <li v-link=\"{ path: '/latest',activeClass:'active'}\"><a href=\"#!\">近7天待还 <span class=\"sr-only\">(current)</span></a></li>\n          <li v-link=\"{ path: '/all',activeClass:'active'}\"><a href=\"#!\"> 全部待还 </a></li>\n        </ul>\n      </div>\n    </div>\n  </nav>\n</template>\n```\n\n至此，我们已经一步步实现了一个基于Vue+Vuex+vue-router搭建的SPA组件demo，如果大家还没学会，可以直接去把完整的demo看一遍，喜欢的话也麻烦给个star。[点击这里](https://github.com/hugzh/vue-demo)进入账单组件的github地址。\n\n\n","slug":"Vue初接触实战之账单组件","published":1,"updated":"2016-08-13T09:00:07.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtqu000p7kauxikmnzbh","content":"<p>Vue作为一个构建数据驱动web界面的库，是去年最火的MVVM风格库之一。Vue的用起来有Angular的影子，把很多自定义指令注入html，又吸收了React的优点和精华。比如与Vue的配套使用的Vuex就是从Redux和Flux中借鉴了不少思路。<a id=\"more\"></a><br>Vue从去年的下半年开始火起来，目前在Awesomes前端资源库的热度排行里面处于Top2的位置。得益于更加简洁的语法和易用性，Vue目前在社区的受欢迎度不在React之下。很多公司纷纷上手Vue了，我厂的前端团队也已经在使用Vue进行业务重构了。即将发布的Vue2.0版本也采用了和React一样的Virtual Dom技术,而且推出了前后端同构的服务端渲染框架vue-hackernews-2.0，这将会使得Vue在技术社区更加受追捧。目前<a href=\"http://rc.vuejs.org/guide/\" target=\"_blank\" rel=\"external\">Vue2.0的RC文档</a>也已经出来了，可以预期，它的使用前景将会非常非常不错。</p>\n<h2 id=\"这里要讲的是啥？\"><a href=\"#这里要讲的是啥？\" class=\"headerlink\" title=\"这里要讲的是啥？\"></a>这里要讲的是啥？</h2><p>这篇文章不是普及Vue的内部实现原理，也不是要比较MVVM三大法器Angular、React和Vue的优劣。这里主要是对自己最近上手学习Vue，进行SPA开发过程中的思路总结。希望通过展示一个分期账单组件，可以对像我一样的Vue初学者提供一丁点的帮助。因为是Vue新手,如有错误之处，也欢迎各位大神批评指正。</p>\n<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><p>首先要介绍的是<a href=\"http://vuex.vuejs.org/en/index.html\" target=\"_blank\" rel=\"external\">Vuex</a>这个神器。关于Vue的基本语法，可以直接打开<a href=\"https://vuejs.org.cn/guide/\" target=\"_blank\" rel=\"external\">官方1.0文档</a>学习。当然，如果你想直接上手Vue2.0，也可以直接<a href=\"http://rc.vuejs.org/guide/\" target=\"_blank\" rel=\"external\">访问这里</a>。</p>\n<blockquote>\n<p>Vuex 是一个专门为 Vue.js 应用所设计的集中式状态管理架构。它借鉴了 Flux 和 Redux 的设计思想，但简化了概念，并且采用了一种为能更好发挥 Vue.js 数据响应机制而专门设计的实现。</p>\n</blockquote>\n<p>也就是说，Vuex将父组件与子组件之间的props传递，组件与组件之间的消息传递集中起来管理。在一个小型应用中，我们可能不会用到Vuex，这样会把原本很简单的任务复杂化了。但是，企业级的项目都是多条业务线交叉的，如果单纯使用Vue本身的组件通信，业务组件之间复杂的关系网会让项目后期的调试和Bug跟踪非常困难，尤其是当你在构建一个SPA项目的时候。</p>\n<blockquote>\n<p>为了更好的解决在大型应用中状态的共用问题，我们需要对组件的 组件本地状态(component local state) 和 应用层级状态(application level state) 进行区分。应用级的状态不属于任何特定的组件，但每一个组件仍然可以监视(Observe)其变化从而响应式地更新 DOM。通过汇总应用的状态管理于一处，我们就不必到处传递事件。</p>\n</blockquote>\n<p>Vuex的数据流模型如下图所示：<br><img src=\"http://vuex.vuejs.org/en/vuex.png\" alt=\"vuex数据流模型\"></p>\n<ol>\n<li>用户在组件中的输入操作触发 action 调用；</li>\n<li>Actions 通过分发 mutations 来修改 store 实例的状态；</li>\n<li>Store 实例的状态变化反过来又通过 getters 被组件获知，组件获悉状态变更之后就是数据驱动的魔法——实时更新DOM状态。</li>\n</ol>\n<p>需要注意的一点是，mutation本身是一个事件系统，通过定义事件来触发Store的状态变更。mutation里面定义的函数必须是同步函数，涉及到API调用的逻辑要放到Action进行，因为Action是可以定义异步函数的。</p>\n<h2 id=\"Vue-route\"><a href=\"#Vue-route\" class=\"headerlink\" title=\"Vue-route\"></a>Vue-route</h2><p>介绍完Vuex，我们来说说<a href=\"http://router.vuejs.org/zh-cn/index.html\" target=\"_blank\" rel=\"external\">vue-router</a>。vue-router是Vue官方提供的路由插件，通过vue-router配合Vuex，我们可以非常高效地开发大型SPA。vue-router最基本的作用是做SPA路由映射。<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">router.<span class=\"keyword\">map</span>(&#123;</div><div class=\"line\">    <span class=\"string\">'/foo'</span>: &#123;</div><div class=\"line\">        component: Foo</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">'/bar'</span>: &#123;</div><div class=\"line\">        component: Bar</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>上面的配置中，当访问路径”/foo”的时候，SPA就会在<router-view>挂载组件Foo，改变访问路径为 “/bar”，Bar组件就会切换到主视口。这就是一个最基本的SAP路由配置。</router-view></p>\n<h2 id=\"一步一步使用Vue构建S一个PA账单组件\"><a href=\"#一步一步使用Vue构建S一个PA账单组件\" class=\"headerlink\" title=\"一步一步使用Vue构建S一个PA账单组件\"></a>一步一步使用Vue构建S一个PA账单组件</h2><p>在简单了解了Vuex和Vue-router的基本概念之后，我们可以进入实践环节。如果还没有完全理解清楚Vue的语法和Vuex数据流的概念，可以继续多看几次官方文档，尤其是对刚接触MVVM的人来说，可能要多看几次才能对数据驱动的编程理念有更好的理解。</p>\n<h3 id=\"1、项目目录\"><a href=\"#1、项目目录\" class=\"headerlink\" title=\"1、项目目录\"></a>1、项目目录</h3><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">|-vue-demo</span></div><div class=\"line\">    <span class=\"string\">|-node_modules</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"string\">|-order</span></div><div class=\"line\">        <span class=\"string\">|-app</span></div><div class=\"line\">            <span class=\"string\">|-components</span></div><div class=\"line\">                <span class=\"string\">|-All.vue</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"string\">|-Latest.vue</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"string\">|-Nav.vue</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"string\">|-Order.vue</span></div><div class=\"line\">            <span class=\"string\">|-vuex</span></div><div class=\"line\">                <span class=\"string\">|-modules</span></div><div class=\"line\">                    <span class=\"string\">|-orderList.js</span></div><div class=\"line\">                <span class=\"string\">|-action.js</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"string\">|-mutation.js</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"string\">|-mutation-type.js</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"string\">|-store.js</span></div><div class=\"line\">            <span class=\"string\">|-App.vue</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"string\">|-main.js</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"string\">|-router.js</span></div><div class=\"line\">        <span class=\"string\">|-index.html</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"string\">|-webpack.config.js</span></div><div class=\"line\">    <span class=\"string\">|-package.json</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"string\">|-README.md</span></div></pre></td></tr></table></figure>\n<p>这个是比较推荐的项目目录结构。其中order是我们要展示的账单组件的根目录，组件目录划分为入口index.html、webpack配置文件和app文件夹。在app目录内：</p>\n<ul>\n<li>App.vue - 组件的根节点;</li>\n<li>main.js - 组件入口;</li>\n<li>router.js - 路由相关配置;</li>\n<li>component - 组件根节点下的各个子组件;</li>\n<li>vuex - 顾名思义，数据流架构vuex相关的文件，包括action、mutation和store。</li>\n</ul>\n<p>在大型项目中，组件数量多，涉及的数据流是比较复杂的。为了更好地管理store，我们又把store定义在不同的模块中，比如modules目录下的orderList就是账单列表相关的数据流。事件类型比较多的情况下，我们把事件名称定义在mutation-type中。</p>\n<h3 id=\"2、创建组件入口\"><a href=\"#2、创建组件入口\" class=\"headerlink\" title=\"2、创建组件入口\"></a>2、创建组件入口</h3><p>组件入口需要做的事情包括创建Vue组件实例、挂载插件、配置路由，main.js如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> VueRouter <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></div><div class=\"line\"><span class=\"keyword\">import</span> ConfigRouter <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span></div><div class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App.vue'</span></div><div class=\"line\"><span class=\"comment\">// import './style/order.css'</span></div><div class=\"line\">Vue.config.devtools = <span class=\"literal\">true</span></div><div class=\"line\"></div><div class=\"line\">Vue.use(VueRouter)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建vue-router实例</span></div><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter()</div><div class=\"line\"><span class=\"comment\">//配置路由</span></div><div class=\"line\">ConfigRouter(router)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 滚动到页面顶部</span></div><div class=\"line\">router.beforeEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">window</span>.scrollTo(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//全路径匹配，防止出现404</span></div><div class=\"line\">router.redirect(&#123;</div><div class=\"line\">  <span class=\"string\">'*'</span>: <span class=\"string\">'/'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">//启动APP</span></div><div class=\"line\">router.start(App, <span class=\"string\">'#root'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"3、使用vue-router配置SPA路由\"><a href=\"#3、使用vue-router配置SPA路由\" class=\"headerlink\" title=\"3、使用vue-router配置SPA路由\"></a>3、使用vue-router配置SPA路由</h3><p>账单组件的路由包括“最近7天待还”以及“全部待还”，router.js:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">export default <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(router)</span> &#123;</span></div><div class=\"line\">  router.<span class=\"keyword\">map</span>(&#123;</div><div class=\"line\">    <span class=\"string\">'/'</span>: &#123;</div><div class=\"line\">      componen<span class=\"variable\">t:</span> require(<span class=\"string\">\"./components/Latest.vue\"</span>),</div><div class=\"line\">      linkActiveClas<span class=\"variable\">s:</span> <span class=\"string\">'active'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">'/latest'</span>: &#123;</div><div class=\"line\">      componen<span class=\"variable\">t:</span> require(<span class=\"string\">\"./components/Latest.vue\"</span>),</div><div class=\"line\">      linkActiveClas<span class=\"variable\">s:</span> <span class=\"string\">'active'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">'/all'</span>: &#123;</div><div class=\"line\">      componen<span class=\"variable\">t:</span> require(<span class=\"string\">\"./components/All.vue\"</span>),</div><div class=\"line\">      linkActiveClas<span class=\"variable\">s:</span> <span class=\"string\">'active'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4、创建-Vuex-Store\"><a href=\"#4、创建-Vuex-Store\" class=\"headerlink\" title=\"4、创建 Vuex Store\"></a>4、创建 Vuex Store</h3><p>尝试列出组件用到的所有数据，在vuex目录下创建store.js文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// vuex/store.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"><span class=\"comment\">// 导入各个模块的初始状态和 mutations</span></div><div class=\"line\"><span class=\"keyword\">import</span> orderList <span class=\"keyword\">from</span> <span class=\"string\">'./modules/orderList'</span></div><div class=\"line\"></div><div class=\"line\">Vue.use(Vuex)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</div><div class=\"line\">  <span class=\"comment\">// 组合各个模块</span></div><div class=\"line\">  modules: &#123;</div><div class=\"line\">    orderList</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>由于我们把store拆分到不同的模块，所以创建store实例的时候需要引入orderList模块，它包括账单列表orders对象和当前被激活的账单对象activeOrder。需要定义的mutation只有一个”SHOW_DETAIL”,当用户点击账单列表的某一个账单的时候，SHOW_DETAIL更新store的activeOrder，表示当前被展开的账单对象。modules/orderList.js如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// vuex/modules/index.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;</div><div class=\"line\">  SHOW_DETAIL,</div><div class=\"line\">&#125; from <span class=\"string\">'../mutation-types'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 该模块的初始状态</span></div><div class=\"line\"><span class=\"keyword\">const</span> state = &#123;</div><div class=\"line\">  orders: [&#123;</div><div class=\"line\">    id: <span class=\"string\">'aedf9c25'</span>,</div><div class=\"line\">    tradeDate: <span class=\"string\">'2016.04.08'</span>,</div><div class=\"line\">    name: <span class=\"string\">'Nike跑步鞋青年版'</span>,</div><div class=\"line\">    totalPrice: <span class=\"number\">888</span>,</div><div class=\"line\">    repayDate: <span class=\"string\">'2016.08.08'</span>,</div><div class=\"line\">    capital: <span class=\"string\">'880'</span>,</div><div class=\"line\">    interest: <span class=\"string\">'5.5'</span>,</div><div class=\"line\">    extra: <span class=\"string\">'2.5'</span>,</div><div class=\"line\">    <span class=\"keyword\">type</span>: <span class=\"string\">'消费'</span>,</div><div class=\"line\">    currentTerm: <span class=\"number\">1</span>,</div><div class=\"line\">    totalTerms: <span class=\"number\">1</span></div><div class=\"line\">  &#125;, &#123;</div><div class=\"line\">    id: <span class=\"string\">'cves9chs'</span>,</div><div class=\"line\">    tradeDate: <span class=\"string\">'2016.04.10'</span>,</div><div class=\"line\">    name: <span class=\"string\">'支付宝提现'</span>,</div><div class=\"line\">    totalPrice: <span class=\"number\">773.5</span>,</div><div class=\"line\">    repayDate: <span class=\"string\">'2016.08.10'</span>,</div><div class=\"line\">    capital: <span class=\"string\">'769'</span>,</div><div class=\"line\">    interest: <span class=\"string\">'4.5'</span>,</div><div class=\"line\">    extra: <span class=\"string\">'0'</span>,</div><div class=\"line\">    <span class=\"keyword\">type</span>: <span class=\"string\">'现金'</span>,</div><div class=\"line\">    currentTerm: <span class=\"number\">1</span>,</div><div class=\"line\">    totalTerms: <span class=\"number\">4</span></div><div class=\"line\">  &#125;, &#123;</div><div class=\"line\">    id: <span class=\"string\">'deef1d3g'</span>,</div><div class=\"line\">    tradeDate: <span class=\"string\">'2016.05.15'</span>,</div><div class=\"line\">    name: <span class=\"string\">'喜洋洋抱枕'</span>,</div><div class=\"line\">    totalPrice: <span class=\"number\">204.8</span>,</div><div class=\"line\">    repayDate: <span class=\"string\">'2016.08.15'</span>,</div><div class=\"line\">    capital: <span class=\"string\">'203.5'</span>,</div><div class=\"line\">    interest: <span class=\"string\">'1.3'</span>,</div><div class=\"line\">    extra: <span class=\"string\">'0'</span>,</div><div class=\"line\">    <span class=\"keyword\">type</span>: <span class=\"string\">'消费'</span>,</div><div class=\"line\">    currentTerm: <span class=\"number\">2</span>,</div><div class=\"line\">    totalTerms: <span class=\"number\">3</span></div><div class=\"line\">  &#125;],</div><div class=\"line\">  activeOrder: &#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 相关的 mutations</span></div><div class=\"line\"><span class=\"keyword\">const</span> mutations = &#123;</div><div class=\"line\">  [SHOW_DETAIL](state, id) &#123;</div><div class=\"line\">    state.activeOrder = state.orders.find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> ele.id == id;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">  state,</div><div class=\"line\">  mutations</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>mutation-types.js:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_DETAIL = <span class=\"string\">'SHOW_DETAIL'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"5、Action\"><a href=\"#5、Action\" class=\"headerlink\" title=\"5、Action\"></a>5、Action</h3><p>Actions 是组件内用来分发 mutations 的函数。第一个参数固定为store。在这里，当用户点击账单列表的某一个账单区域的时候，要调用dispatch(‘SHOW_DETAIL’)。这里的demo只涉及到一个简单的用户事件，所以action.js也比较简单：<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// index actions</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> showDetail = makeAction(<span class=\"string\">'SHOW_DETAIL'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeAction</span>(<span class=\"params\"><span class=\"keyword\">type</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (&#123;</div><div class=\"line\">    dispatch</div><div class=\"line\">  &#125;, ...args) =&gt; dispatch(<span class=\"keyword\">type</span>, ...args)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"6、Vue组件\"><a href=\"#6、Vue组件\" class=\"headerlink\" title=\"6、Vue组件\"></a>6、Vue组件</h3><p>我们在第一步，创建入口文件main.js的时候import进来App.vue这个根组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App.vue'</span></div><div class=\"line\">...</div><div class=\"line\">router.start(App, <span class=\"string\">'#root'</span>)</div></pre></td></tr></table></figure></p>\n<p>定义App.vue也很简单，创建一个Vue实例，把vuex的store注入到根实例即可，这样组件内的所有子组件都能访问到store：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">// App.vue</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">  <span class=\"keyword\">import</span> Nav <span class=\"keyword\">from</span> <span class=\"string\">'./components/Nav.vue'</span></div><div class=\"line\">  <span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./vuex/store'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    name: <span class=\"string\">'App'</span>,</div><div class=\"line\">    <span class=\"comment\">// 注入store到根组件</span></div><div class=\"line\">    store,</div><div class=\"line\">    data() &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> &#123;&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    components: &#123;</div><div class=\"line\">      <span class=\"comment\">//子组件order-nav</span></div><div class=\"line\">      <span class=\"string\">'order-nav'</span>: Nav</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">order-nav</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">order-nav</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>这里的order-nav是一个导航栏组件，包括“最近7天待还”和“全部待还”两个，由于”全部待还”的展示和“最近7天待还”基本一样，demo里面就没有再做实现，只提供一个占位方便展示router切换。Latest.vue就是最近7天待还子组件，它获取近7天待还账单列表，并在下一级子组件(order)中渲染组件列表。组件获取store的数据是通过getter来实现的。</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"xml\">// Latest.vue</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"actionscript\"></span></div><div class=\"line\">  <span class=\"meta\"><span class=\"meta-keyword\">import</span> </span><span class=\"template-variable\">&#123; showDetail&#125;</span><span class=\"xml\"><span class=\"javascript\"> <span class=\"keyword\">from</span> <span class=\"string\">'../vuex/actions'</span>;</span></span></div><div class=\"line\">  <span class=\"keyword\">import</span> Order <span class=\"keyword\">from</span> <span class=\"string\">'./Order.vue'</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"template-variable\">&#123;</span></div><div class=\"line\">    name: 'Latest',</div><div class=\"line\"></div><div class=\"line\">    data() &#123;</div><div class=\"line\">      return &#123;</div><div class=\"line\">      &#125;<span class=\"xml\"><span class=\"undefined\"></span></span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    components:<span class=\"template-variable\">&#123;</span></div><div class=\"line\">      'order':Order</div><div class=\"line\">    &#125;<span class=\"xml\"><span class=\"undefined\">,</span></span></div><div class=\"line\">    vuex: <span class=\"template-variable\">&#123;</span></div><div class=\"line\">     //解构函数，&#123;orderList&#125;<span class=\"xml\"><span class=\"undefined\">对象指的是store的orderList模块的state.orderList</span></span></div><div class=\"line\">      getters: <span class=\"template-variable\">&#123;</span></div><div class=\"line\">        orders: (&#123;orderList&#125;<span class=\"xml\"><span class=\"actionscript\">) =&gt; orderList.orders</span></span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"comment\">//注入actoin</span></div><div class=\"line\">      actions: <span class=\"template-variable\">&#123;</span></div><div class=\"line\">        showDetail</div><div class=\"line\">      &#125;<span class=\"xml\"><span class=\"undefined\">,</span></span></div><div class=\"line\">      computed:<span class=\"template-variable\">&#123;</span></div><div class=\"line\">      &#125;<span class=\"xml\"><span class=\"undefined\"></span></span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container-fluid\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"list-unstyled row\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">order</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">order</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Order.vue是这个账单组件中负责内容显示和用户事件分发的组件模块。Order组件中包括比较详细的Vue指令语法，比如v-for,v-show,track-by等。为了增强用户体验，Order组件在用户点击账单展示详情的时候，通过定义trasitoin属性达到简单的动画切换效果。</p>\n<figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"xml\">// Order.vue</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">  <span class=\"keyword\">import</span> &#123;fold,showDetail&#125; <span class=\"keyword\">from</span> <span class=\"string\">'../vuex/actions'</span></div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    name: <span class=\"string\">'Order'</span>,</div><div class=\"line\">    vuex: &#123;</div><div class=\"line\">      getters: &#123;</div><div class=\"line\">        orders: (&#123;orderList&#125;) =&gt; orderList.orders,</div><div class=\"line\">        activeOrder:(&#123;orderList&#125;)=&gt;orderList.activeOrder</div><div class=\"line\">      &#125;,</div><div class=\"line\">      actions:&#123;</div><div class=\"line\">        showDetail</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>  <span class=\"attr\">class</span>=<span class=\"string\">\"bill\"</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"order in orders\"</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"showDetail(order.id)\"</span> <span class=\"attr\">track-by</span>=<span class=\"string\">\"id\"</span>&gt;</span></div><div class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h4</span>&gt;</span><span class=\"template-variable\">&#123;&#123;order.name&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h4</span>&gt;</span></span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>待还</div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text-danger\"</span>&gt;</span><span class=\"template-variable\">&#123;&#123;order.totalPrice&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>元&amp;nbsp;&amp;nbsp;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">small</span>&gt;</span>[<span class=\"template-variable\">&#123;&#123;order.currentTerm&#125;&#125;</span><span class=\"xml\">/</span><span class=\"template-variable\">&#123;&#123;order.totalTerms&#125;&#125;</span><span class=\"xml\">]<span class=\"tag\">&lt;/<span class=\"name\">small</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bill-detail\"</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"order.id==activeOrder.id\"</span> <span class=\"attr\">transition</span>=<span class=\"string\">\"fade\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"order-item\"</span>&gt;</span>最后还款日期：<span class=\"template-variable\">&#123;&#123;order.repayDate&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"order-item\"</span>&gt;</span>交易类型期：<span class=\"template-variable\">&#123;&#123;order.type&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"order-item\"</span>&gt;</span>应还本金：<span class=\"template-variable\">&#123;&#123;order.capital&#125;&#125;</span><span class=\"xml\">元<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"order-item\"</span>&gt;</span>应还利息：<span class=\"template-variable\">&#123;&#123;order.interest&#125;&#125;</span><span class=\"xml\">元<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"order-item\"</span>&gt;</span>手续费：<span class=\"template-variable\">&#123;&#123;order.extra&#125;&#125;</span><span class=\"xml\">元<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"order-item\"</span>&gt;</span>交易日期：<span class=\"template-variable\">&#123;&#123;order.tradeDate&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">media</span>=<span class=\"string\">\"screen\"</span>&gt;</span><span class=\"css\"></span></div><div class=\"line\"><span class=\"selector-class\">.bill</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-top</span>:<span class=\"number\">2px</span> solid <span class=\"number\">#e7e7e7</span>;</div><div class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">2px</span> solid <span class=\"number\">#e7e7e7</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">5px</span>; </div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</div><div class=\"line\">  <span class=\"attribute\">cursor</span>: pointer;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.bill-detail</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span> <span class=\"number\">10px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.order-item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">45%</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">/* 过渡效果 */</span></div><div class=\"line\"><span class=\"selector-class\">.fade-transition</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: all .<span class=\"number\">8s</span> ease;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.fade-enter</span>,</div><div class=\"line\"><span class=\"selector-class\">.fade-leave</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>最后附上的是组件导航子组件，主要是负责router路由切换的Nav.vue:</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"xml\">// Nav.vue</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"template-variable\">&#123;</span></div><div class=\"line\">    name: 'nav',</div><div class=\"line\">    vuex: &#123;</div><div class=\"line\">      getters: &#123;</div><div class=\"line\">        current: (&#123;orderList&#125;<span class=\"xml\"><span class=\"undefined\">) =&gt; orderList.activeOrder</span></span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nav</span> <span class=\"attr\">class</span>=<span class=\"string\">\"navbar navbar-default\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container-fluid\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"navbar-header\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">class</span>=<span class=\"string\">\"navbar-brand\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">v-link</span>=<span class=\"string\">\"</span></span><span class=\"template-variable\">&#123; path: '/' &#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span>&gt;</span>Vue-订单demo<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"collapse navbar-collapse\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"nav navbar-nav\"</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-link</span>=<span class=\"string\">\"</span></span><span class=\"template-variable\">&#123; path: '/latest',activeClass:'active'&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#!\"</span>&gt;</span>近7天待还 <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sr-only\"</span>&gt;</span>(current)<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-link</span>=<span class=\"string\">\"</span></span><span class=\"template-variable\">&#123; path: '/all',activeClass:'active'&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#!\"</span>&gt;</span> 全部待还 <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>至此，我们已经一步步实现了一个基于Vue+Vuex+vue-router搭建的SPA组件demo，如果大家还没学会，可以直接去把完整的demo看一遍，喜欢的话也麻烦给个star。<a href=\"https://github.com/hugzh/vue-demo\" target=\"_blank\" rel=\"external\">点击这里</a>进入账单组件的github地址。</p>\n","excerpt":"<p>Vue作为一个构建数据驱动web界面的库，是去年最火的MVVM风格库之一。Vue的用起来有Angular的影子，把很多自定义指令注入html，又吸收了React的优点和精华。比如与Vue的配套使用的Vuex就是从Redux和Flux中借鉴了不少思路。","more":"<br>Vue从去年的下半年开始火起来，目前在Awesomes前端资源库的热度排行里面处于Top2的位置。得益于更加简洁的语法和易用性，Vue目前在社区的受欢迎度不在React之下。很多公司纷纷上手Vue了，我厂的前端团队也已经在使用Vue进行业务重构了。即将发布的Vue2.0版本也采用了和React一样的Virtual Dom技术,而且推出了前后端同构的服务端渲染框架vue-hackernews-2.0，这将会使得Vue在技术社区更加受追捧。目前<a href=\"http://rc.vuejs.org/guide/\">Vue2.0的RC文档</a>也已经出来了，可以预期，它的使用前景将会非常非常不错。</p>\n<h2 id=\"这里要讲的是啥？\"><a href=\"#这里要讲的是啥？\" class=\"headerlink\" title=\"这里要讲的是啥？\"></a>这里要讲的是啥？</h2><p>这篇文章不是普及Vue的内部实现原理，也不是要比较MVVM三大法器Angular、React和Vue的优劣。这里主要是对自己最近上手学习Vue，进行SPA开发过程中的思路总结。希望通过展示一个分期账单组件，可以对像我一样的Vue初学者提供一丁点的帮助。因为是Vue新手,如有错误之处，也欢迎各位大神批评指正。</p>\n<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><p>首先要介绍的是<a href=\"http://vuex.vuejs.org/en/index.html\">Vuex</a>这个神器。关于Vue的基本语法，可以直接打开<a href=\"https://vuejs.org.cn/guide/\">官方1.0文档</a>学习。当然，如果你想直接上手Vue2.0，也可以直接<a href=\"http://rc.vuejs.org/guide/\">访问这里</a>。</p>\n<blockquote>\n<p>Vuex 是一个专门为 Vue.js 应用所设计的集中式状态管理架构。它借鉴了 Flux 和 Redux 的设计思想，但简化了概念，并且采用了一种为能更好发挥 Vue.js 数据响应机制而专门设计的实现。</p>\n</blockquote>\n<p>也就是说，Vuex将父组件与子组件之间的props传递，组件与组件之间的消息传递集中起来管理。在一个小型应用中，我们可能不会用到Vuex，这样会把原本很简单的任务复杂化了。但是，企业级的项目都是多条业务线交叉的，如果单纯使用Vue本身的组件通信，业务组件之间复杂的关系网会让项目后期的调试和Bug跟踪非常困难，尤其是当你在构建一个SPA项目的时候。</p>\n<blockquote>\n<p>为了更好的解决在大型应用中状态的共用问题，我们需要对组件的 组件本地状态(component local state) 和 应用层级状态(application level state) 进行区分。应用级的状态不属于任何特定的组件，但每一个组件仍然可以监视(Observe)其变化从而响应式地更新 DOM。通过汇总应用的状态管理于一处，我们就不必到处传递事件。</p>\n</blockquote>\n<p>Vuex的数据流模型如下图所示：<br><img src=\"http://vuex.vuejs.org/en/vuex.png\" alt=\"vuex数据流模型\"></p>\n<ol>\n<li>用户在组件中的输入操作触发 action 调用；</li>\n<li>Actions 通过分发 mutations 来修改 store 实例的状态；</li>\n<li>Store 实例的状态变化反过来又通过 getters 被组件获知，组件获悉状态变更之后就是数据驱动的魔法——实时更新DOM状态。</li>\n</ol>\n<p>需要注意的一点是，mutation本身是一个事件系统，通过定义事件来触发Store的状态变更。mutation里面定义的函数必须是同步函数，涉及到API调用的逻辑要放到Action进行，因为Action是可以定义异步函数的。</p>\n<h2 id=\"Vue-route\"><a href=\"#Vue-route\" class=\"headerlink\" title=\"Vue-route\"></a>Vue-route</h2><p>介绍完Vuex，我们来说说<a href=\"http://router.vuejs.org/zh-cn/index.html\">vue-router</a>。vue-router是Vue官方提供的路由插件，通过vue-router配合Vuex，我们可以非常高效地开发大型SPA。vue-router最基本的作用是做SPA路由映射。<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">router.<span class=\"keyword\">map</span>(&#123;</div><div class=\"line\">    <span class=\"string\">'/foo'</span>: &#123;</div><div class=\"line\">        component: Foo</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">'/bar'</span>: &#123;</div><div class=\"line\">        component: Bar</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>上面的配置中，当访问路径”/foo”的时候，SPA就会在<router-view>挂载组件Foo，改变访问路径为 “/bar”，Bar组件就会切换到主视口。这就是一个最基本的SAP路由配置。</p>\n<h2 id=\"一步一步使用Vue构建S一个PA账单组件\"><a href=\"#一步一步使用Vue构建S一个PA账单组件\" class=\"headerlink\" title=\"一步一步使用Vue构建S一个PA账单组件\"></a>一步一步使用Vue构建S一个PA账单组件</h2><p>在简单了解了Vuex和Vue-router的基本概念之后，我们可以进入实践环节。如果还没有完全理解清楚Vue的语法和Vuex数据流的概念，可以继续多看几次官方文档，尤其是对刚接触MVVM的人来说，可能要多看几次才能对数据驱动的编程理念有更好的理解。</p>\n<h3 id=\"1、项目目录\"><a href=\"#1、项目目录\" class=\"headerlink\" title=\"1、项目目录\"></a>1、项目目录</h3><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">|-vue-demo</span></div><div class=\"line\">    <span class=\"string\">|-node_modules</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"string\">|-order</span></div><div class=\"line\">        <span class=\"string\">|-app</span></div><div class=\"line\">            <span class=\"string\">|-components</span></div><div class=\"line\">                <span class=\"string\">|-All.vue</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"string\">|-Latest.vue</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"string\">|-Nav.vue</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"string\">|-Order.vue</span></div><div class=\"line\">            <span class=\"string\">|-vuex</span></div><div class=\"line\">                <span class=\"string\">|-modules</span></div><div class=\"line\">                    <span class=\"string\">|-orderList.js</span></div><div class=\"line\">                <span class=\"string\">|-action.js</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"string\">|-mutation.js</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"string\">|-mutation-type.js</span></div><div class=\"line\"></div><div class=\"line\">                <span class=\"string\">|-store.js</span></div><div class=\"line\">            <span class=\"string\">|-App.vue</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"string\">|-main.js</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"string\">|-router.js</span></div><div class=\"line\">        <span class=\"string\">|-index.html</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"string\">|-webpack.config.js</span></div><div class=\"line\">    <span class=\"string\">|-package.json</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"string\">|-README.md</span></div></pre></td></tr></table></figure>\n<p>这个是比较推荐的项目目录结构。其中order是我们要展示的账单组件的根目录，组件目录划分为入口index.html、webpack配置文件和app文件夹。在app目录内：</p>\n<ul>\n<li>App.vue - 组件的根节点;</li>\n<li>main.js - 组件入口;</li>\n<li>router.js - 路由相关配置;</li>\n<li>component - 组件根节点下的各个子组件;</li>\n<li>vuex - 顾名思义，数据流架构vuex相关的文件，包括action、mutation和store。</li>\n</ul>\n<p>在大型项目中，组件数量多，涉及的数据流是比较复杂的。为了更好地管理store，我们又把store定义在不同的模块中，比如modules目录下的orderList就是账单列表相关的数据流。事件类型比较多的情况下，我们把事件名称定义在mutation-type中。</p>\n<h3 id=\"2、创建组件入口\"><a href=\"#2、创建组件入口\" class=\"headerlink\" title=\"2、创建组件入口\"></a>2、创建组件入口</h3><p>组件入口需要做的事情包括创建Vue组件实例、挂载插件、配置路由，main.js如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> VueRouter <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></div><div class=\"line\"><span class=\"keyword\">import</span> ConfigRouter <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span></div><div class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App.vue'</span></div><div class=\"line\"><span class=\"comment\">// import './style/order.css'</span></div><div class=\"line\">Vue.config.devtools = <span class=\"literal\">true</span></div><div class=\"line\"></div><div class=\"line\">Vue.use(VueRouter)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建vue-router实例</span></div><div class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"keyword\">new</span> VueRouter()</div><div class=\"line\"><span class=\"comment\">//配置路由</span></div><div class=\"line\">ConfigRouter(router)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 滚动到页面顶部</span></div><div class=\"line\">router.beforeEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">window</span>.scrollTo(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//全路径匹配，防止出现404</span></div><div class=\"line\">router.redirect(&#123;</div><div class=\"line\">  <span class=\"string\">'*'</span>: <span class=\"string\">'/'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">//启动APP</span></div><div class=\"line\">router.start(App, <span class=\"string\">'#root'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"3、使用vue-router配置SPA路由\"><a href=\"#3、使用vue-router配置SPA路由\" class=\"headerlink\" title=\"3、使用vue-router配置SPA路由\"></a>3、使用vue-router配置SPA路由</h3><p>账单组件的路由包括“最近7天待还”以及“全部待还”，router.js:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">export default <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(router)</span> &#123;</span></div><div class=\"line\">  router.<span class=\"keyword\">map</span>(&#123;</div><div class=\"line\">    <span class=\"string\">'/'</span>: &#123;</div><div class=\"line\">      componen<span class=\"variable\">t:</span> require(<span class=\"string\">\"./components/Latest.vue\"</span>),</div><div class=\"line\">      linkActiveClas<span class=\"variable\">s:</span> <span class=\"string\">'active'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">'/latest'</span>: &#123;</div><div class=\"line\">      componen<span class=\"variable\">t:</span> require(<span class=\"string\">\"./components/Latest.vue\"</span>),</div><div class=\"line\">      linkActiveClas<span class=\"variable\">s:</span> <span class=\"string\">'active'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">'/all'</span>: &#123;</div><div class=\"line\">      componen<span class=\"variable\">t:</span> require(<span class=\"string\">\"./components/All.vue\"</span>),</div><div class=\"line\">      linkActiveClas<span class=\"variable\">s:</span> <span class=\"string\">'active'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4、创建-Vuex-Store\"><a href=\"#4、创建-Vuex-Store\" class=\"headerlink\" title=\"4、创建 Vuex Store\"></a>4、创建 Vuex Store</h3><p>尝试列出组件用到的所有数据，在vuex目录下创建store.js文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// vuex/store.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"><span class=\"comment\">// 导入各个模块的初始状态和 mutations</span></div><div class=\"line\"><span class=\"keyword\">import</span> orderList <span class=\"keyword\">from</span> <span class=\"string\">'./modules/orderList'</span></div><div class=\"line\"></div><div class=\"line\">Vue.use(Vuex)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</div><div class=\"line\">  <span class=\"comment\">// 组合各个模块</span></div><div class=\"line\">  modules: &#123;</div><div class=\"line\">    orderList</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>由于我们把store拆分到不同的模块，所以创建store实例的时候需要引入orderList模块，它包括账单列表orders对象和当前被激活的账单对象activeOrder。需要定义的mutation只有一个”SHOW_DETAIL”,当用户点击账单列表的某一个账单的时候，SHOW_DETAIL更新store的activeOrder，表示当前被展开的账单对象。modules/orderList.js如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// vuex/modules/index.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;</div><div class=\"line\">  SHOW_DETAIL,</div><div class=\"line\">&#125; from <span class=\"string\">'../mutation-types'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 该模块的初始状态</span></div><div class=\"line\"><span class=\"keyword\">const</span> state = &#123;</div><div class=\"line\">  orders: [&#123;</div><div class=\"line\">    id: <span class=\"string\">'aedf9c25'</span>,</div><div class=\"line\">    tradeDate: <span class=\"string\">'2016.04.08'</span>,</div><div class=\"line\">    name: <span class=\"string\">'Nike跑步鞋青年版'</span>,</div><div class=\"line\">    totalPrice: <span class=\"number\">888</span>,</div><div class=\"line\">    repayDate: <span class=\"string\">'2016.08.08'</span>,</div><div class=\"line\">    capital: <span class=\"string\">'880'</span>,</div><div class=\"line\">    interest: <span class=\"string\">'5.5'</span>,</div><div class=\"line\">    extra: <span class=\"string\">'2.5'</span>,</div><div class=\"line\">    <span class=\"keyword\">type</span>: <span class=\"string\">'消费'</span>,</div><div class=\"line\">    currentTerm: <span class=\"number\">1</span>,</div><div class=\"line\">    totalTerms: <span class=\"number\">1</span></div><div class=\"line\">  &#125;, &#123;</div><div class=\"line\">    id: <span class=\"string\">'cves9chs'</span>,</div><div class=\"line\">    tradeDate: <span class=\"string\">'2016.04.10'</span>,</div><div class=\"line\">    name: <span class=\"string\">'支付宝提现'</span>,</div><div class=\"line\">    totalPrice: <span class=\"number\">773.5</span>,</div><div class=\"line\">    repayDate: <span class=\"string\">'2016.08.10'</span>,</div><div class=\"line\">    capital: <span class=\"string\">'769'</span>,</div><div class=\"line\">    interest: <span class=\"string\">'4.5'</span>,</div><div class=\"line\">    extra: <span class=\"string\">'0'</span>,</div><div class=\"line\">    <span class=\"keyword\">type</span>: <span class=\"string\">'现金'</span>,</div><div class=\"line\">    currentTerm: <span class=\"number\">1</span>,</div><div class=\"line\">    totalTerms: <span class=\"number\">4</span></div><div class=\"line\">  &#125;, &#123;</div><div class=\"line\">    id: <span class=\"string\">'deef1d3g'</span>,</div><div class=\"line\">    tradeDate: <span class=\"string\">'2016.05.15'</span>,</div><div class=\"line\">    name: <span class=\"string\">'喜洋洋抱枕'</span>,</div><div class=\"line\">    totalPrice: <span class=\"number\">204.8</span>,</div><div class=\"line\">    repayDate: <span class=\"string\">'2016.08.15'</span>,</div><div class=\"line\">    capital: <span class=\"string\">'203.5'</span>,</div><div class=\"line\">    interest: <span class=\"string\">'1.3'</span>,</div><div class=\"line\">    extra: <span class=\"string\">'0'</span>,</div><div class=\"line\">    <span class=\"keyword\">type</span>: <span class=\"string\">'消费'</span>,</div><div class=\"line\">    currentTerm: <span class=\"number\">2</span>,</div><div class=\"line\">    totalTerms: <span class=\"number\">3</span></div><div class=\"line\">  &#125;],</div><div class=\"line\">  activeOrder: &#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 相关的 mutations</span></div><div class=\"line\"><span class=\"keyword\">const</span> mutations = &#123;</div><div class=\"line\">  [SHOW_DETAIL](state, id) &#123;</div><div class=\"line\">    state.activeOrder = state.orders.find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> ele.id == id;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">  state,</div><div class=\"line\">  mutations</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>mutation-types.js:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_DETAIL = <span class=\"string\">'SHOW_DETAIL'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"5、Action\"><a href=\"#5、Action\" class=\"headerlink\" title=\"5、Action\"></a>5、Action</h3><p>Actions 是组件内用来分发 mutations 的函数。第一个参数固定为store。在这里，当用户点击账单列表的某一个账单区域的时候，要调用dispatch(‘SHOW_DETAIL’)。这里的demo只涉及到一个简单的用户事件，所以action.js也比较简单：<br><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// index actions</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> showDetail = makeAction(<span class=\"string\">'SHOW_DETAIL'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeAction</span>(<span class=\"params\"><span class=\"keyword\">type</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (&#123;</div><div class=\"line\">    dispatch</div><div class=\"line\">  &#125;, ...args) =&gt; dispatch(<span class=\"keyword\">type</span>, ...args)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"6、Vue组件\"><a href=\"#6、Vue组件\" class=\"headerlink\" title=\"6、Vue组件\"></a>6、Vue组件</h3><p>我们在第一步，创建入口文件main.js的时候import进来App.vue这个根组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App.vue'</span></div><div class=\"line\">...</div><div class=\"line\">router.start(App, <span class=\"string\">'#root'</span>)</div></pre></td></tr></table></figure></p>\n<p>定义App.vue也很简单，创建一个Vue实例，把vuex的store注入到根实例即可，这样组件内的所有子组件都能访问到store：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">// App.vue</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\">  <span class=\"keyword\">import</span> Nav <span class=\"keyword\">from</span> <span class=\"string\">'./components/Nav.vue'</span></div><div class=\"line\">  <span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./vuex/store'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    name: <span class=\"string\">'App'</span>,</div><div class=\"line\">    <span class=\"comment\">// 注入store到根组件</span></div><div class=\"line\">    store,</div><div class=\"line\">    data() &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> &#123;&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    components: &#123;</div><div class=\"line\">      <span class=\"comment\">//子组件order-nav</span></div><div class=\"line\">      <span class=\"string\">'order-nav'</span>: Nav</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">order-nav</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">order-nav</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>这里的order-nav是一个导航栏组件，包括“最近7天待还”和“全部待还”两个，由于”全部待还”的展示和“最近7天待还”基本一样，demo里面就没有再做实现，只提供一个占位方便展示router切换。Latest.vue就是最近7天待还子组件，它获取近7天待还账单列表，并在下一级子组件(order)中渲染组件列表。组件获取store的数据是通过getter来实现的。</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"xml\">// Latest.vue</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"actionscript\"></div><div class=\"line\">  <span class=\"meta\"><span class=\"meta-keyword\">import</span> </span></span></span><span class=\"template-variable\">&#123; showDetail&#125;</span><span class=\"xml\"><span class=\"javascript\"> <span class=\"keyword\">from</span> <span class=\"string\">'../vuex/actions'</span>;</div><div class=\"line\">  <span class=\"keyword\">import</span> Order <span class=\"keyword\">from</span> <span class=\"string\">'./Order.vue'</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> </span></span><span class=\"template-variable\">&#123;</div><div class=\"line\">    name: 'Latest',</div><div class=\"line\"></div><div class=\"line\">    data() &#123;</div><div class=\"line\">      return &#123;</div><div class=\"line\">      &#125;</span><span class=\"xml\"><span class=\"undefined\"></div><div class=\"line\">    &#125;,</div><div class=\"line\">    components:</span></span><span class=\"template-variable\">&#123;</div><div class=\"line\">      'order':Order</div><div class=\"line\">    &#125;</span><span class=\"xml\"><span class=\"undefined\">,</div><div class=\"line\">    vuex: </span></span><span class=\"template-variable\">&#123;</div><div class=\"line\">     //解构函数，&#123;orderList&#125;</span><span class=\"xml\"><span class=\"undefined\">对象指的是store的orderList模块的state.orderList</div><div class=\"line\">      getters: </span></span><span class=\"template-variable\">&#123;</div><div class=\"line\">        orders: (&#123;orderList&#125;</span><span class=\"xml\"><span class=\"actionscript\">) =&gt; orderList.orders</div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"comment\">//注入actoin</span></div><div class=\"line\">      actions: </span></span><span class=\"template-variable\">&#123;</div><div class=\"line\">        showDetail</div><div class=\"line\">      &#125;</span><span class=\"xml\"><span class=\"undefined\">,</div><div class=\"line\">      computed:</span></span><span class=\"template-variable\">&#123;</div><div class=\"line\">      &#125;</span><span class=\"xml\"><span class=\"undefined\"></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container-fluid\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"list-unstyled row\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">order</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">order</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></div></pre></td></tr></table></figure>\n<p>Order.vue是这个账单组件中负责内容显示和用户事件分发的组件模块。Order组件中包括比较详细的Vue指令语法，比如v-for,v-show,track-by等。为了增强用户体验，Order组件在用户点击账单展示详情的时候，通过定义trasitoin属性达到简单的动画切换效果。</p>\n<figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"xml\">// Order.vue</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\">  <span class=\"keyword\">import</span> &#123;fold,showDetail&#125; <span class=\"keyword\">from</span> <span class=\"string\">'../vuex/actions'</span></div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    name: <span class=\"string\">'Order'</span>,</div><div class=\"line\">    vuex: &#123;</div><div class=\"line\">      getters: &#123;</div><div class=\"line\">        orders: (&#123;orderList&#125;) =&gt; orderList.orders,</div><div class=\"line\">        activeOrder:(&#123;orderList&#125;)=&gt;orderList.activeOrder</div><div class=\"line\">      &#125;,</div><div class=\"line\">      actions:&#123;</div><div class=\"line\">        showDetail</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>  <span class=\"attr\">class</span>=<span class=\"string\">\"bill\"</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"order in orders\"</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"showDetail(order.id)\"</span> <span class=\"attr\">track-by</span>=<span class=\"string\">\"id\"</span>&gt;</span></div><div class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h4</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123;order.name&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h4</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>待还</div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text-danger\"</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123;order.totalPrice&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>元&amp;nbsp;&amp;nbsp;</div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">small</span>&gt;</span>[</span><span class=\"template-variable\">&#123;&#123;order.currentTerm&#125;&#125;</span><span class=\"xml\">/</span><span class=\"template-variable\">&#123;&#123;order.totalTerms&#125;&#125;</span><span class=\"xml\">]<span class=\"tag\">&lt;/<span class=\"name\">small</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bill-detail\"</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"order.id==activeOrder.id\"</span> <span class=\"attr\">transition</span>=<span class=\"string\">\"fade\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"order-item\"</span>&gt;</span>最后还款日期：</span><span class=\"template-variable\">&#123;&#123;order.repayDate&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"order-item\"</span>&gt;</span>交易类型期：</span><span class=\"template-variable\">&#123;&#123;order.type&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"order-item\"</span>&gt;</span>应还本金：</span><span class=\"template-variable\">&#123;&#123;order.capital&#125;&#125;</span><span class=\"xml\">元<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"order-item\"</span>&gt;</span>应还利息：</span><span class=\"template-variable\">&#123;&#123;order.interest&#125;&#125;</span><span class=\"xml\">元<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"order-item\"</span>&gt;</span>手续费：</span><span class=\"template-variable\">&#123;&#123;order.extra&#125;&#125;</span><span class=\"xml\">元<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"order-item\"</span>&gt;</span>交易日期：</span><span class=\"template-variable\">&#123;&#123;order.tradeDate&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">media</span>=<span class=\"string\">\"screen\"</span>&gt;</span><span class=\"css\"></div><div class=\"line\"><span class=\"selector-class\">.bill</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-top</span>:<span class=\"number\">2px</span> solid <span class=\"number\">#e7e7e7</span>;</div><div class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">2px</span> solid <span class=\"number\">#e7e7e7</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">5px</span>; </div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</div><div class=\"line\">  <span class=\"attribute\">cursor</span>: pointer;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.bill-detail</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span> <span class=\"number\">10px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.order-item</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">45%</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">/* 过渡效果 */</span></div><div class=\"line\"><span class=\"selector-class\">.fade-transition</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">transition</span>: all .<span class=\"number\">8s</span> ease;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.fade-enter</span>,</div><div class=\"line\"><span class=\"selector-class\">.fade-leave</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span></div></pre></td></tr></table></figure>\n<p>最后附上的是组件导航子组件，主要是负责router路由切换的Nav.vue:</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"xml\">// Nav.vue</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> </span></span><span class=\"template-variable\">&#123;</div><div class=\"line\">    name: 'nav',</div><div class=\"line\">    vuex: &#123;</div><div class=\"line\">      getters: &#123;</div><div class=\"line\">        current: (&#123;orderList&#125;</span><span class=\"xml\"><span class=\"undefined\">) =&gt; orderList.activeOrder</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nav</span> <span class=\"attr\">class</span>=<span class=\"string\">\"navbar navbar-default\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container-fluid\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"navbar-header\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">class</span>=<span class=\"string\">\"navbar-brand\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">v-link</span>=<span class=\"string\">\"</span></span></span><span class=\"template-variable\">&#123; path: '/' &#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span>&gt;</span>Vue-订单demo<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"collapse navbar-collapse\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"nav navbar-nav\"</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-link</span>=<span class=\"string\">\"</span></span></span><span class=\"template-variable\">&#123; path: '/latest',activeClass:'active'&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#!\"</span>&gt;</span>近7天待还 <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sr-only\"</span>&gt;</span>(current)<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-link</span>=<span class=\"string\">\"</span></span></span><span class=\"template-variable\">&#123; path: '/all',activeClass:'active'&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#!\"</span>&gt;</span> 全部待还 <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></div></pre></td></tr></table></figure>\n<p>至此，我们已经一步步实现了一个基于Vue+Vuex+vue-router搭建的SPA组件demo，如果大家还没学会，可以直接去把完整的demo看一遍，喜欢的话也麻烦给个star。<a href=\"https://github.com/hugzh/vue-demo\">点击这里</a>进入账单组件的github地址。</p>"},{"title":"如何使用Cleaver制作html5幻灯","date":"2015-07-07T15:24:02.000Z","_content":"\nCleaver是一款基于html5的插件，依赖于Markdown文档格式，可以用来快速地制作幻灯片。这里主要是讲一讲如何安装和使用Cleaver制作炫酷幻灯片。\n<!--more-->\n### **1.Cleaver安装**\n\n通过nodejs来安装Cleaver，而且只支持Linux系统，windows下暂时不支持。\n\n进入新建好的文件夹demo，使用命令 npm install cleaver -g ，即可安装完成。\n\n### **2.<span style=\"color: #000000;\">Cleaver基本使用</span> **\n\n执行cleaver命令，解析一个markdown文件。用cleaver自带的例子：\n\n` cleaver node_modules/cleaver/examples/basic.md`\n\nbasic.md的内容是这样的：\n\n```javascript\ntitle: Basic Example\nauthor:\nname: Jordan Scales\ntwitter: jdan\nurl: http://jordanscales.com\noutput: basic.html\n\n--\n\n# Cleaver 101\n## A first look at quick HTML presentations\n\n--\n\n### A textual example\n\nContent can be written in **Markdown!** New lines no longer need two angle brackets.\n\nThis will be in a separate paragraph.\n\n<img src=\"http://whatismarkdown.com/workspace/img/logo.gif\" alt=\"Drawing\" style=\"width: 150px;\"/>\n\n![markdown-logo](logo.gif)\n<img src=\"logo.gif\" />\n\n[Here's a link](http://google.com).\n\n--\n\n### A list of things\n\n* Item 1\n* Item B\n* Item gamma\n\nNo need for multiple templates! [Another link](http://google.com).\n\n--\n\n### Unicode\n\n* 林花謝了春紅 太匆匆\n* 胭脂淚 留人醉 幾時重\n* Matching Pairs «»‹› “”‘’「」〈〉《》〔〕\n* Greek αβγδ εζηθ ικλμ νξοπ ρςτυ φχψω\n* currency ¤ $ ¢ € ₠ £ ¥\n\n--\n\n### A code example\n\n```javascript\n// cool looking code\nvar func = function (arg1) {\nreturn function (arg2) {\nreturn \"arg1: \" + arg1 + \"arg2: \" + arg2;\n};\n};\n\nconsole.log(func(1)(2)); // result is threeAnd here is some `inline code` to check out.\n\n```\n\n&nbsp;\n\n然后打开该目录下的basic.html即可查看幻灯\n\n[![](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/07/cleaver-firefox-300x217.png \"cleaver-firefox\")](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/07/cleaver-firefox.png)\n\n### **3.简单做一些配置：**\n\n1). title: HTML的标题名\n\n2). author: 作者信息,在最后一页显示\n\n包括下面信息：\n\n*   name: 名字\n*   url: 个人网站\n*   twitter: 微博\n*   email: 邮件地址\n3). theme: 皮肤(theme: jdan/cleaver-retro)\n\n4). style: css样式表(style: css/main.css)\n\n5). output: 生成的HTML文件名(output: basic.html)\n\n6). controls: 控制按钮(controls: true)\n\n7). progress: 顶部显示进程条(progress: true)\n\n8). agenda: 生成一个目录页(progress: false)\n\n9). encoding: 文档的字符编码(encoding: utf-8)\n\n10). template: 设置每张slide的模板(template: template/slide.mustache)\n\n11). layout: 设置HTML模板(template: template/layout.mustache)\n\n### **4.正文**\n\n正文必须使用Markdown语法。\n\n&nbsp;","source":"_posts/cleaver-make-ppt.md","raw":"title: 如何使用Cleaver制作html5幻灯\ntags:\n  - cleaver\n  - 幻灯\ncategories:\n  - 前端开发\ndate: 2015-07-07 23:24:02\n---\n\nCleaver是一款基于html5的插件，依赖于Markdown文档格式，可以用来快速地制作幻灯片。这里主要是讲一讲如何安装和使用Cleaver制作炫酷幻灯片。\n<!--more-->\n### **1.Cleaver安装**\n\n通过nodejs来安装Cleaver，而且只支持Linux系统，windows下暂时不支持。\n\n进入新建好的文件夹demo，使用命令 npm install cleaver -g ，即可安装完成。\n\n### **2.<span style=\"color: #000000;\">Cleaver基本使用</span> **\n\n执行cleaver命令，解析一个markdown文件。用cleaver自带的例子：\n\n` cleaver node_modules/cleaver/examples/basic.md`\n\nbasic.md的内容是这样的：\n\n```javascript\ntitle: Basic Example\nauthor:\nname: Jordan Scales\ntwitter: jdan\nurl: http://jordanscales.com\noutput: basic.html\n\n--\n\n# Cleaver 101\n## A first look at quick HTML presentations\n\n--\n\n### A textual example\n\nContent can be written in **Markdown!** New lines no longer need two angle brackets.\n\nThis will be in a separate paragraph.\n\n<img src=\"http://whatismarkdown.com/workspace/img/logo.gif\" alt=\"Drawing\" style=\"width: 150px;\"/>\n\n![markdown-logo](logo.gif)\n<img src=\"logo.gif\" />\n\n[Here's a link](http://google.com).\n\n--\n\n### A list of things\n\n* Item 1\n* Item B\n* Item gamma\n\nNo need for multiple templates! [Another link](http://google.com).\n\n--\n\n### Unicode\n\n* 林花謝了春紅 太匆匆\n* 胭脂淚 留人醉 幾時重\n* Matching Pairs «»‹› “”‘’「」〈〉《》〔〕\n* Greek αβγδ εζηθ ικλμ νξοπ ρςτυ φχψω\n* currency ¤ $ ¢ € ₠ £ ¥\n\n--\n\n### A code example\n\n```javascript\n// cool looking code\nvar func = function (arg1) {\nreturn function (arg2) {\nreturn \"arg1: \" + arg1 + \"arg2: \" + arg2;\n};\n};\n\nconsole.log(func(1)(2)); // result is threeAnd here is some `inline code` to check out.\n\n```\n\n&nbsp;\n\n然后打开该目录下的basic.html即可查看幻灯\n\n[![](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/07/cleaver-firefox-300x217.png \"cleaver-firefox\")](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/07/cleaver-firefox.png)\n\n### **3.简单做一些配置：**\n\n1). title: HTML的标题名\n\n2). author: 作者信息,在最后一页显示\n\n包括下面信息：\n\n*   name: 名字\n*   url: 个人网站\n*   twitter: 微博\n*   email: 邮件地址\n3). theme: 皮肤(theme: jdan/cleaver-retro)\n\n4). style: css样式表(style: css/main.css)\n\n5). output: 生成的HTML文件名(output: basic.html)\n\n6). controls: 控制按钮(controls: true)\n\n7). progress: 顶部显示进程条(progress: true)\n\n8). agenda: 生成一个目录页(progress: false)\n\n9). encoding: 文档的字符编码(encoding: utf-8)\n\n10). template: 设置每张slide的模板(template: template/slide.mustache)\n\n11). layout: 设置HTML模板(template: template/layout.mustache)\n\n### **4.正文**\n\n正文必须使用Markdown语法。\n\n&nbsp;","slug":"cleaver-make-ppt","published":1,"updated":"2016-08-13T03:08:44.534Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtqw000s7kaubnhu85ta","content":"<p>Cleaver是一款基于html5的插件，依赖于Markdown文档格式，可以用来快速地制作幻灯片。这里主要是讲一讲如何安装和使用Cleaver制作炫酷幻灯片。<br><a id=\"more\"></a></p>\n<h3 id=\"1-Cleaver安装\"><a href=\"#1-Cleaver安装\" class=\"headerlink\" title=\"1.Cleaver安装\"></a><strong>1.Cleaver安装</strong></h3><p>通过nodejs来安装Cleaver，而且只支持Linux系统，windows下暂时不支持。</p>\n<p>进入新建好的文件夹demo，使用命令 npm install cleaver -g ，即可安装完成。</p>\n<h3 id=\"2-Cleaver基本使用\"><a href=\"#2-Cleaver基本使用\" class=\"headerlink\" title=\"2.Cleaver基本使用 \"></a><strong>2.<span style=\"color: #000000;\">Cleaver基本使用</span> </strong></h3><p>执行cleaver命令，解析一个markdown文件。用cleaver自带的例子：</p>\n<p><code>cleaver node_modules/cleaver/examples/basic.md</code></p>\n<p>basic.md的内容是这样的：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: Basic Example</div><div class=\"line\">author:</div><div class=\"line\">name: Jordan Scales</div><div class=\"line\">twitter: jdan</div><div class=\"line\">url: http://jordanscales.com</div><div class=\"line\">output: basic.html</div><div class=\"line\"></div><div class=\"line\">--</div><div class=\"line\"></div><div class=\"line\"># Cleaver 101</div><div class=\"line\">## A first look at quick HTML presentations</div><div class=\"line\"></div><div class=\"line\">--</div><div class=\"line\"></div><div class=\"line\">### A textual example</div><div class=\"line\"></div><div class=\"line\">Content can be written in **Markdown!** New lines no longer need two angle brackets.</div><div class=\"line\"></div><div class=\"line\">This will be in a separate paragraph.</div><div class=\"line\"></div><div class=\"line\">&lt;img src=\"http://whatismarkdown.com/workspace/img/logo.gif\" alt=\"Drawing\" style=\"width: 150px;\"/&gt;</div><div class=\"line\"></div><div class=\"line\">![markdown-logo](logo.gif)</div><div class=\"line\">&lt;img src=\"logo.gif\" /&gt;</div><div class=\"line\"></div><div class=\"line\">[Here's a link](http://google.com).</div><div class=\"line\"></div><div class=\"line\">--</div><div class=\"line\"></div><div class=\"line\">### A list of things</div><div class=\"line\"></div><div class=\"line\">* Item 1</div><div class=\"line\">* Item B</div><div class=\"line\">* Item gamma</div><div class=\"line\"></div><div class=\"line\">No need for multiple templates! [Another link](http://google.com).</div><div class=\"line\"></div><div class=\"line\">--</div><div class=\"line\"></div><div class=\"line\">### Unicode</div><div class=\"line\"></div><div class=\"line\">* 林花謝了春紅 太匆匆</div><div class=\"line\">* 胭脂淚 留人醉 幾時重</div><div class=\"line\">* Matching Pairs «»‹› “”‘’「」〈〉《》〔〕</div><div class=\"line\">* Greek αβγδ εζηθ ικλμ νξοπ ρςτυ φχψω</div><div class=\"line\">* currency ¤ $ ¢ € ₠ £ ¥</div><div class=\"line\"></div><div class=\"line\">--</div><div class=\"line\"></div><div class=\"line\">### A code example</div><div class=\"line\"></div><div class=\"line\">```javascript</div><div class=\"line\">// cool looking code</div><div class=\"line\">var func = function (arg1) &#123;</div><div class=\"line\">return function (arg2) &#123;</div><div class=\"line\">return \"arg1: \" + arg1 + \"arg2: \" + arg2;</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">console.log(func(1)(2)); // result is threeAnd here is some `inline code` to check out.</div></pre></td></tr></table></figure>\n<p>&nbsp;</p>\n<p>然后打开该目录下的basic.html即可查看幻灯</p>\n<p><a href=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/07/cleaver-firefox.png\" target=\"_blank\" rel=\"external\"><img src=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/07/cleaver-firefox-300x217.png\" alt=\"\" title=\"cleaver-firefox\"></a></p>\n<h3 id=\"3-简单做一些配置：\"><a href=\"#3-简单做一些配置：\" class=\"headerlink\" title=\"3.简单做一些配置：\"></a><strong>3.简单做一些配置：</strong></h3><p>1). title: HTML的标题名</p>\n<p>2). author: 作者信息,在最后一页显示</p>\n<p>包括下面信息：</p>\n<ul>\n<li>name: 名字</li>\n<li>url: 个人网站</li>\n<li>twitter: 微博</li>\n<li>email: 邮件地址<br>3). theme: 皮肤(theme: jdan/cleaver-retro)</li>\n</ul>\n<p>4). style: css样式表(style: css/main.css)</p>\n<p>5). output: 生成的HTML文件名(output: basic.html)</p>\n<p>6). controls: 控制按钮(controls: true)</p>\n<p>7). progress: 顶部显示进程条(progress: true)</p>\n<p>8). agenda: 生成一个目录页(progress: false)</p>\n<p>9). encoding: 文档的字符编码(encoding: utf-8)</p>\n<p>10). template: 设置每张slide的模板(template: template/slide.mustache)</p>\n<p>11). layout: 设置HTML模板(template: template/layout.mustache)</p>\n<h3 id=\"4-正文\"><a href=\"#4-正文\" class=\"headerlink\" title=\"4.正文\"></a><strong>4.正文</strong></h3><p>正文必须使用Markdown语法。</p>\n<p>&nbsp;</p>\n","excerpt":"<p>Cleaver是一款基于html5的插件，依赖于Markdown文档格式，可以用来快速地制作幻灯片。这里主要是讲一讲如何安装和使用Cleaver制作炫酷幻灯片。<br>","more":"</p>\n<h3 id=\"1-Cleaver安装\"><a href=\"#1-Cleaver安装\" class=\"headerlink\" title=\"1.Cleaver安装\"></a><strong>1.Cleaver安装</strong></h3><p>通过nodejs来安装Cleaver，而且只支持Linux系统，windows下暂时不支持。</p>\n<p>进入新建好的文件夹demo，使用命令 npm install cleaver -g ，即可安装完成。</p>\n<h3 id=\"2-Cleaver基本使用\"><a href=\"#2-Cleaver基本使用\" class=\"headerlink\" title=\"2.Cleaver基本使用 \"></a><strong>2.<span style=\"color: #000000;\">Cleaver基本使用</span> </strong></h3><p>执行cleaver命令，解析一个markdown文件。用cleaver自带的例子：</p>\n<p><code>cleaver node_modules/cleaver/examples/basic.md</code></p>\n<p>basic.md的内容是这样的：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: Basic Example</div><div class=\"line\">author:</div><div class=\"line\">name: Jordan Scales</div><div class=\"line\">twitter: jdan</div><div class=\"line\">url: http://jordanscales.com</div><div class=\"line\">output: basic.html</div><div class=\"line\"></div><div class=\"line\">--</div><div class=\"line\"></div><div class=\"line\"># Cleaver 101</div><div class=\"line\">## A first look at quick HTML presentations</div><div class=\"line\"></div><div class=\"line\">--</div><div class=\"line\"></div><div class=\"line\">### A textual example</div><div class=\"line\"></div><div class=\"line\">Content can be written in **Markdown!** New lines no longer need two angle brackets.</div><div class=\"line\"></div><div class=\"line\">This will be in a separate paragraph.</div><div class=\"line\"></div><div class=\"line\">&lt;img src=\"http://whatismarkdown.com/workspace/img/logo.gif\" alt=\"Drawing\" style=\"width: 150px;\"/&gt;</div><div class=\"line\"></div><div class=\"line\">![markdown-logo](logo.gif)</div><div class=\"line\">&lt;img src=\"logo.gif\" /&gt;</div><div class=\"line\"></div><div class=\"line\">[Here's a link](http://google.com).</div><div class=\"line\"></div><div class=\"line\">--</div><div class=\"line\"></div><div class=\"line\">### A list of things</div><div class=\"line\"></div><div class=\"line\">* Item 1</div><div class=\"line\">* Item B</div><div class=\"line\">* Item gamma</div><div class=\"line\"></div><div class=\"line\">No need for multiple templates! [Another link](http://google.com).</div><div class=\"line\"></div><div class=\"line\">--</div><div class=\"line\"></div><div class=\"line\">### Unicode</div><div class=\"line\"></div><div class=\"line\">* 林花謝了春紅 太匆匆</div><div class=\"line\">* 胭脂淚 留人醉 幾時重</div><div class=\"line\">* Matching Pairs «»‹› “”‘’「」〈〉《》〔〕</div><div class=\"line\">* Greek αβγδ εζηθ ικλμ νξοπ ρςτυ φχψω</div><div class=\"line\">* currency ¤ $ ¢ € ₠ £ ¥</div><div class=\"line\"></div><div class=\"line\">--</div><div class=\"line\"></div><div class=\"line\">### A code example</div><div class=\"line\"></div><div class=\"line\">```javascript</div><div class=\"line\">// cool looking code</div><div class=\"line\">var func = function (arg1) &#123;</div><div class=\"line\">return function (arg2) &#123;</div><div class=\"line\">return \"arg1: \" + arg1 + \"arg2: \" + arg2;</div><div class=\"line\">&#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">console.log(func(1)(2)); // result is threeAnd here is some `inline code` to check out.</div></pre></td></tr></table></figure>\n<p>&nbsp;</p>\n<p>然后打开该目录下的basic.html即可查看幻灯</p>\n<p><a href=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/07/cleaver-firefox.png\"><img src=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/07/cleaver-firefox-300x217.png\" alt=\"\" title=\"cleaver-firefox\"></a></p>\n<h3 id=\"3-简单做一些配置：\"><a href=\"#3-简单做一些配置：\" class=\"headerlink\" title=\"3.简单做一些配置：\"></a><strong>3.简单做一些配置：</strong></h3><p>1). title: HTML的标题名</p>\n<p>2). author: 作者信息,在最后一页显示</p>\n<p>包括下面信息：</p>\n<ul>\n<li>name: 名字</li>\n<li>url: 个人网站</li>\n<li>twitter: 微博</li>\n<li>email: 邮件地址<br>3). theme: 皮肤(theme: jdan/cleaver-retro)</li>\n</ul>\n<p>4). style: css样式表(style: css/main.css)</p>\n<p>5). output: 生成的HTML文件名(output: basic.html)</p>\n<p>6). controls: 控制按钮(controls: true)</p>\n<p>7). progress: 顶部显示进程条(progress: true)</p>\n<p>8). agenda: 生成一个目录页(progress: false)</p>\n<p>9). encoding: 文档的字符编码(encoding: utf-8)</p>\n<p>10). template: 设置每张slide的模板(template: template/slide.mustache)</p>\n<p>11). layout: 设置HTML模板(template: template/layout.mustache)</p>\n<h3 id=\"4-正文\"><a href=\"#4-正文\" class=\"headerlink\" title=\"4.正文\"></a><strong>4.正文</strong></h3><p>正文必须使用Markdown语法。</p>\n<p>&nbsp;</p>"},{"title":"从AJAX的使用到爬虫友好到SEO优化","id":"81","date":"2015-05-14T13:26:09.000Z","_content":"\n&nbsp;\n\n#  关于Ajax的使用注意\n\n最近做爬虫项目的时候发现一个比较值得探讨的问题：由于Ajax的无刷新加载特性，web开发者都比较喜欢使用ajax进行与服务器的数据交互。很多DOM元素都是在基本DOM文档加载完毕之后再进行加载的。这种做法虽然对用户非常友好，但是有时候对于程序（搜索引擎）来说，页面信息获取也会带来一些挑战。\n<!--more-->\n## 1.  关于异步加载\nAjax的使用是非常广泛的。作为前端开发者，我们往往喜欢JSON数据这种交互模式,所以在渲染页面的时候也倾向于使用ajax从服务器获取JSON数据，从而实现无刷新渲染。这么做对于用户体验肯定是加分的。但是大规模地使用Ajax有时候会使得爬虫很难去获得想要的数据，当然如果我们设计的网站本身就是不想要别人抓取到数据的那就另当别论（除此之外还要加上一些JS动态加载数据以及数据编码等开发方式）。\n\n我们知道，所谓的网络“爬虫” ，就是通过一些http的request模块获取某个URL对应的页面的整个html文档，然后根据一些XPath或者CSS路径语法提取出文档的DOM节点内容，从而获取想要的数据。因此，如果这个页面的重要数据是通过JS执行Ajax来实现的话，就要求爬虫自己去模拟JS事件的触发（这种情况出现最多的就是”load more“这种情景）。甚至有时候如果封装的函数和要传输的参数太过复杂的话，爬虫根本无法通过模拟事件获取最新数据。这样无形之中就会使得爬虫无法抓取更多的网页数据。也就是对爬虫不友好。当然，很多脚本语言已经实现了很多对于事件模拟的模块，但是如果在不是非常必要的情况下，我觉得还是不要滥用Ajax。 那么，爬虫在获取JSON数据的时候具体是怎样工作的呢？我这里举一个处理样例，这个例子是基于Nodejs的Osmosis插件做的爬虫处理。\n首先  ，我们先来看看这个AJAX的访问url \"http://russia.tv/video/json/menu_id/267?page=4\" ,访问这个URL得到的数据格式如图：\n\n[![](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/05/捕获-300x89.jpg \"捕获JSON\")](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/05/捕获.jpg)\n\n我们需要的仅仅是里面的'url'键对应的值，所以爬虫可以这样去提取数据：\n```\n    var json_text = JSON.parse(data.json);\n    // get flower\n    // {\"last_page\":0,\"row_list\":[{\"url\":'xxxxx'}]}\n    var urls = [];\n     _.each(json_text.row_list, function (url) {\n\n         urls.push({\n            url: url.url\n        });\n    });\n```\n## 2.搜索引擎优化(SEO)\n\n既然聊到了爬虫，那么第二个我想说的问题就是关于SEO。爬虫只是人工搜索数据的一种手段，但是更高级别的大规模数据搜索往往是谷歌百度等搜索引擎。这类的搜索引擎是使用robots来进行数据挖掘的。这就要求前端开发者需要做一些页面优化，使得自己的站点可以更好的被搜索引擎发现。这就是SEO的主要内容，比较简单的SEO方法就是添加meta标签。meta是用来在HTML文档中模拟HTTP协议的响应头报文。META标签是HTML语言HEAD区的一个辅助性标签，它位于HTML文档头部的&lt;HEAD&gt;标记和&lt;TITLE&gt;标记之间，它提供用户不可见的信息。以下是几种meta标签的用法：\n<div align=\"left\">1、&lt;meta name=\"Generator\" content=\"\"&gt;用以说明生成工具（如Microsoft FrontPage 4.0）等；</div>\n<div align=\"left\">2、&lt;meta name=\"KEYWords\"  content=\"\"&gt;向搜索引擎说明你的网页的关键词；</div>\n<div align=\"left\">3、&lt;meta name=\"DEscription\"  content=\"\"&gt;告诉搜索引擎你的站点的主要内容；</div>\n<div align=\"left\">4、&lt;meta name=\"Author\"  content=\"你的姓名\"&gt;告诉搜索引擎你的站点的制作的作者；</div>\n<div align=\"left\">5、&lt;meta name=\"Robots\"  content= \"all|none|index|noindex|follow|nofollow\"&gt;</div>\n<div align=\"left\">　 其中的属性说明如下：</div>\n<div align=\"left\">　 设定为all：文件将被检索，且页面上的链接可以被查询；</div>\n<div align=\"left\">   设定为none：文件将不被检索，且页面上的链接不可以被查询；</div>\n<div align=\"left\">   设定为index：文件将被检索；</div>\n<div align=\"left\">   设定为follow：页面上的链接可以被查询；</div>\n<div align=\"left\">   设定为noindex：文件将不被检索，但页面上的链接可以被查询；</div>\n<div align=\"left\">   设定为nofollow：文件将不被检索，页面上的链接可以被查询。</div>\n<div align=\"left\"> 还有一种比较常见的meta标签是用户社交（**Open Graph Protocol**）。我们可以发现很多网页的head里面包含&lt;meta property=\"og:title\" content=\"xxx\"&gt;这样的标签。</div>\n<div align=\"left\">Meta Property=og标签是什么呢?og是一种新的HTTP头部标记，即Open Graph Protocol。即这种协议可以让网页成为一个“富媒体对象”。</div>\n\n用了Meta Property=og标签，就是你同意了网页内容可以被其他社会化网站引用等，目前这种协议被SNS网站如Fackbook、renren采用。SNS已经成为网络上的一大热门应用，优质的内容通过分享在好友间迅速传播。为了提高站外内容的传播效率，2010年F8会议上Facebook公布 了一套开放内容协议(Open Graph Protocol)，任何网页只要遵守该协议，SNS就能从页面上提取最有效的信息并呈现给用户。\n","source":"_posts/from-ajax-to-seo.md","raw":"title: 从AJAX的使用到爬虫友好到SEO优化\ntags:\n  - SEO\n  - 爬虫\nid: 81\ncategories:\n  - Nodejs\ndate: 2015-05-14 21:26:09\n---\n\n&nbsp;\n\n#  关于Ajax的使用注意\n\n最近做爬虫项目的时候发现一个比较值得探讨的问题：由于Ajax的无刷新加载特性，web开发者都比较喜欢使用ajax进行与服务器的数据交互。很多DOM元素都是在基本DOM文档加载完毕之后再进行加载的。这种做法虽然对用户非常友好，但是有时候对于程序（搜索引擎）来说，页面信息获取也会带来一些挑战。\n<!--more-->\n## 1.  关于异步加载\nAjax的使用是非常广泛的。作为前端开发者，我们往往喜欢JSON数据这种交互模式,所以在渲染页面的时候也倾向于使用ajax从服务器获取JSON数据，从而实现无刷新渲染。这么做对于用户体验肯定是加分的。但是大规模地使用Ajax有时候会使得爬虫很难去获得想要的数据，当然如果我们设计的网站本身就是不想要别人抓取到数据的那就另当别论（除此之外还要加上一些JS动态加载数据以及数据编码等开发方式）。\n\n我们知道，所谓的网络“爬虫” ，就是通过一些http的request模块获取某个URL对应的页面的整个html文档，然后根据一些XPath或者CSS路径语法提取出文档的DOM节点内容，从而获取想要的数据。因此，如果这个页面的重要数据是通过JS执行Ajax来实现的话，就要求爬虫自己去模拟JS事件的触发（这种情况出现最多的就是”load more“这种情景）。甚至有时候如果封装的函数和要传输的参数太过复杂的话，爬虫根本无法通过模拟事件获取最新数据。这样无形之中就会使得爬虫无法抓取更多的网页数据。也就是对爬虫不友好。当然，很多脚本语言已经实现了很多对于事件模拟的模块，但是如果在不是非常必要的情况下，我觉得还是不要滥用Ajax。 那么，爬虫在获取JSON数据的时候具体是怎样工作的呢？我这里举一个处理样例，这个例子是基于Nodejs的Osmosis插件做的爬虫处理。\n首先  ，我们先来看看这个AJAX的访问url \"http://russia.tv/video/json/menu_id/267?page=4\" ,访问这个URL得到的数据格式如图：\n\n[![](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/05/捕获-300x89.jpg \"捕获JSON\")](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/05/捕获.jpg)\n\n我们需要的仅仅是里面的'url'键对应的值，所以爬虫可以这样去提取数据：\n```\n    var json_text = JSON.parse(data.json);\n    // get flower\n    // {\"last_page\":0,\"row_list\":[{\"url\":'xxxxx'}]}\n    var urls = [];\n     _.each(json_text.row_list, function (url) {\n\n         urls.push({\n            url: url.url\n        });\n    });\n```\n## 2.搜索引擎优化(SEO)\n\n既然聊到了爬虫，那么第二个我想说的问题就是关于SEO。爬虫只是人工搜索数据的一种手段，但是更高级别的大规模数据搜索往往是谷歌百度等搜索引擎。这类的搜索引擎是使用robots来进行数据挖掘的。这就要求前端开发者需要做一些页面优化，使得自己的站点可以更好的被搜索引擎发现。这就是SEO的主要内容，比较简单的SEO方法就是添加meta标签。meta是用来在HTML文档中模拟HTTP协议的响应头报文。META标签是HTML语言HEAD区的一个辅助性标签，它位于HTML文档头部的&lt;HEAD&gt;标记和&lt;TITLE&gt;标记之间，它提供用户不可见的信息。以下是几种meta标签的用法：\n<div align=\"left\">1、&lt;meta name=\"Generator\" content=\"\"&gt;用以说明生成工具（如Microsoft FrontPage 4.0）等；</div>\n<div align=\"left\">2、&lt;meta name=\"KEYWords\"  content=\"\"&gt;向搜索引擎说明你的网页的关键词；</div>\n<div align=\"left\">3、&lt;meta name=\"DEscription\"  content=\"\"&gt;告诉搜索引擎你的站点的主要内容；</div>\n<div align=\"left\">4、&lt;meta name=\"Author\"  content=\"你的姓名\"&gt;告诉搜索引擎你的站点的制作的作者；</div>\n<div align=\"left\">5、&lt;meta name=\"Robots\"  content= \"all|none|index|noindex|follow|nofollow\"&gt;</div>\n<div align=\"left\">　 其中的属性说明如下：</div>\n<div align=\"left\">　 设定为all：文件将被检索，且页面上的链接可以被查询；</div>\n<div align=\"left\">   设定为none：文件将不被检索，且页面上的链接不可以被查询；</div>\n<div align=\"left\">   设定为index：文件将被检索；</div>\n<div align=\"left\">   设定为follow：页面上的链接可以被查询；</div>\n<div align=\"left\">   设定为noindex：文件将不被检索，但页面上的链接可以被查询；</div>\n<div align=\"left\">   设定为nofollow：文件将不被检索，页面上的链接可以被查询。</div>\n<div align=\"left\"> 还有一种比较常见的meta标签是用户社交（**Open Graph Protocol**）。我们可以发现很多网页的head里面包含&lt;meta property=\"og:title\" content=\"xxx\"&gt;这样的标签。</div>\n<div align=\"left\">Meta Property=og标签是什么呢?og是一种新的HTTP头部标记，即Open Graph Protocol。即这种协议可以让网页成为一个“富媒体对象”。</div>\n\n用了Meta Property=og标签，就是你同意了网页内容可以被其他社会化网站引用等，目前这种协议被SNS网站如Fackbook、renren采用。SNS已经成为网络上的一大热门应用，优质的内容通过分享在好友间迅速传播。为了提高站外内容的传播效率，2010年F8会议上Facebook公布 了一套开放内容协议(Open Graph Protocol)，任何网页只要遵守该协议，SNS就能从页面上提取最有效的信息并呈现给用户。\n","slug":"from-ajax-to-seo","published":1,"updated":"2016-08-13T03:08:44.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtqy000v7kauqc6c26zo","content":"<p>&nbsp;</p>\n<h1 id=\"关于Ajax的使用注意\"><a href=\"#关于Ajax的使用注意\" class=\"headerlink\" title=\"关于Ajax的使用注意\"></a>关于Ajax的使用注意</h1><p>最近做爬虫项目的时候发现一个比较值得探讨的问题：由于Ajax的无刷新加载特性，web开发者都比较喜欢使用ajax进行与服务器的数据交互。很多DOM元素都是在基本DOM文档加载完毕之后再进行加载的。这种做法虽然对用户非常友好，但是有时候对于程序（搜索引擎）来说，页面信息获取也会带来一些挑战。<br><a id=\"more\"></a></p>\n<h2 id=\"1-关于异步加载\"><a href=\"#1-关于异步加载\" class=\"headerlink\" title=\"1.  关于异步加载\"></a>1.  关于异步加载</h2><p>Ajax的使用是非常广泛的。作为前端开发者，我们往往喜欢JSON数据这种交互模式,所以在渲染页面的时候也倾向于使用ajax从服务器获取JSON数据，从而实现无刷新渲染。这么做对于用户体验肯定是加分的。但是大规模地使用Ajax有时候会使得爬虫很难去获得想要的数据，当然如果我们设计的网站本身就是不想要别人抓取到数据的那就另当别论（除此之外还要加上一些JS动态加载数据以及数据编码等开发方式）。</p>\n<p>我们知道，所谓的网络“爬虫” ，就是通过一些http的request模块获取某个URL对应的页面的整个html文档，然后根据一些XPath或者CSS路径语法提取出文档的DOM节点内容，从而获取想要的数据。因此，如果这个页面的重要数据是通过JS执行Ajax来实现的话，就要求爬虫自己去模拟JS事件的触发（这种情况出现最多的就是”load more“这种情景）。甚至有时候如果封装的函数和要传输的参数太过复杂的话，爬虫根本无法通过模拟事件获取最新数据。这样无形之中就会使得爬虫无法抓取更多的网页数据。也就是对爬虫不友好。当然，很多脚本语言已经实现了很多对于事件模拟的模块，但是如果在不是非常必要的情况下，我觉得还是不要滥用Ajax。 那么，爬虫在获取JSON数据的时候具体是怎样工作的呢？我这里举一个处理样例，这个例子是基于Nodejs的Osmosis插件做的爬虫处理。<br>首先  ，我们先来看看这个AJAX的访问url “<a href=\"http://russia.tv/video/json/menu_id/267?page=4\" target=\"_blank\" rel=\"external\">http://russia.tv/video/json/menu_id/267?page=4</a>“ ,访问这个URL得到的数据格式如图：</p>\n<p><a href=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/05/捕获.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/05/捕获-300x89.jpg\" alt=\"\" title=\"捕获JSON\"></a></p>\n<p>我们需要的仅仅是里面的’url’键对应的值，所以爬虫可以这样去提取数据：<br><figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">var</span> json_text = <span class=\"built_in\">JSON</span>.parse(data.json);</div><div class=\"line\"><span class=\"comment\">// get flower</span></div><div class=\"line\"><span class=\"comment\">// &#123;\"last_page\":0,\"row_list\":[&#123;\"url\":'xxxxx'&#125;]&#125;</span></div><div class=\"line\"><span class=\"built_in\">var</span> urls = [];</div><div class=\"line\"> _.each(json_text.row_list, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">url</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">     urls.push(&#123;</div><div class=\"line\">        <span class=\"attribute\">url</span>: <span class=\"built_in\">url</span>.url</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-搜索引擎优化-SEO\"><a href=\"#2-搜索引擎优化-SEO\" class=\"headerlink\" title=\"2.搜索引擎优化(SEO)\"></a>2.搜索引擎优化(SEO)</h2><p>既然聊到了爬虫，那么第二个我想说的问题就是关于SEO。爬虫只是人工搜索数据的一种手段，但是更高级别的大规模数据搜索往往是谷歌百度等搜索引擎。这类的搜索引擎是使用robots来进行数据挖掘的。这就要求前端开发者需要做一些页面优化，使得自己的站点可以更好的被搜索引擎发现。这就是SEO的主要内容，比较简单的SEO方法就是添加meta标签。meta是用来在HTML文档中模拟HTTP协议的响应头报文。META标签是HTML语言HEAD区的一个辅助性标签，它位于HTML文档头部的&lt;HEAD&gt;标记和&lt;TITLE&gt;标记之间，它提供用户不可见的信息。以下是几种meta标签的用法：</p>\n<div align=\"left\">1、&lt;meta name=”Generator” content=””&gt;用以说明生成工具（如Microsoft FrontPage 4.0）等；</div><br><div align=\"left\">2、&lt;meta name=”KEYWords”  content=””&gt;向搜索引擎说明你的网页的关键词；</div><br><div align=\"left\">3、&lt;meta name=”DEscription”  content=””&gt;告诉搜索引擎你的站点的主要内容；</div><br><div align=\"left\">4、&lt;meta name=”Author”  content=”你的姓名”&gt;告诉搜索引擎你的站点的制作的作者；</div><br><div align=\"left\">5、&lt;meta name=”Robots”  content= “all|none|index|noindex|follow|nofollow”&gt;</div><br><div align=\"left\">　 其中的属性说明如下：</div><br><div align=\"left\">　 设定为all：文件将被检索，且页面上的链接可以被查询；</div><br><div align=\"left\">   设定为none：文件将不被检索，且页面上的链接不可以被查询；</div><br><div align=\"left\">   设定为index：文件将被检索；</div><br><div align=\"left\">   设定为follow：页面上的链接可以被查询；</div><br><div align=\"left\">   设定为noindex：文件将不被检索，但页面上的链接可以被查询；</div><br><div align=\"left\">   设定为nofollow：文件将不被检索，页面上的链接可以被查询。</div><br><div align=\"left\"> 还有一种比较常见的meta标签是用户社交（<strong>Open Graph Protocol</strong>）。我们可以发现很多网页的head里面包含&lt;meta property=”og:title” content=”xxx”&gt;这样的标签。</div><br><div align=\"left\">Meta Property=og标签是什么呢?og是一种新的HTTP头部标记，即Open Graph Protocol。即这种协议可以让网页成为一个“富媒体对象”。</div>\n\n<p>用了Meta Property=og标签，就是你同意了网页内容可以被其他社会化网站引用等，目前这种协议被SNS网站如Fackbook、renren采用。SNS已经成为网络上的一大热门应用，优质的内容通过分享在好友间迅速传播。为了提高站外内容的传播效率，2010年F8会议上Facebook公布 了一套开放内容协议(Open Graph Protocol)，任何网页只要遵守该协议，SNS就能从页面上提取最有效的信息并呈现给用户。</p>\n","excerpt":"<p>&nbsp;</p>\n<h1 id=\"关于Ajax的使用注意\"><a href=\"#关于Ajax的使用注意\" class=\"headerlink\" title=\"关于Ajax的使用注意\"></a>关于Ajax的使用注意</h1><p>最近做爬虫项目的时候发现一个比较值得探讨的问题：由于Ajax的无刷新加载特性，web开发者都比较喜欢使用ajax进行与服务器的数据交互。很多DOM元素都是在基本DOM文档加载完毕之后再进行加载的。这种做法虽然对用户非常友好，但是有时候对于程序（搜索引擎）来说，页面信息获取也会带来一些挑战。<br>","more":"</p>\n<h2 id=\"1-关于异步加载\"><a href=\"#1-关于异步加载\" class=\"headerlink\" title=\"1.  关于异步加载\"></a>1.  关于异步加载</h2><p>Ajax的使用是非常广泛的。作为前端开发者，我们往往喜欢JSON数据这种交互模式,所以在渲染页面的时候也倾向于使用ajax从服务器获取JSON数据，从而实现无刷新渲染。这么做对于用户体验肯定是加分的。但是大规模地使用Ajax有时候会使得爬虫很难去获得想要的数据，当然如果我们设计的网站本身就是不想要别人抓取到数据的那就另当别论（除此之外还要加上一些JS动态加载数据以及数据编码等开发方式）。</p>\n<p>我们知道，所谓的网络“爬虫” ，就是通过一些http的request模块获取某个URL对应的页面的整个html文档，然后根据一些XPath或者CSS路径语法提取出文档的DOM节点内容，从而获取想要的数据。因此，如果这个页面的重要数据是通过JS执行Ajax来实现的话，就要求爬虫自己去模拟JS事件的触发（这种情况出现最多的就是”load more“这种情景）。甚至有时候如果封装的函数和要传输的参数太过复杂的话，爬虫根本无法通过模拟事件获取最新数据。这样无形之中就会使得爬虫无法抓取更多的网页数据。也就是对爬虫不友好。当然，很多脚本语言已经实现了很多对于事件模拟的模块，但是如果在不是非常必要的情况下，我觉得还是不要滥用Ajax。 那么，爬虫在获取JSON数据的时候具体是怎样工作的呢？我这里举一个处理样例，这个例子是基于Nodejs的Osmosis插件做的爬虫处理。<br>首先  ，我们先来看看这个AJAX的访问url “<a href=\"http://russia.tv/video/json/menu_id/267?page=4\">http://russia.tv/video/json/menu_id/267?page=4</a>“ ,访问这个URL得到的数据格式如图：</p>\n<p><a href=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/05/捕获.jpg\"><img src=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/05/捕获-300x89.jpg\" alt=\"\" title=\"捕获JSON\"></a></p>\n<p>我们需要的仅仅是里面的’url’键对应的值，所以爬虫可以这样去提取数据：<br><figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">var</span> json_text = <span class=\"built_in\">JSON</span>.parse(data.json);</div><div class=\"line\"><span class=\"comment\">// get flower</span></div><div class=\"line\"><span class=\"comment\">// &#123;\"last_page\":0,\"row_list\":[&#123;\"url\":'xxxxx'&#125;]&#125;</span></div><div class=\"line\"><span class=\"built_in\">var</span> urls = [];</div><div class=\"line\"> _.each(json_text.row_list, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">url</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">     urls.push(&#123;</div><div class=\"line\">        <span class=\"attribute\">url</span>: <span class=\"built_in\">url</span>.url</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-搜索引擎优化-SEO\"><a href=\"#2-搜索引擎优化-SEO\" class=\"headerlink\" title=\"2.搜索引擎优化(SEO)\"></a>2.搜索引擎优化(SEO)</h2><p>既然聊到了爬虫，那么第二个我想说的问题就是关于SEO。爬虫只是人工搜索数据的一种手段，但是更高级别的大规模数据搜索往往是谷歌百度等搜索引擎。这类的搜索引擎是使用robots来进行数据挖掘的。这就要求前端开发者需要做一些页面优化，使得自己的站点可以更好的被搜索引擎发现。这就是SEO的主要内容，比较简单的SEO方法就是添加meta标签。meta是用来在HTML文档中模拟HTTP协议的响应头报文。META标签是HTML语言HEAD区的一个辅助性标签，它位于HTML文档头部的&lt;HEAD&gt;标记和&lt;TITLE&gt;标记之间，它提供用户不可见的信息。以下是几种meta标签的用法：</p>\n<div align=\"left\">1、&lt;meta name=”Generator” content=””&gt;用以说明生成工具（如Microsoft FrontPage 4.0）等；</div><br><div align=\"left\">2、&lt;meta name=”KEYWords”  content=””&gt;向搜索引擎说明你的网页的关键词；</div><br><div align=\"left\">3、&lt;meta name=”DEscription”  content=””&gt;告诉搜索引擎你的站点的主要内容；</div><br><div align=\"left\">4、&lt;meta name=”Author”  content=”你的姓名”&gt;告诉搜索引擎你的站点的制作的作者；</div><br><div align=\"left\">5、&lt;meta name=”Robots”  content= “all|none|index|noindex|follow|nofollow”&gt;</div><br><div align=\"left\">　 其中的属性说明如下：</div><br><div align=\"left\">　 设定为all：文件将被检索，且页面上的链接可以被查询；</div><br><div align=\"left\">   设定为none：文件将不被检索，且页面上的链接不可以被查询；</div><br><div align=\"left\">   设定为index：文件将被检索；</div><br><div align=\"left\">   设定为follow：页面上的链接可以被查询；</div><br><div align=\"left\">   设定为noindex：文件将不被检索，但页面上的链接可以被查询；</div><br><div align=\"left\">   设定为nofollow：文件将不被检索，页面上的链接可以被查询。</div><br><div align=\"left\"> 还有一种比较常见的meta标签是用户社交（<strong>Open Graph Protocol</strong>）。我们可以发现很多网页的head里面包含&lt;meta property=”og:title” content=”xxx”&gt;这样的标签。</div><br><div align=\"left\">Meta Property=og标签是什么呢?og是一种新的HTTP头部标记，即Open Graph Protocol。即这种协议可以让网页成为一个“富媒体对象”。</div>\n\n<p>用了Meta Property=og标签，就是你同意了网页内容可以被其他社会化网站引用等，目前这种协议被SNS网站如Fackbook、renren采用。SNS已经成为网络上的一大热门应用，优质的内容通过分享在好友间迅速传播。为了提高站外内容的传播效率，2010年F8会议上Facebook公布 了一套开放内容协议(Open Graph Protocol)，任何网页只要遵守该协议，SNS就能从页面上提取最有效的信息并呈现给用户。</p>"},{"title":"Haskell初接触感悟","date":"2014-09-02T16:00:00.000Z","_content":"\n最近选修函数程序设计这门选修课，初步接触到函数式编程语言 Haskell 的思想，在学习的过程中有意识地拿它跟Python去做一些比较，发现两者之间在元组Tuple以及List这种灵活数据类型上面有比较大的接近。但是在设计思想以及语法上面，两者又存在较大差别。先说说Haskell语言是什么东西：\n<!--more-->\nHaskell 是一门纯函数式编程语言 (purely functional programming language)。在命令式语言中执行操作需要给电脑安排一组命令，随着命令的执行，状态就会随之发生改变。例如你指派变量 a 的值为 5，而随后做了其它一些事情之后 a 就可能变成的其它值。有控制流程 (control flow)，你就可以重复执行操作。然而在纯函数式编程语言中，你不是像命令式语言那样命令电脑“要做什么”，而是通过用函数来描述出问题“是什么”，如“阶乘是指从1到某个数的乘积”，\"一个串列中数字的和\"是指把第一个数字跟剩余数字的和相加。你用宣告函数是什么的形式来写程序。另外，变量 (variable) 一旦被指定，就不可以更改了，你已经说了 a 就是 5，就不能再另说 a 是别的什么数。（译注：其实用 variable 来表达造成字义的 overloading，会让人联想到 imperative languages 中 variable 是代表状态，但在 functional languages 中 variable 是相近于数学中使用的 variable。x=5 代表 x 就是 5，不是说 x 在 5 这个状态。) 所以说，在纯函数式编程语言中的函数能做的唯一事情就是利用引数计算结果，不会产生所谓的\"副作用 (side effect)\" (译注：也就是改变非函数内部的状态，像是 imperative languages 里面动到 global variable 就是 side effect)。一开始会觉得这限制很大，不过这也是他的优点所在：若以同样的参数调用同一个函数两次，得到的结果一定是相同。这被称作“引用透明 (Referential Transparency)” (译注：这就跟数学上函数的使用一样)。如此一来编译器就可以理解程序的行为，你也很容易就能验证一个函数的正确性，继而可以将一些简单的函数组合成更复杂的函数。(来源:《Learn You a Haskell For Great Good》)也就是说，面向对象或者基于过程的程序设计语言和函数式编程语言是存在本质区别的。\nHaskell语言有什么特点呢，要记的特点（或者说优势）还是比较多的，这里介绍一两个我刚刚理解的方面。第一，灵活的数据结构——List和Tuple，关于这两种数据结构是有比较多的内建函数需要去掌握的，比如：head 返回一个 List 的头部，也就是 List 的首个元素\n\n```haskell\nghci> head [5,4,3,2,1]\n\n5\n```\n`；又比如：take 返回一个 List 的前几个元素\n\n```haskell\nghci> take 3 [5,4,3,2,1]\n[5,4,3]\nghci> take 1 [3,9,3]\n[3]\nghci> take 5 [1,2]\n[1,2]\nghci> take 0 [6,6,6]\n[]\n\n```\n\n在这里我想要分享的是关于模式匹配这一章，模式匹配是Haskell最大的特点之一，也是学习Haskell的最大难点之一（个人感觉，目前还没有完全搞懂）。\n函数的模式匹配在递归函数的运用还是比较多的，除了一种显示的匹配（类似于C语言里面的CASE）如下：\n\n```haskell\nsayMe :: (Integral a) => a -> String\nsayMe 1 = \"One!\"\nsayMe 2 = \"Two!\"\nsayMe 3 = \"Three!\"\nsayMe 4 = \"Four!\"\nsayMe 5 = \"Five!\"\nsayMe x = \"Not between 1 and 5\"\n```\n\n除此之外，比较有用的模式匹配就是x:xs这种模式，这在函数递归里面非常重要。而函数递归有事Haskell的核心内容，因此，模式匹配也就是Haskell的核心内容。以下是一个递归求和的例子\n\n```haskell\nsum' [] = 0\nsum' (x:xs) = x + sum' xs\n```\n\n在这段代码里面，现匹配列表为空的情况，余下的情况，提取出列表头部x，x加上余下列表的递归sum'函数，这样就会一直把列表里面的元素相加，知道列表为空，也就是边界条件。这就是模式匹配在函数递归里面的简单应用。至于更强大的函数功能，大家可以参考网上教程 http://learnyouahaskell-zh-tw.csie.org/zh-cn/chapters.html 去更深入的学习Haskell的精髓。","source":"_posts/haskell-introduce.md","raw":"title: Haskell初接触感悟\ncategories:\n  - 其它\ndate: 2014-09-03 00:00:00\ntags:\n---\n\n最近选修函数程序设计这门选修课，初步接触到函数式编程语言 Haskell 的思想，在学习的过程中有意识地拿它跟Python去做一些比较，发现两者之间在元组Tuple以及List这种灵活数据类型上面有比较大的接近。但是在设计思想以及语法上面，两者又存在较大差别。先说说Haskell语言是什么东西：\n<!--more-->\nHaskell 是一门纯函数式编程语言 (purely functional programming language)。在命令式语言中执行操作需要给电脑安排一组命令，随着命令的执行，状态就会随之发生改变。例如你指派变量 a 的值为 5，而随后做了其它一些事情之后 a 就可能变成的其它值。有控制流程 (control flow)，你就可以重复执行操作。然而在纯函数式编程语言中，你不是像命令式语言那样命令电脑“要做什么”，而是通过用函数来描述出问题“是什么”，如“阶乘是指从1到某个数的乘积”，\"一个串列中数字的和\"是指把第一个数字跟剩余数字的和相加。你用宣告函数是什么的形式来写程序。另外，变量 (variable) 一旦被指定，就不可以更改了，你已经说了 a 就是 5，就不能再另说 a 是别的什么数。（译注：其实用 variable 来表达造成字义的 overloading，会让人联想到 imperative languages 中 variable 是代表状态，但在 functional languages 中 variable 是相近于数学中使用的 variable。x=5 代表 x 就是 5，不是说 x 在 5 这个状态。) 所以说，在纯函数式编程语言中的函数能做的唯一事情就是利用引数计算结果，不会产生所谓的\"副作用 (side effect)\" (译注：也就是改变非函数内部的状态，像是 imperative languages 里面动到 global variable 就是 side effect)。一开始会觉得这限制很大，不过这也是他的优点所在：若以同样的参数调用同一个函数两次，得到的结果一定是相同。这被称作“引用透明 (Referential Transparency)” (译注：这就跟数学上函数的使用一样)。如此一来编译器就可以理解程序的行为，你也很容易就能验证一个函数的正确性，继而可以将一些简单的函数组合成更复杂的函数。(来源:《Learn You a Haskell For Great Good》)也就是说，面向对象或者基于过程的程序设计语言和函数式编程语言是存在本质区别的。\nHaskell语言有什么特点呢，要记的特点（或者说优势）还是比较多的，这里介绍一两个我刚刚理解的方面。第一，灵活的数据结构——List和Tuple，关于这两种数据结构是有比较多的内建函数需要去掌握的，比如：head 返回一个 List 的头部，也就是 List 的首个元素\n\n```haskell\nghci> head [5,4,3,2,1]\n\n5\n```\n`；又比如：take 返回一个 List 的前几个元素\n\n```haskell\nghci> take 3 [5,4,3,2,1]\n[5,4,3]\nghci> take 1 [3,9,3]\n[3]\nghci> take 5 [1,2]\n[1,2]\nghci> take 0 [6,6,6]\n[]\n\n```\n\n在这里我想要分享的是关于模式匹配这一章，模式匹配是Haskell最大的特点之一，也是学习Haskell的最大难点之一（个人感觉，目前还没有完全搞懂）。\n函数的模式匹配在递归函数的运用还是比较多的，除了一种显示的匹配（类似于C语言里面的CASE）如下：\n\n```haskell\nsayMe :: (Integral a) => a -> String\nsayMe 1 = \"One!\"\nsayMe 2 = \"Two!\"\nsayMe 3 = \"Three!\"\nsayMe 4 = \"Four!\"\nsayMe 5 = \"Five!\"\nsayMe x = \"Not between 1 and 5\"\n```\n\n除此之外，比较有用的模式匹配就是x:xs这种模式，这在函数递归里面非常重要。而函数递归有事Haskell的核心内容，因此，模式匹配也就是Haskell的核心内容。以下是一个递归求和的例子\n\n```haskell\nsum' [] = 0\nsum' (x:xs) = x + sum' xs\n```\n\n在这段代码里面，现匹配列表为空的情况，余下的情况，提取出列表头部x，x加上余下列表的递归sum'函数，这样就会一直把列表里面的元素相加，知道列表为空，也就是边界条件。这就是模式匹配在函数递归里面的简单应用。至于更强大的函数功能，大家可以参考网上教程 http://learnyouahaskell-zh-tw.csie.org/zh-cn/chapters.html 去更深入的学习Haskell的精髓。","slug":"haskell-introduce","published":1,"updated":"2016-08-13T03:08:44.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtqz000z7kau3dw0mgdl","content":"<p>最近选修函数程序设计这门选修课，初步接触到函数式编程语言 Haskell 的思想，在学习的过程中有意识地拿它跟Python去做一些比较，发现两者之间在元组Tuple以及List这种灵活数据类型上面有比较大的接近。但是在设计思想以及语法上面，两者又存在较大差别。先说说Haskell语言是什么东西：<br><a id=\"more\"></a><br>Haskell 是一门纯函数式编程语言 (purely functional programming language)。在命令式语言中执行操作需要给电脑安排一组命令，随着命令的执行，状态就会随之发生改变。例如你指派变量 a 的值为 5，而随后做了其它一些事情之后 a 就可能变成的其它值。有控制流程 (control flow)，你就可以重复执行操作。然而在纯函数式编程语言中，你不是像命令式语言那样命令电脑“要做什么”，而是通过用函数来描述出问题“是什么”，如“阶乘是指从1到某个数的乘积”，”一个串列中数字的和”是指把第一个数字跟剩余数字的和相加。你用宣告函数是什么的形式来写程序。另外，变量 (variable) 一旦被指定，就不可以更改了，你已经说了 a 就是 5，就不能再另说 a 是别的什么数。（译注：其实用 variable 来表达造成字义的 overloading，会让人联想到 imperative languages 中 variable 是代表状态，但在 functional languages 中 variable 是相近于数学中使用的 variable。x=5 代表 x 就是 5，不是说 x 在 5 这个状态。) 所以说，在纯函数式编程语言中的函数能做的唯一事情就是利用引数计算结果，不会产生所谓的”副作用 (side effect)” (译注：也就是改变非函数内部的状态，像是 imperative languages 里面动到 global variable 就是 side effect)。一开始会觉得这限制很大，不过这也是他的优点所在：若以同样的参数调用同一个函数两次，得到的结果一定是相同。这被称作“引用透明 (Referential Transparency)” (译注：这就跟数学上函数的使用一样)。如此一来编译器就可以理解程序的行为，你也很容易就能验证一个函数的正确性，继而可以将一些简单的函数组合成更复杂的函数。(来源:《Learn You a Haskell For Great Good》)也就是说，面向对象或者基于过程的程序设计语言和函数式编程语言是存在本质区别的。<br>Haskell语言有什么特点呢，要记的特点（或者说优势）还是比较多的，这里介绍一两个我刚刚理解的方面。第一，灵活的数据结构——List和Tuple，关于这两种数据结构是有比较多的内建函数需要去掌握的，比如：head 返回一个 List 的头部，也就是 List 的首个元素</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"title\">ghci</span>&gt; head [<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span></div></pre></td></tr></table></figure>\n<p>`；又比如：take 返回一个 List 的前几个元素</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"title\">ghci</span>&gt; take <span class=\"number\">3</span> [<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</div><div class=\"line\">[<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"title\">ghci</span>&gt; take <span class=\"number\">1</span> [<span class=\"number\">3</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>]</div><div class=\"line\">[<span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"title\">ghci</span>&gt; take <span class=\"number\">5</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>]</div><div class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>]</div><div class=\"line\"><span class=\"title\">ghci</span>&gt; take <span class=\"number\">0</span> [<span class=\"number\">6</span>,<span class=\"number\">6</span>,<span class=\"number\">6</span>]</div><div class=\"line\">[]</div></pre></td></tr></table></figure>\n<p>在这里我想要分享的是关于模式匹配这一章，模式匹配是Haskell最大的特点之一，也是学习Haskell的最大难点之一（个人感觉，目前还没有完全搞懂）。<br>函数的模式匹配在递归函数的运用还是比较多的，除了一种显示的匹配（类似于C语言里面的CASE）如下：</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"title\">sayMe</span> :: (<span class=\"type\">Integral</span> a) =&gt; a -&gt; <span class=\"type\">String</span></div><div class=\"line\"><span class=\"title\">sayMe</span> <span class=\"number\">1</span> = <span class=\"string\">\"One!\"</span></div><div class=\"line\"><span class=\"title\">sayMe</span> <span class=\"number\">2</span> = <span class=\"string\">\"Two!\"</span></div><div class=\"line\"><span class=\"title\">sayMe</span> <span class=\"number\">3</span> = <span class=\"string\">\"Three!\"</span></div><div class=\"line\"><span class=\"title\">sayMe</span> <span class=\"number\">4</span> = <span class=\"string\">\"Four!\"</span></div><div class=\"line\"><span class=\"title\">sayMe</span> <span class=\"number\">5</span> = <span class=\"string\">\"Five!\"</span></div><div class=\"line\"><span class=\"title\">sayMe</span> x = <span class=\"string\">\"Not between 1 and 5\"</span></div></pre></td></tr></table></figure>\n<p>除此之外，比较有用的模式匹配就是x:xs这种模式，这在函数递归里面非常重要。而函数递归有事Haskell的核心内容，因此，模式匹配也就是Haskell的核心内容。以下是一个递归求和的例子</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"title\">sum'</span> [] = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"title\">sum'</span> (x:xs) = x + sum' xs</div></pre></td></tr></table></figure>\n<p>在这段代码里面，现匹配列表为空的情况，余下的情况，提取出列表头部x，x加上余下列表的递归sum’函数，这样就会一直把列表里面的元素相加，知道列表为空，也就是边界条件。这就是模式匹配在函数递归里面的简单应用。至于更强大的函数功能，大家可以参考网上教程 <a href=\"http://learnyouahaskell-zh-tw.csie.org/zh-cn/chapters.html\" target=\"_blank\" rel=\"external\">http://learnyouahaskell-zh-tw.csie.org/zh-cn/chapters.html</a> 去更深入的学习Haskell的精髓。</p>\n","excerpt":"<p>最近选修函数程序设计这门选修课，初步接触到函数式编程语言 Haskell 的思想，在学习的过程中有意识地拿它跟Python去做一些比较，发现两者之间在元组Tuple以及List这种灵活数据类型上面有比较大的接近。但是在设计思想以及语法上面，两者又存在较大差别。先说说Haskell语言是什么东西：<br>","more":"<br>Haskell 是一门纯函数式编程语言 (purely functional programming language)。在命令式语言中执行操作需要给电脑安排一组命令，随着命令的执行，状态就会随之发生改变。例如你指派变量 a 的值为 5，而随后做了其它一些事情之后 a 就可能变成的其它值。有控制流程 (control flow)，你就可以重复执行操作。然而在纯函数式编程语言中，你不是像命令式语言那样命令电脑“要做什么”，而是通过用函数来描述出问题“是什么”，如“阶乘是指从1到某个数的乘积”，”一个串列中数字的和”是指把第一个数字跟剩余数字的和相加。你用宣告函数是什么的形式来写程序。另外，变量 (variable) 一旦被指定，就不可以更改了，你已经说了 a 就是 5，就不能再另说 a 是别的什么数。（译注：其实用 variable 来表达造成字义的 overloading，会让人联想到 imperative languages 中 variable 是代表状态，但在 functional languages 中 variable 是相近于数学中使用的 variable。x=5 代表 x 就是 5，不是说 x 在 5 这个状态。) 所以说，在纯函数式编程语言中的函数能做的唯一事情就是利用引数计算结果，不会产生所谓的”副作用 (side effect)” (译注：也就是改变非函数内部的状态，像是 imperative languages 里面动到 global variable 就是 side effect)。一开始会觉得这限制很大，不过这也是他的优点所在：若以同样的参数调用同一个函数两次，得到的结果一定是相同。这被称作“引用透明 (Referential Transparency)” (译注：这就跟数学上函数的使用一样)。如此一来编译器就可以理解程序的行为，你也很容易就能验证一个函数的正确性，继而可以将一些简单的函数组合成更复杂的函数。(来源:《Learn You a Haskell For Great Good》)也就是说，面向对象或者基于过程的程序设计语言和函数式编程语言是存在本质区别的。<br>Haskell语言有什么特点呢，要记的特点（或者说优势）还是比较多的，这里介绍一两个我刚刚理解的方面。第一，灵活的数据结构——List和Tuple，关于这两种数据结构是有比较多的内建函数需要去掌握的，比如：head 返回一个 List 的头部，也就是 List 的首个元素</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"title\">ghci</span>&gt; head [<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5</span></div></pre></td></tr></table></figure>\n<p>`；又比如：take 返回一个 List 的前几个元素</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"title\">ghci</span>&gt; take <span class=\"number\">3</span> [<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</div><div class=\"line\">[<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"title\">ghci</span>&gt; take <span class=\"number\">1</span> [<span class=\"number\">3</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>]</div><div class=\"line\">[<span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"title\">ghci</span>&gt; take <span class=\"number\">5</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>]</div><div class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>]</div><div class=\"line\"><span class=\"title\">ghci</span>&gt; take <span class=\"number\">0</span> [<span class=\"number\">6</span>,<span class=\"number\">6</span>,<span class=\"number\">6</span>]</div><div class=\"line\">[]</div></pre></td></tr></table></figure>\n<p>在这里我想要分享的是关于模式匹配这一章，模式匹配是Haskell最大的特点之一，也是学习Haskell的最大难点之一（个人感觉，目前还没有完全搞懂）。<br>函数的模式匹配在递归函数的运用还是比较多的，除了一种显示的匹配（类似于C语言里面的CASE）如下：</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"title\">sayMe</span> :: (<span class=\"type\">Integral</span> a) =&gt; a -&gt; <span class=\"type\">String</span></div><div class=\"line\"><span class=\"title\">sayMe</span> <span class=\"number\">1</span> = <span class=\"string\">\"One!\"</span></div><div class=\"line\"><span class=\"title\">sayMe</span> <span class=\"number\">2</span> = <span class=\"string\">\"Two!\"</span></div><div class=\"line\"><span class=\"title\">sayMe</span> <span class=\"number\">3</span> = <span class=\"string\">\"Three!\"</span></div><div class=\"line\"><span class=\"title\">sayMe</span> <span class=\"number\">4</span> = <span class=\"string\">\"Four!\"</span></div><div class=\"line\"><span class=\"title\">sayMe</span> <span class=\"number\">5</span> = <span class=\"string\">\"Five!\"</span></div><div class=\"line\"><span class=\"title\">sayMe</span> x = <span class=\"string\">\"Not between 1 and 5\"</span></div></pre></td></tr></table></figure>\n<p>除此之外，比较有用的模式匹配就是x:xs这种模式，这在函数递归里面非常重要。而函数递归有事Haskell的核心内容，因此，模式匹配也就是Haskell的核心内容。以下是一个递归求和的例子</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"title\">sum'</span> [] = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"title\">sum'</span> (x:xs) = x + sum' xs</div></pre></td></tr></table></figure>\n<p>在这段代码里面，现匹配列表为空的情况，余下的情况，提取出列表头部x，x加上余下列表的递归sum’函数，这样就会一直把列表里面的元素相加，知道列表为空，也就是边界条件。这就是模式匹配在函数递归里面的简单应用。至于更强大的函数功能，大家可以参考网上教程 <a href=\"http://learnyouahaskell-zh-tw.csie.org/zh-cn/chapters.html\">http://learnyouahaskell-zh-tw.csie.org/zh-cn/chapters.html</a> 去更深入的学习Haskell的精髓。</p>"},{"title":"HTML5里的placeholder属性","date":"2015-03-26T15:33:49.000Z","_content":"\nHTML5里新引入很多有趣的新特征；有些体现在HTML里，有些是JavaScript API，全部非常的有用。其中我最喜欢的一个特征就是文本框(INPUT)里的 placeholder 属性。placeholder属性能够让你在文本框里显示提示信息，一旦你在文本框里输入了什么信息，提示信息就会隐藏。你以前可能无数次看到这种效果，但那些大部分是用JavaScript里实现的，而现在，HTML5提供了原生支持，而且效果更好！\n<!--more-->\n## 用法:\n\n 需要做的只是在文本框的声明标签上加入 placeholder 属性。完全不需要JavaScript来创造这种效果。\n\n```\n<input type=\"text\" name=\"first_name\" placeholder=\"你的姓名...\" />\n```\n\n## 检查浏览器是否支持Placeholder属性：\n\n因为 placeholder 是一种新属性，很有必要检查一下你的浏览器是否支持它，比如IE6、IE8肯定是不支持的：\n\n```\nfunction hasPlaceholderSupport() {\n\tvar input = document.createElement('input');\n\treturn ('placeholder' in input);\n}\n```\n如果用户的浏览器不支持 placeholder 特征，你需要借助MooTools, Dojo, 或其它JavaScript工具来实现它\n\n```\n/* mootools ftw! */\nvar firstNameBox = $('first_name'),\n\tmessage = firstNameBox.get('placeholder');\nfirstNameBox.addEvents({\n\tfocus: function() {\n\t\tif(firstNameBox.value == message) { searchBox.value = ''; }\n\t},\n\tblur: function() {\n\t\tif(firstNameBox.value == '') { searchBox.value = message; }\n\t}\n});\n\n```\n\n## 可以对样式进行CSS美化：\n```\n::-webkit-input-placeholder { color:#f00; }\n::-moz-placeholder { color:#f00; } /* firefox 19+ */\n:-ms-input-placeholder { color:#f00; } /* ie */\ninput:-moz-placeholder { color:#f00; }\n\n/* individual: webkit */\n#field2::-webkit-input-placeholder { color:#00f; }\n#field3::-webkit-input-placeholder { color:#090; background:lightgreen; text-transform:uppercase; }\n#field4::-webkit-input-placeholder { font-style:italic; text-decoration:overline; letter-spacing:3px; color:#999; }\n\n/* individual: mozilla */\n#field2::-moz-placeholder { color:#00f; }\n#field3::-moz-placeholder { color:#090; background:lightgreen; text-transform:uppercase; }\n#field4::-moz-placeholder { font-style:italic; text-decoration:overline; letter-spacing:3px; color:#999; }\n```\n\n##\n你可以控制placeholder文字的字体、颜色和风格。你甚至可以将文本框的placeholder以动画方式显示。 美化你的文本框都是些看起来很小的事情，但对于一些交互式的网站来说，成功的关键就在于细节。现在IE10里也只支持placeholder了，相信越来越多的人会使用这种原生的placeholder效果。\n\n(本文转载自 http://www.webhek.com/html5-placeholder?rel=http://geek.csdn.net)\n","source":"_posts/html5-placeholder.md","raw":"title: HTML5里的placeholder属性\ntags:\n  - css\n  - html5\ncategories:\n  - 前端开发\ndate: 2015-03-26 23:33:49\n---\n\nHTML5里新引入很多有趣的新特征；有些体现在HTML里，有些是JavaScript API，全部非常的有用。其中我最喜欢的一个特征就是文本框(INPUT)里的 placeholder 属性。placeholder属性能够让你在文本框里显示提示信息，一旦你在文本框里输入了什么信息，提示信息就会隐藏。你以前可能无数次看到这种效果，但那些大部分是用JavaScript里实现的，而现在，HTML5提供了原生支持，而且效果更好！\n<!--more-->\n## 用法:\n\n 需要做的只是在文本框的声明标签上加入 placeholder 属性。完全不需要JavaScript来创造这种效果。\n\n```\n<input type=\"text\" name=\"first_name\" placeholder=\"你的姓名...\" />\n```\n\n## 检查浏览器是否支持Placeholder属性：\n\n因为 placeholder 是一种新属性，很有必要检查一下你的浏览器是否支持它，比如IE6、IE8肯定是不支持的：\n\n```\nfunction hasPlaceholderSupport() {\n\tvar input = document.createElement('input');\n\treturn ('placeholder' in input);\n}\n```\n如果用户的浏览器不支持 placeholder 特征，你需要借助MooTools, Dojo, 或其它JavaScript工具来实现它\n\n```\n/* mootools ftw! */\nvar firstNameBox = $('first_name'),\n\tmessage = firstNameBox.get('placeholder');\nfirstNameBox.addEvents({\n\tfocus: function() {\n\t\tif(firstNameBox.value == message) { searchBox.value = ''; }\n\t},\n\tblur: function() {\n\t\tif(firstNameBox.value == '') { searchBox.value = message; }\n\t}\n});\n\n```\n\n## 可以对样式进行CSS美化：\n```\n::-webkit-input-placeholder { color:#f00; }\n::-moz-placeholder { color:#f00; } /* firefox 19+ */\n:-ms-input-placeholder { color:#f00; } /* ie */\ninput:-moz-placeholder { color:#f00; }\n\n/* individual: webkit */\n#field2::-webkit-input-placeholder { color:#00f; }\n#field3::-webkit-input-placeholder { color:#090; background:lightgreen; text-transform:uppercase; }\n#field4::-webkit-input-placeholder { font-style:italic; text-decoration:overline; letter-spacing:3px; color:#999; }\n\n/* individual: mozilla */\n#field2::-moz-placeholder { color:#00f; }\n#field3::-moz-placeholder { color:#090; background:lightgreen; text-transform:uppercase; }\n#field4::-moz-placeholder { font-style:italic; text-decoration:overline; letter-spacing:3px; color:#999; }\n```\n\n##\n你可以控制placeholder文字的字体、颜色和风格。你甚至可以将文本框的placeholder以动画方式显示。 美化你的文本框都是些看起来很小的事情，但对于一些交互式的网站来说，成功的关键就在于细节。现在IE10里也只支持placeholder了，相信越来越多的人会使用这种原生的placeholder效果。\n\n(本文转载自 http://www.webhek.com/html5-placeholder?rel=http://geek.csdn.net)\n","slug":"html5-placeholder","published":1,"updated":"2016-08-13T03:08:44.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtr200117kau7ca8ubpx","content":"<p>HTML5里新引入很多有趣的新特征；有些体现在HTML里，有些是JavaScript API，全部非常的有用。其中我最喜欢的一个特征就是文本框(INPUT)里的 placeholder 属性。placeholder属性能够让你在文本框里显示提示信息，一旦你在文本框里输入了什么信息，提示信息就会隐藏。你以前可能无数次看到这种效果，但那些大部分是用JavaScript里实现的，而现在，HTML5提供了原生支持，而且效果更好！<br><a id=\"more\"></a></p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法:\"></a>用法:</h2><p> 需要做的只是在文本框的声明标签上加入 placeholder 属性。完全不需要JavaScript来创造这种效果。</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input <span class=\"class\"><span class=\"keyword\">type</span></span>=<span class=\"string\">\"text\"</span> name=<span class=\"string\">\"first_name\"</span> placeholder=<span class=\"string\">\"你的姓名...\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"检查浏览器是否支持Placeholder属性：\"><a href=\"#检查浏览器是否支持Placeholder属性：\" class=\"headerlink\" title=\"检查浏览器是否支持Placeholder属性：\"></a>检查浏览器是否支持Placeholder属性：</h2><p>因为 placeholder 是一种新属性，很有必要检查一下你的浏览器是否支持它，比如IE6、IE8肯定是不支持的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hasPlaceholderSupport</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> input = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'input'</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"string\">'placeholder'</span> <span class=\"keyword\">in</span> input);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果用户的浏览器不支持 placeholder 特征，你需要借助MooTools, Dojo, 或其它JavaScript工具来实现它</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* mootools ftw! */</span></div><div class=\"line\"><span class=\"keyword\">var</span> firstNameBox = $(<span class=\"string\">'first_name'</span>),</div><div class=\"line\">\tmessage = firstNameBox.get(<span class=\"string\">'placeholder'</span>);</div><div class=\"line\">firstNameBox.addEvents(&#123;</div><div class=\"line\">\tfocus: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(firstNameBox.value == message) &#123; searchBox.value = <span class=\"string\">''</span>; &#125;</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tblur: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(firstNameBox.value == <span class=\"string\">''</span>) &#123; searchBox.value = message; &#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"可以对样式进行CSS美化：\"><a href=\"#可以对样式进行CSS美化：\" class=\"headerlink\" title=\"可以对样式进行CSS美化：\"></a>可以对样式进行CSS美化：</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-pseudo\">::-webkit-input-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#f00</span>; &#125;</div><div class=\"line\"><span class=\"selector-pseudo\">::-moz-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#f00</span>; &#125; <span class=\"comment\">/* firefox 19+ */</span></div><div class=\"line\"><span class=\"selector-pseudo\">:-ms-input-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#f00</span>; &#125; <span class=\"comment\">/* ie */</span></div><div class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-pseudo\">:-moz-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#f00</span>; &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* individual: webkit */</span></div><div class=\"line\"><span class=\"selector-id\">#field2</span><span class=\"selector-pseudo\">::-webkit-input-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#00f</span>; &#125;</div><div class=\"line\"><span class=\"selector-id\">#field3</span><span class=\"selector-pseudo\">::-webkit-input-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#090</span>; <span class=\"attribute\">background</span>:lightgreen; <span class=\"attribute\">text-transform</span>:uppercase; &#125;</div><div class=\"line\"><span class=\"selector-id\">#field4</span><span class=\"selector-pseudo\">::-webkit-input-placeholder</span> &#123; <span class=\"attribute\">font-style</span>:italic; <span class=\"attribute\">text-decoration</span>:overline; <span class=\"attribute\">letter-spacing</span>:<span class=\"number\">3px</span>; <span class=\"attribute\">color</span>:<span class=\"number\">#999</span>; &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* individual: mozilla */</span></div><div class=\"line\"><span class=\"selector-id\">#field2</span><span class=\"selector-pseudo\">::-moz-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#00f</span>; &#125;</div><div class=\"line\"><span class=\"selector-id\">#field3</span><span class=\"selector-pseudo\">::-moz-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#090</span>; <span class=\"attribute\">background</span>:lightgreen; <span class=\"attribute\">text-transform</span>:uppercase; &#125;</div><div class=\"line\"><span class=\"selector-id\">#field4</span><span class=\"selector-pseudo\">::-moz-placeholder</span> &#123; <span class=\"attribute\">font-style</span>:italic; <span class=\"attribute\">text-decoration</span>:overline; <span class=\"attribute\">letter-spacing</span>:<span class=\"number\">3px</span>; <span class=\"attribute\">color</span>:<span class=\"number\">#999</span>; &#125;</div></pre></td></tr></table></figure>\n<p>##<br>你可以控制placeholder文字的字体、颜色和风格。你甚至可以将文本框的placeholder以动画方式显示。 美化你的文本框都是些看起来很小的事情，但对于一些交互式的网站来说，成功的关键就在于细节。现在IE10里也只支持placeholder了，相信越来越多的人会使用这种原生的placeholder效果。</p>\n<p>(本文转载自 <a href=\"http://www.webhek.com/html5-placeholder?rel=http://geek.csdn.net\" target=\"_blank\" rel=\"external\">http://www.webhek.com/html5-placeholder?rel=http://geek.csdn.net</a>)</p>\n","excerpt":"<p>HTML5里新引入很多有趣的新特征；有些体现在HTML里，有些是JavaScript API，全部非常的有用。其中我最喜欢的一个特征就是文本框(INPUT)里的 placeholder 属性。placeholder属性能够让你在文本框里显示提示信息，一旦你在文本框里输入了什么信息，提示信息就会隐藏。你以前可能无数次看到这种效果，但那些大部分是用JavaScript里实现的，而现在，HTML5提供了原生支持，而且效果更好！<br>","more":"</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法:\"></a>用法:</h2><p> 需要做的只是在文本框的声明标签上加入 placeholder 属性。完全不需要JavaScript来创造这种效果。</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input <span class=\"class\"><span class=\"keyword\">type</span></span>=<span class=\"string\">\"text\"</span> name=<span class=\"string\">\"first_name\"</span> placeholder=<span class=\"string\">\"你的姓名...\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"检查浏览器是否支持Placeholder属性：\"><a href=\"#检查浏览器是否支持Placeholder属性：\" class=\"headerlink\" title=\"检查浏览器是否支持Placeholder属性：\"></a>检查浏览器是否支持Placeholder属性：</h2><p>因为 placeholder 是一种新属性，很有必要检查一下你的浏览器是否支持它，比如IE6、IE8肯定是不支持的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hasPlaceholderSupport</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> input = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'input'</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"string\">'placeholder'</span> <span class=\"keyword\">in</span> input);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果用户的浏览器不支持 placeholder 特征，你需要借助MooTools, Dojo, 或其它JavaScript工具来实现它</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* mootools ftw! */</span></div><div class=\"line\"><span class=\"keyword\">var</span> firstNameBox = $(<span class=\"string\">'first_name'</span>),</div><div class=\"line\">\tmessage = firstNameBox.get(<span class=\"string\">'placeholder'</span>);</div><div class=\"line\">firstNameBox.addEvents(&#123;</div><div class=\"line\">\tfocus: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(firstNameBox.value == message) &#123; searchBox.value = <span class=\"string\">''</span>; &#125;</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tblur: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(firstNameBox.value == <span class=\"string\">''</span>) &#123; searchBox.value = message; &#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"可以对样式进行CSS美化：\"><a href=\"#可以对样式进行CSS美化：\" class=\"headerlink\" title=\"可以对样式进行CSS美化：\"></a>可以对样式进行CSS美化：</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-pseudo\">::-webkit-input-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#f00</span>; &#125;</div><div class=\"line\"><span class=\"selector-pseudo\">::-moz-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#f00</span>; &#125; <span class=\"comment\">/* firefox 19+ */</span></div><div class=\"line\"><span class=\"selector-pseudo\">:-ms-input-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#f00</span>; &#125; <span class=\"comment\">/* ie */</span></div><div class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-pseudo\">:-moz-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#f00</span>; &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* individual: webkit */</span></div><div class=\"line\"><span class=\"selector-id\">#field2</span><span class=\"selector-pseudo\">::-webkit-input-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#00f</span>; &#125;</div><div class=\"line\"><span class=\"selector-id\">#field3</span><span class=\"selector-pseudo\">::-webkit-input-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#090</span>; <span class=\"attribute\">background</span>:lightgreen; <span class=\"attribute\">text-transform</span>:uppercase; &#125;</div><div class=\"line\"><span class=\"selector-id\">#field4</span><span class=\"selector-pseudo\">::-webkit-input-placeholder</span> &#123; <span class=\"attribute\">font-style</span>:italic; <span class=\"attribute\">text-decoration</span>:overline; <span class=\"attribute\">letter-spacing</span>:<span class=\"number\">3px</span>; <span class=\"attribute\">color</span>:<span class=\"number\">#999</span>; &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* individual: mozilla */</span></div><div class=\"line\"><span class=\"selector-id\">#field2</span><span class=\"selector-pseudo\">::-moz-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#00f</span>; &#125;</div><div class=\"line\"><span class=\"selector-id\">#field3</span><span class=\"selector-pseudo\">::-moz-placeholder</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#090</span>; <span class=\"attribute\">background</span>:lightgreen; <span class=\"attribute\">text-transform</span>:uppercase; &#125;</div><div class=\"line\"><span class=\"selector-id\">#field4</span><span class=\"selector-pseudo\">::-moz-placeholder</span> &#123; <span class=\"attribute\">font-style</span>:italic; <span class=\"attribute\">text-decoration</span>:overline; <span class=\"attribute\">letter-spacing</span>:<span class=\"number\">3px</span>; <span class=\"attribute\">color</span>:<span class=\"number\">#999</span>; &#125;</div></pre></td></tr></table></figure>\n<p>##<br>你可以控制placeholder文字的字体、颜色和风格。你甚至可以将文本框的placeholder以动画方式显示。 美化你的文本框都是些看起来很小的事情，但对于一些交互式的网站来说，成功的关键就在于细节。现在IE10里也只支持placeholder了，相信越来越多的人会使用这种原生的placeholder效果。</p>\n<p>(本文转载自 <a href=\"http://www.webhek.com/html5-placeholder?rel=http://geek.csdn.net\">http://www.webhek.com/html5-placeholder?rel=http://geek.csdn.net</a>)</p>"},{"title":"JavaScript操作符使用注意事项","id":"54","date":"2015-03-10T16:00:00.000Z","_content":"\njavascript 的操作符运算中有很多是可以适用于不同类型的值，这是因为javascript本身是一门变量类型松散型的语言，在使用运算符的时候有很多容易出错的地方。加法和减法这两个运算符是各种开发语言中用得最多的运算符了，但是在ECMAScript中，这两个操作符却有一系列特殊行为。\n<!--more-->\n1、加法：\n如果+号的两个操作数有一个是字符串，那么就有下面的规则：\n两个操作数都是字符串的时候，那么结果就是两个字符串拼接；\n只有一个是字符串，那么将另外一个操作数转化为字符串，然后两个字符串拼接\n如果有一个操作数是对象、数值或者布尔值，则调用它们的toString()方法取得相应的字符串值，再按照上面的规则。\n\n比如:\n\n```\nvar res = 5+5; //两个数值相加，结果为10\nvar res2 = 5+“5”; //一个数值和一个字符串相加，结果为\"55\"\n```\n\n编程中常犯的一个错误就是当我们想要得到相加结果，我们很容易这么写：\n\n```\nvar num1 = 5;\nvar num2 = 10;\nvar msg = \"The sum of 5 and 10 is \" + num1 +num2; //错误结果\n```\n\n这样我们得到的结果竟然是“The sum of 5 and 10 is 510”。出现这样的情况就是因为运算规则是从左到右，前面一个加号是字符串和数值相加，根据上面的规则，结果为字符串，然后再进行下一步加法时，还是字符串和数值的相加，结果就会出现上面的错误，正确的写法是将后两个数值相加就和之后再与字符串合并，即：\n\n```\nvar num1 = 5;\nvar num2 = 10;\nvar msg = \"The sum of 5 and 10 is \" +（ num1 +num2）; // The sum of 5 and 10 is 15\n```\n2、减法：\n减法和加法类似，但是参数转换略有不同，减法的两个操作数其中一个是字符串、布尔值或者对象的时候，后台调用Number() 函数将其转换为数值再进行减法运算。比如：\n\n```\nvar res1 = 5 - true; //4，因为true被转换成1\nvar res2 = 5 - \"\"; //5，因为\"\"被转化成0\nvar res3 = 5 - \"2\"; //3，因为\"2\"被转化成数值2\n```\n\n3、相等操作符：\njavascript中==和===不一样。前一个是相等操作符，在比较之前会进行类型强制转换，也就是说true==1、null==undefined是成立的。但是后一个操作符是全等操作符，比较之前不会进行类型转换，所以全等的前提是类型和值都相等，关系才成立。\n\n还有很多类似的小细节，使用者在开发过程中一定要注意这些可能造成致命错误的细节。","source":"_posts/javascript-op.md","raw":"title: JavaScript操作符使用注意事项\nid: 54\ncategories:\n  - 前端开发\ndate: 2015-03-11 00:00:00\ntags:\n---\n\njavascript 的操作符运算中有很多是可以适用于不同类型的值，这是因为javascript本身是一门变量类型松散型的语言，在使用运算符的时候有很多容易出错的地方。加法和减法这两个运算符是各种开发语言中用得最多的运算符了，但是在ECMAScript中，这两个操作符却有一系列特殊行为。\n<!--more-->\n1、加法：\n如果+号的两个操作数有一个是字符串，那么就有下面的规则：\n两个操作数都是字符串的时候，那么结果就是两个字符串拼接；\n只有一个是字符串，那么将另外一个操作数转化为字符串，然后两个字符串拼接\n如果有一个操作数是对象、数值或者布尔值，则调用它们的toString()方法取得相应的字符串值，再按照上面的规则。\n\n比如:\n\n```\nvar res = 5+5; //两个数值相加，结果为10\nvar res2 = 5+“5”; //一个数值和一个字符串相加，结果为\"55\"\n```\n\n编程中常犯的一个错误就是当我们想要得到相加结果，我们很容易这么写：\n\n```\nvar num1 = 5;\nvar num2 = 10;\nvar msg = \"The sum of 5 and 10 is \" + num1 +num2; //错误结果\n```\n\n这样我们得到的结果竟然是“The sum of 5 and 10 is 510”。出现这样的情况就是因为运算规则是从左到右，前面一个加号是字符串和数值相加，根据上面的规则，结果为字符串，然后再进行下一步加法时，还是字符串和数值的相加，结果就会出现上面的错误，正确的写法是将后两个数值相加就和之后再与字符串合并，即：\n\n```\nvar num1 = 5;\nvar num2 = 10;\nvar msg = \"The sum of 5 and 10 is \" +（ num1 +num2）; // The sum of 5 and 10 is 15\n```\n2、减法：\n减法和加法类似，但是参数转换略有不同，减法的两个操作数其中一个是字符串、布尔值或者对象的时候，后台调用Number() 函数将其转换为数值再进行减法运算。比如：\n\n```\nvar res1 = 5 - true; //4，因为true被转换成1\nvar res2 = 5 - \"\"; //5，因为\"\"被转化成0\nvar res3 = 5 - \"2\"; //3，因为\"2\"被转化成数值2\n```\n\n3、相等操作符：\njavascript中==和===不一样。前一个是相等操作符，在比较之前会进行类型强制转换，也就是说true==1、null==undefined是成立的。但是后一个操作符是全等操作符，比较之前不会进行类型转换，所以全等的前提是类型和值都相等，关系才成立。\n\n还有很多类似的小细节，使用者在开发过程中一定要注意这些可能造成致命错误的细节。","slug":"javascript-op","published":1,"updated":"2016-08-13T03:08:44.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtr400147kauj559g8jt","content":"<p>javascript 的操作符运算中有很多是可以适用于不同类型的值，这是因为javascript本身是一门变量类型松散型的语言，在使用运算符的时候有很多容易出错的地方。加法和减法这两个运算符是各种开发语言中用得最多的运算符了，但是在ECMAScript中，这两个操作符却有一系列特殊行为。<br><a id=\"more\"></a><br>1、加法：<br>如果+号的两个操作数有一个是字符串，那么就有下面的规则：<br>两个操作数都是字符串的时候，那么结果就是两个字符串拼接；<br>只有一个是字符串，那么将另外一个操作数转化为字符串，然后两个字符串拼接<br>如果有一个操作数是对象、数值或者布尔值，则调用它们的toString()方法取得相应的字符串值，再按照上面的规则。</p>\n<p>比如:</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var res = <span class=\"number\">5</span>+<span class=\"number\">5</span>; <span class=\"comment\">//两个数值相加，结果为10</span></div><div class=\"line\">var res2 = <span class=\"number\">5</span>+“<span class=\"number\">5</span>”; <span class=\"comment\">//一个数值和一个字符串相加，结果为\"55\"</span></div></pre></td></tr></table></figure>\n<p>编程中常犯的一个错误就是当我们想要得到相加结果，我们很容易这么写：</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var <span class=\"symbol\">num1</span> = <span class=\"number\">5</span>;</div><div class=\"line\">var <span class=\"symbol\">num2</span> = <span class=\"number\">10</span>;</div><div class=\"line\">var msg = <span class=\"string\">\"The sum of 5 and 10 is \"</span> + <span class=\"symbol\">num1</span> +<span class=\"symbol\">num2</span>; <span class=\"comment\">//错误结果</span></div></pre></td></tr></table></figure>\n<p>这样我们得到的结果竟然是“The sum of 5 and 10 is 510”。出现这样的情况就是因为运算规则是从左到右，前面一个加号是字符串和数值相加，根据上面的规则，结果为字符串，然后再进行下一步加法时，还是字符串和数值的相加，结果就会出现上面的错误，正确的写法是将后两个数值相加就和之后再与字符串合并，即：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">var</span> num1 = <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"built_in\">var</span> num2 = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"built_in\">var</span> msg = <span class=\"string\">\"The sum of 5 and 10 is \"</span> +（ num1 +num2）; // The <span class=\"built_in\">sum</span> of <span class=\"number\">5</span> <span class=\"keyword\">and</span> <span class=\"number\">10</span> <span class=\"built_in\">is</span> <span class=\"number\">15</span></div></pre></td></tr></table></figure>\n<p>2、减法：<br>减法和加法类似，但是参数转换略有不同，减法的两个操作数其中一个是字符串、布尔值或者对象的时候，后台调用Number() 函数将其转换为数值再进行减法运算。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> res1 = <span class=\"number\">5</span> - <span class=\"literal\">true</span>; <span class=\"comment\">//4，因为true被转换成1</span></div><div class=\"line\"><span class=\"keyword\">var</span> res2 = <span class=\"number\">5</span> - <span class=\"string\">\"\"</span>; <span class=\"comment\">//5，因为\"\"被转化成0</span></div><div class=\"line\"><span class=\"keyword\">var</span> res3 = <span class=\"number\">5</span> - <span class=\"string\">\"2\"</span>; <span class=\"comment\">//3，因为\"2\"被转化成数值2</span></div></pre></td></tr></table></figure>\n<p>3、相等操作符：<br>javascript中==和===不一样。前一个是相等操作符，在比较之前会进行类型强制转换，也就是说true==1、null==undefined是成立的。但是后一个操作符是全等操作符，比较之前不会进行类型转换，所以全等的前提是类型和值都相等，关系才成立。</p>\n<p>还有很多类似的小细节，使用者在开发过程中一定要注意这些可能造成致命错误的细节。</p>\n","excerpt":"<p>javascript 的操作符运算中有很多是可以适用于不同类型的值，这是因为javascript本身是一门变量类型松散型的语言，在使用运算符的时候有很多容易出错的地方。加法和减法这两个运算符是各种开发语言中用得最多的运算符了，但是在ECMAScript中，这两个操作符却有一系列特殊行为。<br>","more":"<br>1、加法：<br>如果+号的两个操作数有一个是字符串，那么就有下面的规则：<br>两个操作数都是字符串的时候，那么结果就是两个字符串拼接；<br>只有一个是字符串，那么将另外一个操作数转化为字符串，然后两个字符串拼接<br>如果有一个操作数是对象、数值或者布尔值，则调用它们的toString()方法取得相应的字符串值，再按照上面的规则。</p>\n<p>比如:</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var res = <span class=\"number\">5</span>+<span class=\"number\">5</span>; <span class=\"comment\">//两个数值相加，结果为10</span></div><div class=\"line\">var res2 = <span class=\"number\">5</span>+“<span class=\"number\">5</span>”; <span class=\"comment\">//一个数值和一个字符串相加，结果为\"55\"</span></div></pre></td></tr></table></figure>\n<p>编程中常犯的一个错误就是当我们想要得到相加结果，我们很容易这么写：</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var <span class=\"symbol\">num1</span> = <span class=\"number\">5</span>;</div><div class=\"line\">var <span class=\"symbol\">num2</span> = <span class=\"number\">10</span>;</div><div class=\"line\">var msg = <span class=\"string\">\"The sum of 5 and 10 is \"</span> + <span class=\"symbol\">num1</span> +<span class=\"symbol\">num2</span>; <span class=\"comment\">//错误结果</span></div></pre></td></tr></table></figure>\n<p>这样我们得到的结果竟然是“The sum of 5 and 10 is 510”。出现这样的情况就是因为运算规则是从左到右，前面一个加号是字符串和数值相加，根据上面的规则，结果为字符串，然后再进行下一步加法时，还是字符串和数值的相加，结果就会出现上面的错误，正确的写法是将后两个数值相加就和之后再与字符串合并，即：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">var</span> num1 = <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"built_in\">var</span> num2 = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"built_in\">var</span> msg = <span class=\"string\">\"The sum of 5 and 10 is \"</span> +（ num1 +num2）; // The <span class=\"built_in\">sum</span> of <span class=\"number\">5</span> <span class=\"keyword\">and</span> <span class=\"number\">10</span> <span class=\"built_in\">is</span> <span class=\"number\">15</span></div></pre></td></tr></table></figure>\n<p>2、减法：<br>减法和加法类似，但是参数转换略有不同，减法的两个操作数其中一个是字符串、布尔值或者对象的时候，后台调用Number() 函数将其转换为数值再进行减法运算。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> res1 = <span class=\"number\">5</span> - <span class=\"literal\">true</span>; <span class=\"comment\">//4，因为true被转换成1</span></div><div class=\"line\"><span class=\"keyword\">var</span> res2 = <span class=\"number\">5</span> - <span class=\"string\">\"\"</span>; <span class=\"comment\">//5，因为\"\"被转化成0</span></div><div class=\"line\"><span class=\"keyword\">var</span> res3 = <span class=\"number\">5</span> - <span class=\"string\">\"2\"</span>; <span class=\"comment\">//3，因为\"2\"被转化成数值2</span></div></pre></td></tr></table></figure>\n<p>3、相等操作符：<br>javascript中==和===不一样。前一个是相等操作符，在比较之前会进行类型强制转换，也就是说true==1、null==undefined是成立的。但是后一个操作符是全等操作符，比较之前不会进行类型转换，所以全等的前提是类型和值都相等，关系才成立。</p>\n<p>还有很多类似的小细节，使用者在开发过程中一定要注意这些可能造成致命错误的细节。</p>"},{"title":"javascript之Location对象","date":"2015-08-15T04:55:22.000Z","_content":"\n#  Location对象\n\nlocation对象是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。location对象既是window对象的属性，也是document对象的属性，window.location和document.location是引用同一个对象。\n<!--more-->\n## location对象的所有属性\n* hash          //返回URL中的hash(#后面跟的零个或者多个字符),如果URL中不包含散列，则返回空字符串\n* host          //返回服务器的名称和端口（如果有）\n* hostname      //返回不带端口的服务器名称\n* href          //返回当前加载页面的完整URL，location对象的toString()方法也是返回这个值\n* pathname      //返回URL中的路径\n* port          //返回URL中指定的端口号，没有包含则为空\n* ptotocol      //返回这个页面使用的协议\n* search        //返回查询字符串，比如“?q=javascript”\n我想在这里讨论的是location对象的hash属性及其用法\n\n## 关于hash\n#### “#”的含义\n“#”代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如,\"http://www.example.com/index.html#print\"\n就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。\n为网页位置指定标识符，有两个方法。一是使用锚点，比如\n```html \n<a name=\"print\"></a>\n```\n二是使用id属性，比如\n```html\n<div id=\"print\" ></div>\n```\n\n#### HTTP请求不包括\"#\"\n“#”是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括“#”。在第一个“#”后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。\n\n#### 改变“#”后面的字符不触发网页重载\n单单改变“#”后的部分，浏览器只会滚动到相应位置，不会重新加载网\n\n#### 改变“#”会改变浏览器的访问历史\n每一次改变“#”后的部分，都会在浏览器的访问历史中增加一个记录，使用\"后退\"按钮，就可以回到上一个位置。\n这对于ajax应用程序特别有用，可以用不同的“#”值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。\n值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。\n\n#### 监听hash值变化的方法\n```javascript\nwindow.onhashchange = func;\n<body onhashchange=\"func();\">\nwindow.addEventListener(\"hashchange\", func, false);\n```\n其中，onhashchange是一个html5的事件。当“#”值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0+支持该事件。对于不支持onhashchange的浏览器，可以用setInterval监控location.hash的变化。\n\n#### Google抓取“#”的机制\n默认情况下，Google的网络蜘蛛忽视URL的#部分。\n但是，Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用\"#!\"，Google会自动将其后面的内容转成查询字符串_escaped_fragment_的值。","source":"_posts/javascript之Location对象.md","raw":"title: javascript之Location对象\ndate: 2015-08-15 12:55:22\ntags:\n    - hash\n    - location\ncategories:\n    - 前端开发\n---\n\n#  Location对象\n\nlocation对象是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。location对象既是window对象的属性，也是document对象的属性，window.location和document.location是引用同一个对象。\n<!--more-->\n## location对象的所有属性\n* hash          //返回URL中的hash(#后面跟的零个或者多个字符),如果URL中不包含散列，则返回空字符串\n* host          //返回服务器的名称和端口（如果有）\n* hostname      //返回不带端口的服务器名称\n* href          //返回当前加载页面的完整URL，location对象的toString()方法也是返回这个值\n* pathname      //返回URL中的路径\n* port          //返回URL中指定的端口号，没有包含则为空\n* ptotocol      //返回这个页面使用的协议\n* search        //返回查询字符串，比如“?q=javascript”\n我想在这里讨论的是location对象的hash属性及其用法\n\n## 关于hash\n#### “#”的含义\n“#”代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如,\"http://www.example.com/index.html#print\"\n就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。\n为网页位置指定标识符，有两个方法。一是使用锚点，比如\n```html \n<a name=\"print\"></a>\n```\n二是使用id属性，比如\n```html\n<div id=\"print\" ></div>\n```\n\n#### HTTP请求不包括\"#\"\n“#”是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括“#”。在第一个“#”后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。\n\n#### 改变“#”后面的字符不触发网页重载\n单单改变“#”后的部分，浏览器只会滚动到相应位置，不会重新加载网\n\n#### 改变“#”会改变浏览器的访问历史\n每一次改变“#”后的部分，都会在浏览器的访问历史中增加一个记录，使用\"后退\"按钮，就可以回到上一个位置。\n这对于ajax应用程序特别有用，可以用不同的“#”值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。\n值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。\n\n#### 监听hash值变化的方法\n```javascript\nwindow.onhashchange = func;\n<body onhashchange=\"func();\">\nwindow.addEventListener(\"hashchange\", func, false);\n```\n其中，onhashchange是一个html5的事件。当“#”值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0+支持该事件。对于不支持onhashchange的浏览器，可以用setInterval监控location.hash的变化。\n\n#### Google抓取“#”的机制\n默认情况下，Google的网络蜘蛛忽视URL的#部分。\n但是，Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用\"#!\"，Google会自动将其后面的内容转成查询字符串_escaped_fragment_的值。","slug":"javascript之Location对象","published":1,"updated":"2016-08-13T03:08:44.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtr600187kau9lflhhs2","content":"<h1 id=\"Location对象\"><a href=\"#Location对象\" class=\"headerlink\" title=\"Location对象\"></a>Location对象</h1><p>location对象是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。location对象既是window对象的属性，也是document对象的属性，window.location和document.location是引用同一个对象。<br><a id=\"more\"></a></p>\n<h2 id=\"location对象的所有属性\"><a href=\"#location对象的所有属性\" class=\"headerlink\" title=\"location对象的所有属性\"></a>location对象的所有属性</h2><ul>\n<li>hash          //返回URL中的hash(#后面跟的零个或者多个字符),如果URL中不包含散列，则返回空字符串</li>\n<li>host          //返回服务器的名称和端口（如果有）</li>\n<li>hostname      //返回不带端口的服务器名称</li>\n<li>href          //返回当前加载页面的完整URL，location对象的toString()方法也是返回这个值</li>\n<li>pathname      //返回URL中的路径</li>\n<li>port          //返回URL中指定的端口号，没有包含则为空</li>\n<li>ptotocol      //返回这个页面使用的协议</li>\n<li>search        //返回查询字符串，比如“?q=javascript”<br>我想在这里讨论的是location对象的hash属性及其用法</li>\n</ul>\n<h2 id=\"关于hash\"><a href=\"#关于hash\" class=\"headerlink\" title=\"关于hash\"></a>关于hash</h2><h4 id=\"“-”的含义\"><a href=\"#“-”的含义\" class=\"headerlink\" title=\"“#”的含义\"></a>“#”的含义</h4><p>“#”代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如,”<a href=\"http://www.example.com/index.html#print\" target=\"_blank\" rel=\"external\">http://www.example.com/index.html#print</a>“<br>就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。<br>为网页位置指定标识符，有两个方法。一是使用锚点，比如<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">name</span>=<span class=\"string\">\"print\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>二是使用id属性，比如<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"print\"</span> &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"HTTP请求不包括”-”\"><a href=\"#HTTP请求不包括”-”\" class=\"headerlink\" title=\"HTTP请求不包括”#”\"></a>HTTP请求不包括”#”</h4><p>“#”是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括“#”。在第一个“#”后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。</p>\n<h4 id=\"改变“-”后面的字符不触发网页重载\"><a href=\"#改变“-”后面的字符不触发网页重载\" class=\"headerlink\" title=\"改变“#”后面的字符不触发网页重载\"></a>改变“#”后面的字符不触发网页重载</h4><p>单单改变“#”后的部分，浏览器只会滚动到相应位置，不会重新加载网</p>\n<h4 id=\"改变“-”会改变浏览器的访问历史\"><a href=\"#改变“-”会改变浏览器的访问历史\" class=\"headerlink\" title=\"改变“#”会改变浏览器的访问历史\"></a>改变“#”会改变浏览器的访问历史</h4><p>每一次改变“#”后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置。<br>这对于ajax应用程序特别有用，可以用不同的“#”值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。<br>值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。</p>\n<h4 id=\"监听hash值变化的方法\"><a href=\"#监听hash值变化的方法\" class=\"headerlink\" title=\"监听hash值变化的方法\"></a>监听hash值变化的方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.onhashchange = func;</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onhashchange</span>=<span class=\"string\">\"func();\"</span>&gt;</span></span></div><div class=\"line\">window.addEventListener(\"hashchange\", func, false);</div></pre></td></tr></table></figure>\n<p>其中，onhashchange是一个html5的事件。当“#”值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0+支持该事件。对于不支持onhashchange的浏览器，可以用setInterval监控location.hash的变化。</p>\n<h4 id=\"Google抓取“-”的机制\"><a href=\"#Google抓取“-”的机制\" class=\"headerlink\" title=\"Google抓取“#”的机制\"></a>Google抓取“#”的机制</h4><p>默认情况下，Google的网络蜘蛛忽视URL的#部分。<br>但是，Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用”#!”，Google会自动将其后面的内容转成查询字符串_escaped<em>fragment</em>的值。</p>\n","excerpt":"<h1 id=\"Location对象\"><a href=\"#Location对象\" class=\"headerlink\" title=\"Location对象\"></a>Location对象</h1><p>location对象是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。location对象既是window对象的属性，也是document对象的属性，window.location和document.location是引用同一个对象。<br>","more":"</p>\n<h2 id=\"location对象的所有属性\"><a href=\"#location对象的所有属性\" class=\"headerlink\" title=\"location对象的所有属性\"></a>location对象的所有属性</h2><ul>\n<li>hash          //返回URL中的hash(#后面跟的零个或者多个字符),如果URL中不包含散列，则返回空字符串</li>\n<li>host          //返回服务器的名称和端口（如果有）</li>\n<li>hostname      //返回不带端口的服务器名称</li>\n<li>href          //返回当前加载页面的完整URL，location对象的toString()方法也是返回这个值</li>\n<li>pathname      //返回URL中的路径</li>\n<li>port          //返回URL中指定的端口号，没有包含则为空</li>\n<li>ptotocol      //返回这个页面使用的协议</li>\n<li>search        //返回查询字符串，比如“?q=javascript”<br>我想在这里讨论的是location对象的hash属性及其用法</li>\n</ul>\n<h2 id=\"关于hash\"><a href=\"#关于hash\" class=\"headerlink\" title=\"关于hash\"></a>关于hash</h2><h4 id=\"“-”的含义\"><a href=\"#“-”的含义\" class=\"headerlink\" title=\"“#”的含义\"></a>“#”的含义</h4><p>“#”代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如,”<a href=\"http://www.example.com/index.html#print\">http://www.example.com/index.html#print</a>“<br>就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。<br>为网页位置指定标识符，有两个方法。一是使用锚点，比如<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">name</span>=<span class=\"string\">\"print\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>二是使用id属性，比如<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"print\"</span> &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"HTTP请求不包括”-”\"><a href=\"#HTTP请求不包括”-”\" class=\"headerlink\" title=\"HTTP请求不包括”#”\"></a>HTTP请求不包括”#”</h4><p>“#”是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括“#”。在第一个“#”后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。</p>\n<h4 id=\"改变“-”后面的字符不触发网页重载\"><a href=\"#改变“-”后面的字符不触发网页重载\" class=\"headerlink\" title=\"改变“#”后面的字符不触发网页重载\"></a>改变“#”后面的字符不触发网页重载</h4><p>单单改变“#”后的部分，浏览器只会滚动到相应位置，不会重新加载网</p>\n<h4 id=\"改变“-”会改变浏览器的访问历史\"><a href=\"#改变“-”会改变浏览器的访问历史\" class=\"headerlink\" title=\"改变“#”会改变浏览器的访问历史\"></a>改变“#”会改变浏览器的访问历史</h4><p>每一次改变“#”后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置。<br>这对于ajax应用程序特别有用，可以用不同的“#”值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。<br>值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。</p>\n<h4 id=\"监听hash值变化的方法\"><a href=\"#监听hash值变化的方法\" class=\"headerlink\" title=\"监听hash值变化的方法\"></a>监听hash值变化的方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.onhashchange = func;</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onhashchange</span>=<span class=\"string\">\"func();\"</span>&gt;</span></div><div class=\"line\">window.addEventListener(\"hashchange\", func, false);</span></div></pre></td></tr></table></figure>\n<p>其中，onhashchange是一个html5的事件。当“#”值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0+支持该事件。对于不支持onhashchange的浏览器，可以用setInterval监控location.hash的变化。</p>\n<h4 id=\"Google抓取“-”的机制\"><a href=\"#Google抓取“-”的机制\" class=\"headerlink\" title=\"Google抓取“#”的机制\"></a>Google抓取“#”的机制</h4><p>默认情况下，Google的网络蜘蛛忽视URL的#部分。<br>但是，Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用”#!”，Google会自动将其后面的内容转成查询字符串_escaped<em>fragment</em>的值。</p>"},{"title":"移动前端框架jQuery Mobile 的介绍（一）","id":"48","date":"2015-01-27T16:00:00.000Z","_content":"\n简介：\njQuery Mobile 是用于创建移动 Web应用的前端开发框架，可以应用于智能手机与平板电脑。是一个比较好用的前端框架。\njMobile适用于ios，android，black berry，windows phone等主流移动终端操作系统。\n<!--more-->\njQuery Mobile 的安装：\n安装非常简单，就像jQuery的安装一样，可以直接把文件下载到本地，然后再html文件的head标签内引用，也可以直接通过\nCDN 中加载。需要包含三个文件jquery.mobile.min.css、jquery.js以及jquery.mobile.min.js。由于jMobile是自带一套UI的框架，\n所以第一个css文件是必须要包含进来的。\n\n一个简单的jMobile页面包括三个部分——header、content和footer。通过data-role来实现，比如:\n\n```\n\n<div data-role=\"header\">\n<h1>头</h1>\n</div>\n\n```\n\n```\n\n<div data-role=\"content\">\n<p>主体</p>\n</div>\n\n```\n\n```\n\n<div data-role=\"footer\">\n<h1>底部</h1>\n</div>\n\n```\n\n其中，jQuery Mobile 依赖 HTML5 data-* 属性来支持各种 UI 元素、过渡和页面结构：\ndata-role=\"page\" 是在浏览器中显示的页面。\ndata-role=\"header\" 是在页面顶部创建的工具条 (通常用于标题或者搜索按钮)\ndata-role=\"content\" 定义了页面的内容，比如文本， 图片，表单，按钮等。\ndata-role=\"footer\" 用于创建页面底部工具条。\n在这些容器中你可以添加任何 HTML 元素 - 段落, 图片, 标题, 列表等。\n\n在页面的切换方式使用data-transition来定义，可以包括从上到下滑动，从左到右滑动，抛出页面，弹窗等多种形式。\n在导航元素上，data-role=\"navbar\"加图标data-icon可以实现导航栏。每一个的导航元素可以通过class=\"ui-btn-active\"\n来实现按钮激活状态。在布局方面，可以使用网格和可折叠板块来实现复杂布局。如需创建一个可折叠的内容块，需要为\n容器添加 data-role=\"collapsible\" 属性。在容器（div）内，添加一个标题元素（H1-H6），后跟您想要进行扩展的 HTML\n标记：\n\n一个默认展开的折叠板：\n\n```\n<div data-role=\"collapsible\" data-collapsed=\"false\">\n<h1>点击我 - 我可以折叠!</h1>\n<p>I'm 现在我默认是展开的。</p>\n</div>\n\n```\n\n一个默认折叠的折叠版：\n\n```\n<div data-role=\"collapsible\">\n<h1>点击我 - 我可以折叠!</h1>\n<p>我是可折叠的内容。</p>\n</div>\n```\njMobile的列表使用非常有特色。可以在列表中添加图标。默认的列表用法如下：\n\n```\n<ul data-role=\"listview\">\n<li><a href=\"#\">列表项</a></li>\n<li><a href=\"#\">列表项</a></li>\n<li><a href=\"#\">列表项</a></li>\n</ul>\n```\n\n列表样式的圆角和边缘，使用 data-inset=\"true\" 属性设置\n列表项也可以转化为列表分割项，用来组织列表，使列表项成组。\n指定列表分割，给列表项 li 元素添加 data-role=\"list-divider\" 属性即可。\n\n\njquery Mobile提供一个非常简单的方法，实现客户端搜索功能，筛选列表的选项。只需添加 data-filter=\"true\" 属性即可:\n\n```\n<ul data-role=\"listview\" data-filter=\"true\"></ul>\n```\n\n以上的介绍时关于jMobile的最基础用法，我们在下一篇将着重介绍表单基础和事件处理。","source":"_posts/jmobile-use-1.md","raw":"title: 移动前端框架jQuery Mobile 的介绍（一）\nid: 48\ncategories:\n  - 前端开发\ndate: 2015-01-28 00:00:00\ntags:\n---\n\n简介：\njQuery Mobile 是用于创建移动 Web应用的前端开发框架，可以应用于智能手机与平板电脑。是一个比较好用的前端框架。\njMobile适用于ios，android，black berry，windows phone等主流移动终端操作系统。\n<!--more-->\njQuery Mobile 的安装：\n安装非常简单，就像jQuery的安装一样，可以直接把文件下载到本地，然后再html文件的head标签内引用，也可以直接通过\nCDN 中加载。需要包含三个文件jquery.mobile.min.css、jquery.js以及jquery.mobile.min.js。由于jMobile是自带一套UI的框架，\n所以第一个css文件是必须要包含进来的。\n\n一个简单的jMobile页面包括三个部分——header、content和footer。通过data-role来实现，比如:\n\n```\n\n<div data-role=\"header\">\n<h1>头</h1>\n</div>\n\n```\n\n```\n\n<div data-role=\"content\">\n<p>主体</p>\n</div>\n\n```\n\n```\n\n<div data-role=\"footer\">\n<h1>底部</h1>\n</div>\n\n```\n\n其中，jQuery Mobile 依赖 HTML5 data-* 属性来支持各种 UI 元素、过渡和页面结构：\ndata-role=\"page\" 是在浏览器中显示的页面。\ndata-role=\"header\" 是在页面顶部创建的工具条 (通常用于标题或者搜索按钮)\ndata-role=\"content\" 定义了页面的内容，比如文本， 图片，表单，按钮等。\ndata-role=\"footer\" 用于创建页面底部工具条。\n在这些容器中你可以添加任何 HTML 元素 - 段落, 图片, 标题, 列表等。\n\n在页面的切换方式使用data-transition来定义，可以包括从上到下滑动，从左到右滑动，抛出页面，弹窗等多种形式。\n在导航元素上，data-role=\"navbar\"加图标data-icon可以实现导航栏。每一个的导航元素可以通过class=\"ui-btn-active\"\n来实现按钮激活状态。在布局方面，可以使用网格和可折叠板块来实现复杂布局。如需创建一个可折叠的内容块，需要为\n容器添加 data-role=\"collapsible\" 属性。在容器（div）内，添加一个标题元素（H1-H6），后跟您想要进行扩展的 HTML\n标记：\n\n一个默认展开的折叠板：\n\n```\n<div data-role=\"collapsible\" data-collapsed=\"false\">\n<h1>点击我 - 我可以折叠!</h1>\n<p>I'm 现在我默认是展开的。</p>\n</div>\n\n```\n\n一个默认折叠的折叠版：\n\n```\n<div data-role=\"collapsible\">\n<h1>点击我 - 我可以折叠!</h1>\n<p>我是可折叠的内容。</p>\n</div>\n```\njMobile的列表使用非常有特色。可以在列表中添加图标。默认的列表用法如下：\n\n```\n<ul data-role=\"listview\">\n<li><a href=\"#\">列表项</a></li>\n<li><a href=\"#\">列表项</a></li>\n<li><a href=\"#\">列表项</a></li>\n</ul>\n```\n\n列表样式的圆角和边缘，使用 data-inset=\"true\" 属性设置\n列表项也可以转化为列表分割项，用来组织列表，使列表项成组。\n指定列表分割，给列表项 li 元素添加 data-role=\"list-divider\" 属性即可。\n\n\njquery Mobile提供一个非常简单的方法，实现客户端搜索功能，筛选列表的选项。只需添加 data-filter=\"true\" 属性即可:\n\n```\n<ul data-role=\"listview\" data-filter=\"true\"></ul>\n```\n\n以上的介绍时关于jMobile的最基础用法，我们在下一篇将着重介绍表单基础和事件处理。","slug":"jmobile-use-1","published":1,"updated":"2016-08-13T03:08:44.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtr9001b7kauctzhzrki","content":"<p>简介：<br>jQuery Mobile 是用于创建移动 Web应用的前端开发框架，可以应用于智能手机与平板电脑。是一个比较好用的前端框架。<br>jMobile适用于ios，android，black berry，windows phone等主流移动终端操作系统。<br><a id=\"more\"></a><br>jQuery Mobile 的安装：<br>安装非常简单，就像jQuery的安装一样，可以直接把文件下载到本地，然后再html文件的head标签内引用，也可以直接通过<br>CDN 中加载。需要包含三个文件jquery.mobile.min.css、jquery.js以及jquery.mobile.min.js。由于jMobile是自带一套UI的框架，<br>所以第一个css文件是必须要包含进来的。</p>\n<p>一个简单的jMobile页面包括三个部分——header、content和footer。通过data-role来实现，比如:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"header\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>头<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"content\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>主体<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"footer\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>底部<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>其中，jQuery Mobile 依赖 HTML5 data-* 属性来支持各种 UI 元素、过渡和页面结构：<br>data-role=”page” 是在浏览器中显示的页面。<br>data-role=”header” 是在页面顶部创建的工具条 (通常用于标题或者搜索按钮)<br>data-role=”content” 定义了页面的内容，比如文本， 图片，表单，按钮等。<br>data-role=”footer” 用于创建页面底部工具条。<br>在这些容器中你可以添加任何 HTML 元素 - 段落, 图片, 标题, 列表等。</p>\n<p>在页面的切换方式使用data-transition来定义，可以包括从上到下滑动，从左到右滑动，抛出页面，弹窗等多种形式。<br>在导航元素上，data-role=”navbar”加图标data-icon可以实现导航栏。每一个的导航元素可以通过class=”ui-btn-active”<br>来实现按钮激活状态。在布局方面，可以使用网格和可折叠板块来实现复杂布局。如需创建一个可折叠的内容块，需要为<br>容器添加 data-role=”collapsible” 属性。在容器（div）内，添加一个标题元素（H1-H6），后跟您想要进行扩展的 HTML<br>标记：</p>\n<p>一个默认展开的折叠板：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"collapsible\"</span> <span class=\"attr\">data-collapsed</span>=<span class=\"string\">\"false\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>点击我 - 我可以折叠!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>I'm 现在我默认是展开的。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>一个默认折叠的折叠版：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"collapsible\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>点击我 - 我可以折叠!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>我是可折叠的内容。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>jMobile的列表使用非常有特色。可以在列表中添加图标。默认的列表用法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul data-role=<span class=\"string\">\"listview\"</span>&gt;</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>列表项<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></div><div class=\"line\">&lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>列表项<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></div><div class=\"line\">&lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>列表项<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></div><div class=\"line\">&lt;<span class=\"regexp\">/ul&gt;</span></div></pre></td></tr></table></figure>\n<p>列表样式的圆角和边缘，使用 data-inset=”true” 属性设置<br>列表项也可以转化为列表分割项，用来组织列表，使列表项成组。<br>指定列表分割，给列表项 li 元素添加 data-role=”list-divider” 属性即可。</p>\n<p>jquery Mobile提供一个非常简单的方法，实现客户端搜索功能，筛选列表的选项。只需添加 data-filter=”true” 属性即可:</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;<span class=\"selector-tag\">ul</span> data-role=<span class=\"string\">\"listview\"</span> data-<span class=\"attribute\">filter</span>=<span class=\"string\">\"true\"</span>&gt;&lt;/ul&gt;</div></pre></td></tr></table></figure>\n<p>以上的介绍时关于jMobile的最基础用法，我们在下一篇将着重介绍表单基础和事件处理。</p>\n","excerpt":"<p>简介：<br>jQuery Mobile 是用于创建移动 Web应用的前端开发框架，可以应用于智能手机与平板电脑。是一个比较好用的前端框架。<br>jMobile适用于ios，android，black berry，windows phone等主流移动终端操作系统。<br>","more":"<br>jQuery Mobile 的安装：<br>安装非常简单，就像jQuery的安装一样，可以直接把文件下载到本地，然后再html文件的head标签内引用，也可以直接通过<br>CDN 中加载。需要包含三个文件jquery.mobile.min.css、jquery.js以及jquery.mobile.min.js。由于jMobile是自带一套UI的框架，<br>所以第一个css文件是必须要包含进来的。</p>\n<p>一个简单的jMobile页面包括三个部分——header、content和footer。通过data-role来实现，比如:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"header\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>头<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"content\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>主体<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"footer\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>底部<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>其中，jQuery Mobile 依赖 HTML5 data-* 属性来支持各种 UI 元素、过渡和页面结构：<br>data-role=”page” 是在浏览器中显示的页面。<br>data-role=”header” 是在页面顶部创建的工具条 (通常用于标题或者搜索按钮)<br>data-role=”content” 定义了页面的内容，比如文本， 图片，表单，按钮等。<br>data-role=”footer” 用于创建页面底部工具条。<br>在这些容器中你可以添加任何 HTML 元素 - 段落, 图片, 标题, 列表等。</p>\n<p>在页面的切换方式使用data-transition来定义，可以包括从上到下滑动，从左到右滑动，抛出页面，弹窗等多种形式。<br>在导航元素上，data-role=”navbar”加图标data-icon可以实现导航栏。每一个的导航元素可以通过class=”ui-btn-active”<br>来实现按钮激活状态。在布局方面，可以使用网格和可折叠板块来实现复杂布局。如需创建一个可折叠的内容块，需要为<br>容器添加 data-role=”collapsible” 属性。在容器（div）内，添加一个标题元素（H1-H6），后跟您想要进行扩展的 HTML<br>标记：</p>\n<p>一个默认展开的折叠板：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"collapsible\"</span> <span class=\"attr\">data-collapsed</span>=<span class=\"string\">\"false\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>点击我 - 我可以折叠!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>I'm 现在我默认是展开的。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>一个默认折叠的折叠版：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"collapsible\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>点击我 - 我可以折叠!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>我是可折叠的内容。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>jMobile的列表使用非常有特色。可以在列表中添加图标。默认的列表用法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul data-role=<span class=\"string\">\"listview\"</span>&gt;</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>列表项<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></div><div class=\"line\">&lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>列表项<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></div><div class=\"line\">&lt;li&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>列表项<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></div><div class=\"line\">&lt;<span class=\"regexp\">/ul&gt;</span></div></pre></td></tr></table></figure>\n<p>列表样式的圆角和边缘，使用 data-inset=”true” 属性设置<br>列表项也可以转化为列表分割项，用来组织列表，使列表项成组。<br>指定列表分割，给列表项 li 元素添加 data-role=”list-divider” 属性即可。</p>\n<p>jquery Mobile提供一个非常简单的方法，实现客户端搜索功能，筛选列表的选项。只需添加 data-filter=”true” 属性即可:</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;<span class=\"selector-tag\">ul</span> data-role=<span class=\"string\">\"listview\"</span> data-<span class=\"attribute\">filter</span>=<span class=\"string\">\"true\"</span>&gt;&lt;/ul&gt;</div></pre></td></tr></table></figure>\n<p>以上的介绍时关于jMobile的最基础用法，我们在下一篇将着重介绍表单基础和事件处理。</p>"},{"title":"移动前端框架jQuery Mobile 的介绍（二）","id":"51","date":"2015-01-28T16:00:00.000Z","_content":"\n上一篇主要是介绍了jMobile框架的基础知识，在这一篇里，我们主要是介绍\n表单应用以及基于移动端的各种events。\n<!--more-->\n## 一、表单基础：\n\n在 jQuery Mobile 中，我们可以使用下列表单控件：\n1、文本输入框\n2、搜索输入框\n3、单选按钮\n4、复选框\n5、选择菜单\n6、滑动条\n7、翻转拨动开关\n\n1~5都是和PC前端的用法一样。其中，滑动条以及翻转拨动按钮是具有移动设备特色的表单。值得注意的是，由于\nhtml5的使用，input标签的type值可以是mail、date、search，这是不同于PC端的使用，\n非常方便。如需让标签和表单元素看起来更适应宽屏，可以用带有data-role=\"fieldcontain\"\n属性的\ndiv或\nfieldset元素包围 label/form 元素：\n\n```html\n<form method=\"post\" action=\"demoform.html\">\n<div data-role=\"fieldcontain\">\n<label for=\"fname\">姓:</label>\n<input type=\"text\" name=\"fname\" id=\"fname\">\n<label for=\"lname\">名:</label>\n<input type=\"text\" name=\"lname\" id=\"lname\">\n</div>\n</form>\n\n```\n\n\n为了创建一个可以折叠的表单，可以将表单内容置于带有data-role=\"collapsible\"\n\n属性的fieldset中。\n表单滑动条的使用如下：\n\n```html\n\n<input type=\"range\" name=\"points\" id=\"points\" value=\"50\" min=\"0\" max=\"100\"/>\n```\n\n\n其中的value属性表示滑动条的默认值，min和max是滑动条的取值范围。如果想要高亮突出\n显示滑动条的值，添加 data-highlight=\"true\"。\n\n至于拨动按钮开关，用法如下：\n\n```html\n<select name=\"switch\" id=\"switch\" data-role=\"slider\">\n<option value=\"on\">On</option>\n<option value=\"off\">Off</option>\n</select>\n\n```\n\n可以在option里面添加 \"selected\" 属性来设置选项中的一个为预选中状态（高亮突出显\n示状态）。\n\n## 二、页面事件：\n\n在 jQuery Mobile 中, 使用pageinit 事件来设置代码脚本在DOM元素加载完成后开始\n执行，所以要在任何新页面加载并创建是执行脚本，就需要绑定pageinit事件：\n\n```javascript\n<script>\n$(document).on(\"pageinit\",\"#pageone\",function(){\n});\n</script>\n```\n\n点击事件：\n\n```javascript\n$(\"p\").on(\"tap\",function(){\n$(this).hide();\n});\n```\n\n长按事件：\n```javascript\n\n$(\"p\").on(\"taphold\",function(){\n$(this).hide();\n});\n```\n\n滑动事件：\n\n```javascript\n//简单滑动\n$(\"p\").on(\"swipe\",function(){\n$(\"span\").text(\"Swipe detected!\");\n});\n\n//向左滑动\n$(\"p\").on(\"swipeleft\",function(){\nalert(\"You swiped left!\");\n});\n\n//向右滑动\n$(\"p\").on(\"swiperight\",function(){\nalert(\"You swiped right!\");\n});\n```\n\n滚动屏幕事件：\n\n```javascript\n//滚屏开始\n$(document).on(\"scrollstart\",function(){\n\n});\n\n//滚屏结束\n$(document).on(\"scrollstop\",function(){\n});\n```\n\n另外，还有页面加载完成、失败、页面切换等事件，如果需要更加详细地了解jMobile的\n用法，可以登录官方网站(http://jquerymobile.com/)去了解更多用法。","source":"_posts/jmobile-use-2.md","raw":"title: 移动前端框架jQuery Mobile 的介绍（二）\nid: 51\ncategories:\n  - 前端开发\ndate: 2015-01-29 00:00:00\ntags:\n---\n\n上一篇主要是介绍了jMobile框架的基础知识，在这一篇里，我们主要是介绍\n表单应用以及基于移动端的各种events。\n<!--more-->\n## 一、表单基础：\n\n在 jQuery Mobile 中，我们可以使用下列表单控件：\n1、文本输入框\n2、搜索输入框\n3、单选按钮\n4、复选框\n5、选择菜单\n6、滑动条\n7、翻转拨动开关\n\n1~5都是和PC前端的用法一样。其中，滑动条以及翻转拨动按钮是具有移动设备特色的表单。值得注意的是，由于\nhtml5的使用，input标签的type值可以是mail、date、search，这是不同于PC端的使用，\n非常方便。如需让标签和表单元素看起来更适应宽屏，可以用带有data-role=\"fieldcontain\"\n属性的\ndiv或\nfieldset元素包围 label/form 元素：\n\n```html\n<form method=\"post\" action=\"demoform.html\">\n<div data-role=\"fieldcontain\">\n<label for=\"fname\">姓:</label>\n<input type=\"text\" name=\"fname\" id=\"fname\">\n<label for=\"lname\">名:</label>\n<input type=\"text\" name=\"lname\" id=\"lname\">\n</div>\n</form>\n\n```\n\n\n为了创建一个可以折叠的表单，可以将表单内容置于带有data-role=\"collapsible\"\n\n属性的fieldset中。\n表单滑动条的使用如下：\n\n```html\n\n<input type=\"range\" name=\"points\" id=\"points\" value=\"50\" min=\"0\" max=\"100\"/>\n```\n\n\n其中的value属性表示滑动条的默认值，min和max是滑动条的取值范围。如果想要高亮突出\n显示滑动条的值，添加 data-highlight=\"true\"。\n\n至于拨动按钮开关，用法如下：\n\n```html\n<select name=\"switch\" id=\"switch\" data-role=\"slider\">\n<option value=\"on\">On</option>\n<option value=\"off\">Off</option>\n</select>\n\n```\n\n可以在option里面添加 \"selected\" 属性来设置选项中的一个为预选中状态（高亮突出显\n示状态）。\n\n## 二、页面事件：\n\n在 jQuery Mobile 中, 使用pageinit 事件来设置代码脚本在DOM元素加载完成后开始\n执行，所以要在任何新页面加载并创建是执行脚本，就需要绑定pageinit事件：\n\n```javascript\n<script>\n$(document).on(\"pageinit\",\"#pageone\",function(){\n});\n</script>\n```\n\n点击事件：\n\n```javascript\n$(\"p\").on(\"tap\",function(){\n$(this).hide();\n});\n```\n\n长按事件：\n```javascript\n\n$(\"p\").on(\"taphold\",function(){\n$(this).hide();\n});\n```\n\n滑动事件：\n\n```javascript\n//简单滑动\n$(\"p\").on(\"swipe\",function(){\n$(\"span\").text(\"Swipe detected!\");\n});\n\n//向左滑动\n$(\"p\").on(\"swipeleft\",function(){\nalert(\"You swiped left!\");\n});\n\n//向右滑动\n$(\"p\").on(\"swiperight\",function(){\nalert(\"You swiped right!\");\n});\n```\n\n滚动屏幕事件：\n\n```javascript\n//滚屏开始\n$(document).on(\"scrollstart\",function(){\n\n});\n\n//滚屏结束\n$(document).on(\"scrollstop\",function(){\n});\n```\n\n另外，还有页面加载完成、失败、页面切换等事件，如果需要更加详细地了解jMobile的\n用法，可以登录官方网站(http://jquerymobile.com/)去了解更多用法。","slug":"jmobile-use-2","published":1,"updated":"2016-08-13T03:08:44.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtrb001f7kaudxo1e70o","content":"<p>上一篇主要是介绍了jMobile框架的基础知识，在这一篇里，我们主要是介绍<br>表单应用以及基于移动端的各种events。<br><a id=\"more\"></a></p>\n<h2 id=\"一、表单基础：\"><a href=\"#一、表单基础：\" class=\"headerlink\" title=\"一、表单基础：\"></a>一、表单基础：</h2><p>在 jQuery Mobile 中，我们可以使用下列表单控件：<br>1、文本输入框<br>2、搜索输入框<br>3、单选按钮<br>4、复选框<br>5、选择菜单<br>6、滑动条<br>7、翻转拨动开关</p>\n<p>1~5都是和PC前端的用法一样。其中，滑动条以及翻转拨动按钮是具有移动设备特色的表单。值得注意的是，由于<br>html5的使用，input标签的type值可以是mail、date、search，这是不同于PC端的使用，<br>非常方便。如需让标签和表单元素看起来更适应宽屏，可以用带有data-role=”fieldcontain”<br>属性的<br>div或<br>fieldset元素包围 label/form 元素：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">action</span>=<span class=\"string\">\"demoform.html\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"fieldcontain\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"fname\"</span>&gt;</span>姓:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fname\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"fname\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"lname\"</span>&gt;</span>名:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"lname\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"lname\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>为了创建一个可以折叠的表单，可以将表单内容置于带有data-role=”collapsible”</p>\n<p>属性的fieldset中。<br>表单滑动条的使用如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"range\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"points\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"points\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"50\"</span> <span class=\"attr\">min</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">max</span>=<span class=\"string\">\"100\"</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>其中的value属性表示滑动条的默认值，min和max是滑动条的取值范围。如果想要高亮突出<br>显示滑动条的值，添加 data-highlight=”true”。</p>\n<p>至于拨动按钮开关，用法如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">\"switch\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"switch\"</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"slider\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"on\"</span>&gt;</span>On<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"off\"</span>&gt;</span>Off<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>可以在option里面添加 “selected” 属性来设置选项中的一个为预选中状态（高亮突出显<br>示状态）。</p>\n<h2 id=\"二、页面事件：\"><a href=\"#二、页面事件：\" class=\"headerlink\" title=\"二、页面事件：\"></a>二、页面事件：</h2><p>在 jQuery Mobile 中, 使用pageinit 事件来设置代码脚本在DOM元素加载完成后开始<br>执行，所以要在任何新页面加载并创建是执行脚本，就需要绑定pageinit事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;</div><div class=\"line\">$(<span class=\"built_in\">document</span>).on(<span class=\"string\">\"pageinit\"</span>,<span class=\"string\">\"#pageone\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></div></pre></td></tr></table></figure>\n<p>点击事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">\"p\"</span>).on(<span class=\"string\">\"tap\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">$(<span class=\"keyword\">this</span>).hide();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>长按事件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">\"p\"</span>).on(<span class=\"string\">\"taphold\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">$(<span class=\"keyword\">this</span>).hide();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>滑动事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//简单滑动</span></div><div class=\"line\">$(<span class=\"string\">\"p\"</span>).on(<span class=\"string\">\"swipe\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">$(<span class=\"string\">\"span\"</span>).text(<span class=\"string\">\"Swipe detected!\"</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//向左滑动</span></div><div class=\"line\">$(<span class=\"string\">\"p\"</span>).on(<span class=\"string\">\"swipeleft\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">alert(<span class=\"string\">\"You swiped left!\"</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//向右滑动</span></div><div class=\"line\">$(<span class=\"string\">\"p\"</span>).on(<span class=\"string\">\"swiperight\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">alert(<span class=\"string\">\"You swiped right!\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>滚动屏幕事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//滚屏开始</span></div><div class=\"line\">$(<span class=\"built_in\">document</span>).on(<span class=\"string\">\"scrollstart\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//滚屏结束</span></div><div class=\"line\">$(<span class=\"built_in\">document</span>).on(<span class=\"string\">\"scrollstop\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>另外，还有页面加载完成、失败、页面切换等事件，如果需要更加详细地了解jMobile的<br>用法，可以登录官方网站(<a href=\"http://jquerymobile.com/)去了解更多用法。\" target=\"_blank\" rel=\"external\">http://jquerymobile.com/)去了解更多用法。</a></p>\n","excerpt":"<p>上一篇主要是介绍了jMobile框架的基础知识，在这一篇里，我们主要是介绍<br>表单应用以及基于移动端的各种events。<br>","more":"</p>\n<h2 id=\"一、表单基础：\"><a href=\"#一、表单基础：\" class=\"headerlink\" title=\"一、表单基础：\"></a>一、表单基础：</h2><p>在 jQuery Mobile 中，我们可以使用下列表单控件：<br>1、文本输入框<br>2、搜索输入框<br>3、单选按钮<br>4、复选框<br>5、选择菜单<br>6、滑动条<br>7、翻转拨动开关</p>\n<p>1~5都是和PC前端的用法一样。其中，滑动条以及翻转拨动按钮是具有移动设备特色的表单。值得注意的是，由于<br>html5的使用，input标签的type值可以是mail、date、search，这是不同于PC端的使用，<br>非常方便。如需让标签和表单元素看起来更适应宽屏，可以用带有data-role=”fieldcontain”<br>属性的<br>div或<br>fieldset元素包围 label/form 元素：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">action</span>=<span class=\"string\">\"demoform.html\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"fieldcontain\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"fname\"</span>&gt;</span>姓:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fname\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"fname\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"lname\"</span>&gt;</span>名:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"lname\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"lname\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>为了创建一个可以折叠的表单，可以将表单内容置于带有data-role=”collapsible”</p>\n<p>属性的fieldset中。<br>表单滑动条的使用如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"range\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"points\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"points\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"50\"</span> <span class=\"attr\">min</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">max</span>=<span class=\"string\">\"100\"</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>其中的value属性表示滑动条的默认值，min和max是滑动条的取值范围。如果想要高亮突出<br>显示滑动条的值，添加 data-highlight=”true”。</p>\n<p>至于拨动按钮开关，用法如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">\"switch\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"switch\"</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"slider\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"on\"</span>&gt;</span>On<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"off\"</span>&gt;</span>Off<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>可以在option里面添加 “selected” 属性来设置选项中的一个为预选中状态（高亮突出显<br>示状态）。</p>\n<h2 id=\"二、页面事件：\"><a href=\"#二、页面事件：\" class=\"headerlink\" title=\"二、页面事件：\"></a>二、页面事件：</h2><p>在 jQuery Mobile 中, 使用pageinit 事件来设置代码脚本在DOM元素加载完成后开始<br>执行，所以要在任何新页面加载并创建是执行脚本，就需要绑定pageinit事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;</div><div class=\"line\">$(<span class=\"built_in\">document</span>).on(<span class=\"string\">\"pageinit\"</span>,<span class=\"string\">\"#pageone\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></div></pre></td></tr></table></figure>\n<p>点击事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">\"p\"</span>).on(<span class=\"string\">\"tap\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">$(<span class=\"keyword\">this</span>).hide();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>长按事件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">\"p\"</span>).on(<span class=\"string\">\"taphold\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">$(<span class=\"keyword\">this</span>).hide();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>滑动事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//简单滑动</span></div><div class=\"line\">$(<span class=\"string\">\"p\"</span>).on(<span class=\"string\">\"swipe\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">$(<span class=\"string\">\"span\"</span>).text(<span class=\"string\">\"Swipe detected!\"</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//向左滑动</span></div><div class=\"line\">$(<span class=\"string\">\"p\"</span>).on(<span class=\"string\">\"swipeleft\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">alert(<span class=\"string\">\"You swiped left!\"</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//向右滑动</span></div><div class=\"line\">$(<span class=\"string\">\"p\"</span>).on(<span class=\"string\">\"swiperight\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">alert(<span class=\"string\">\"You swiped right!\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>滚动屏幕事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//滚屏开始</span></div><div class=\"line\">$(<span class=\"built_in\">document</span>).on(<span class=\"string\">\"scrollstart\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//滚屏结束</span></div><div class=\"line\">$(<span class=\"built_in\">document</span>).on(<span class=\"string\">\"scrollstop\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>另外，还有页面加载完成、失败、页面切换等事件，如果需要更加详细地了解jMobile的<br>用法，可以登录官方网站(<a href=\"http://jquerymobile.com/)去了解更多用法。\">http://jquerymobile.com/)去了解更多用法。</a></p>"},{"title":"一道经典的Web前端笔试试题——闭包","date":"2015-03-31T14:29:29.000Z","_content":"\n**    永远不要以为自己学了点javascript的DOM操作就以为自己“学会”了JS这门博大精深的语言，其实是自己图样图森破了！！！其实javascript的真正精髓（难点）在于作用域、原型以及闭包这三个方面。这是成为前端高手之前必须要迈过的一道坎**。\n<!--more-->\n首先我们来看看这样一道题：\n\n```javascript\nvar a=0;\nfunction fn(){\nfor(var i=0;i&lt;10;i++)\n{\nsetTimeout(function(){\na+=i;},0);\n}\n}\n\nfunction main(){\nconsole.log(a);\n}\n```\n\n这个函数咋一看，没什么了不起的嘛。不就是实现从0加到9的和嘛！很简单，就是45。\n\n显然，世界上大多数的事情总是不能按照我们自己编造的剧本发展滴。实际上，这个main函数的返回结果是100！！！Why?这就涉及到我想要讲的闭包问题。\n\nJS的闭包是比较难理解的一个知识点，我到现在也没有完全理解。实际上，在循环内部的每一个函数中都保留着它的外部函数的活动对象，它们都是指向同一个变量i。当外部函数fn()返回后，变量i的值是10，此时每一个函数都保存着变量i的同一个变量对象，所以在每个函数内部的i的值都是10，所以a+=i实际上是等价于a+=10。循环10次之后的结果显然就变成100了！这其实是因为作用域链的配置机制引发的一个副作用，即闭包只能取得包含函数中任何变量的最后一个值。因为闭包所保存的是整个变量对象，而不是某一个特殊值。\n那如果我非要实现从0到9相加怎么办呢？咱们可以这样写：\n\n```javascript\nvar a=0;\nfunction fn(){\nfor(var i=0;i&lt;10;i++)\n{\nsetTimeout(function(num){\nreturn function(){\na+=num;\n}\n}(i),0);\n}\n}\n\nfunction main(){\nconsole.log(a);//45\n}\n```\n\n这样，我们没有直接把闭包放进setTimeout函数，而是定义一个匿名函数，并立即执行该匿名函数的结果返回。匿名函数的参数num也就是最终要返回的值。在调用每个匿名函数的时候，我们传入了变量i。由于变量参数是传值的，所以i会复制一个副本给num参数，这样在匿名函数的内部又返回了一个访问num的闭包。所以，每一个内部函数中都有一个自己的num副本，算出来的结果就是0到9相加了，最后结果为45。\n\n我们再来看一道著名互联网公司的实习招聘题目：\n\n[![](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/03/2-300x189.jpg \"2\")](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/03/2.jpg)\n\n这道题的话相对理解起来还是比较容易理解的，如果你搞明白了闭包的含义的话。其实是这样子的：函数a里面有一个匿名函数，这个匿名函数访问了a函数的参数x，形成一个闭包。由于作用域链以及函数声明提前的关系，y函数在代码运行之前就已经预先声明，也就是存在于外部活动变量中，当a函数执行返回的时候，活动变量里面的x值就变成了活动变量里面的X值，即2。","source":"_posts/one-interview-closure.md","raw":"title: 一道经典的Web前端笔试试题——闭包\ntags:\n  - js\ncategories:\n  - 前端开发\ndate: 2015-03-31 22:29:29\n---\n\n**    永远不要以为自己学了点javascript的DOM操作就以为自己“学会”了JS这门博大精深的语言，其实是自己图样图森破了！！！其实javascript的真正精髓（难点）在于作用域、原型以及闭包这三个方面。这是成为前端高手之前必须要迈过的一道坎**。\n<!--more-->\n首先我们来看看这样一道题：\n\n```javascript\nvar a=0;\nfunction fn(){\nfor(var i=0;i&lt;10;i++)\n{\nsetTimeout(function(){\na+=i;},0);\n}\n}\n\nfunction main(){\nconsole.log(a);\n}\n```\n\n这个函数咋一看，没什么了不起的嘛。不就是实现从0加到9的和嘛！很简单，就是45。\n\n显然，世界上大多数的事情总是不能按照我们自己编造的剧本发展滴。实际上，这个main函数的返回结果是100！！！Why?这就涉及到我想要讲的闭包问题。\n\nJS的闭包是比较难理解的一个知识点，我到现在也没有完全理解。实际上，在循环内部的每一个函数中都保留着它的外部函数的活动对象，它们都是指向同一个变量i。当外部函数fn()返回后，变量i的值是10，此时每一个函数都保存着变量i的同一个变量对象，所以在每个函数内部的i的值都是10，所以a+=i实际上是等价于a+=10。循环10次之后的结果显然就变成100了！这其实是因为作用域链的配置机制引发的一个副作用，即闭包只能取得包含函数中任何变量的最后一个值。因为闭包所保存的是整个变量对象，而不是某一个特殊值。\n那如果我非要实现从0到9相加怎么办呢？咱们可以这样写：\n\n```javascript\nvar a=0;\nfunction fn(){\nfor(var i=0;i&lt;10;i++)\n{\nsetTimeout(function(num){\nreturn function(){\na+=num;\n}\n}(i),0);\n}\n}\n\nfunction main(){\nconsole.log(a);//45\n}\n```\n\n这样，我们没有直接把闭包放进setTimeout函数，而是定义一个匿名函数，并立即执行该匿名函数的结果返回。匿名函数的参数num也就是最终要返回的值。在调用每个匿名函数的时候，我们传入了变量i。由于变量参数是传值的，所以i会复制一个副本给num参数，这样在匿名函数的内部又返回了一个访问num的闭包。所以，每一个内部函数中都有一个自己的num副本，算出来的结果就是0到9相加了，最后结果为45。\n\n我们再来看一道著名互联网公司的实习招聘题目：\n\n[![](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/03/2-300x189.jpg \"2\")](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/03/2.jpg)\n\n这道题的话相对理解起来还是比较容易理解的，如果你搞明白了闭包的含义的话。其实是这样子的：函数a里面有一个匿名函数，这个匿名函数访问了a函数的参数x，形成一个闭包。由于作用域链以及函数声明提前的关系，y函数在代码运行之前就已经预先声明，也就是存在于外部活动变量中，当a函数执行返回的时候，活动变量里面的x值就变成了活动变量里面的X值，即2。","slug":"one-interview-closure","published":1,"updated":"2016-08-13T03:08:44.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtrc001i7kauxthal2sj","content":"<p><strong>    永远不要以为自己学了点javascript的DOM操作就以为自己“学会”了JS这门博大精深的语言，其实是自己图样图森破了！！！其实javascript的真正精髓（难点）在于作用域、原型以及闭包这三个方面。这是成为前端高手之前必须要迈过的一道坎</strong>。<br><a id=\"more\"></a><br>首先我们来看看这样一道题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&amp;lt;<span class=\"number\">10</span>;i++)</div><div class=\"line\">&#123;</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">a+=i;&#125;,<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个函数咋一看，没什么了不起的嘛。不就是实现从0加到9的和嘛！很简单，就是45。</p>\n<p>显然，世界上大多数的事情总是不能按照我们自己编造的剧本发展滴。实际上，这个main函数的返回结果是100！！！Why?这就涉及到我想要讲的闭包问题。</p>\n<p>JS的闭包是比较难理解的一个知识点，我到现在也没有完全理解。实际上，在循环内部的每一个函数中都保留着它的外部函数的活动对象，它们都是指向同一个变量i。当外部函数fn()返回后，变量i的值是10，此时每一个函数都保存着变量i的同一个变量对象，所以在每个函数内部的i的值都是10，所以a+=i实际上是等价于a+=10。循环10次之后的结果显然就变成100了！这其实是因为作用域链的配置机制引发的一个副作用，即闭包只能取得包含函数中任何变量的最后一个值。因为闭包所保存的是整个变量对象，而不是某一个特殊值。<br>那如果我非要实现从0到9相加怎么办呢？咱们可以这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&amp;lt;<span class=\"number\">10</span>;i++)</div><div class=\"line\">&#123;</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>)</span>&#123;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">a+=num;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;(i),<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a);<span class=\"comment\">//45</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样，我们没有直接把闭包放进setTimeout函数，而是定义一个匿名函数，并立即执行该匿名函数的结果返回。匿名函数的参数num也就是最终要返回的值。在调用每个匿名函数的时候，我们传入了变量i。由于变量参数是传值的，所以i会复制一个副本给num参数，这样在匿名函数的内部又返回了一个访问num的闭包。所以，每一个内部函数中都有一个自己的num副本，算出来的结果就是0到9相加了，最后结果为45。</p>\n<p>我们再来看一道著名互联网公司的实习招聘题目：</p>\n<p><a href=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/03/2.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/03/2-300x189.jpg\" alt=\"\" title=\"2\"></a></p>\n<p>这道题的话相对理解起来还是比较容易理解的，如果你搞明白了闭包的含义的话。其实是这样子的：函数a里面有一个匿名函数，这个匿名函数访问了a函数的参数x，形成一个闭包。由于作用域链以及函数声明提前的关系，y函数在代码运行之前就已经预先声明，也就是存在于外部活动变量中，当a函数执行返回的时候，活动变量里面的x值就变成了活动变量里面的X值，即2。</p>\n","excerpt":"<p><strong>    永远不要以为自己学了点javascript的DOM操作就以为自己“学会”了JS这门博大精深的语言，其实是自己图样图森破了！！！其实javascript的真正精髓（难点）在于作用域、原型以及闭包这三个方面。这是成为前端高手之前必须要迈过的一道坎</strong>。<br>","more":"<br>首先我们来看看这样一道题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&amp;lt;<span class=\"number\">10</span>;i++)</div><div class=\"line\">&#123;</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">a+=i;&#125;,<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个函数咋一看，没什么了不起的嘛。不就是实现从0加到9的和嘛！很简单，就是45。</p>\n<p>显然，世界上大多数的事情总是不能按照我们自己编造的剧本发展滴。实际上，这个main函数的返回结果是100！！！Why?这就涉及到我想要讲的闭包问题。</p>\n<p>JS的闭包是比较难理解的一个知识点，我到现在也没有完全理解。实际上，在循环内部的每一个函数中都保留着它的外部函数的活动对象，它们都是指向同一个变量i。当外部函数fn()返回后，变量i的值是10，此时每一个函数都保存着变量i的同一个变量对象，所以在每个函数内部的i的值都是10，所以a+=i实际上是等价于a+=10。循环10次之后的结果显然就变成100了！这其实是因为作用域链的配置机制引发的一个副作用，即闭包只能取得包含函数中任何变量的最后一个值。因为闭包所保存的是整个变量对象，而不是某一个特殊值。<br>那如果我非要实现从0到9相加怎么办呢？咱们可以这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&amp;lt;<span class=\"number\">10</span>;i++)</div><div class=\"line\">&#123;</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>)</span>&#123;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">a+=num;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;(i),<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a);<span class=\"comment\">//45</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样，我们没有直接把闭包放进setTimeout函数，而是定义一个匿名函数，并立即执行该匿名函数的结果返回。匿名函数的参数num也就是最终要返回的值。在调用每个匿名函数的时候，我们传入了变量i。由于变量参数是传值的，所以i会复制一个副本给num参数，这样在匿名函数的内部又返回了一个访问num的闭包。所以，每一个内部函数中都有一个自己的num副本，算出来的结果就是0到9相加了，最后结果为45。</p>\n<p>我们再来看一道著名互联网公司的实习招聘题目：</p>\n<p><a href=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/03/2.jpg\"><img src=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/03/2-300x189.jpg\" alt=\"\" title=\"2\"></a></p>\n<p>这道题的话相对理解起来还是比较容易理解的，如果你搞明白了闭包的含义的话。其实是这样子的：函数a里面有一个匿名函数，这个匿名函数访问了a函数的参数x，形成一个闭包。由于作用域链以及函数声明提前的关系，y函数在代码运行之前就已经预先声明，也就是存在于外部活动变量中，当a函数执行返回的时候，活动变量里面的x值就变成了活动变量里面的X值，即2。</p>"},{"title":"使用nodejs做一个新闻网页爬虫——Nodejs初体验","id":"71","date":"2015-04-16T12:45:12.000Z","_content":"\n昨天在leader的要求下做了一个小小的作业，作为近期项目的一个入门练习。要写的是一个网页爬虫，使用node来爬取网易新闻页 http://news.163.com 的首页所有的新闻连接，存入urls.txt文件。然后从urls.txt文件中选取一条url进行新闻内容的爬取，存入news.txt文件中。\n<!--more-->\n本来对nodejs的了解仅仅停留在“hello world”的水平，虽然很早就曾打算学习这们传说中无比流弊的语言，无奈最近因为找实习各种事务缠身，始终没时间深入研究node。好在leader给我们的任务恰恰成为我学习node的推动力，哈哈。\n\n回到刚才说的任务，网页爬虫。既然是对网页内容的提取，首先必须得搭建好一个良好的架构。主要是两个方面：一个是对整个页面的爬取，另一个就是对页面关键词的提取。爬取页面肯定要用到node的http模块，在这里我是用了http.get的方法。对于页面元素的提取，我是用了最近刚刚接触过的cheerio这样一个库，这是一个非常轻量型的第三方插件，它的使用语法和jQuery几乎完全一样。比如选择器的语法：\n$(selectior,[context],[root])\n\n选择器在 Context 范围内搜索，Context又在Root范围内搜索。selector 和context可是一个字符串表达式，DOM元素，和DOM元素的数组，或者chreeio对象。root 是通常是HTML 文档字符串。\n\n```javascript\n$('.apple', '#fruits').text()\n//=&gt; Apple\n\n$('ul .pear').attr('class')\n//=&gt; pear\n\n$('li[class=orange]').html()\n//=&gt; &lt;li class=\"orange\"&gt;Orange&lt;/li&gt;\n```\n\n又比如获取html元素内容的语法：.text( [textString] )\n\n```javascript\n$('.orange').text()\n//=&gt; Orange\n\n$('ul').text()\n//=&gt;  Apple\n//    Orange\n//    Pear</pre>\n\n```\n\n下面是我整个代码的目录结构\n\n[![](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/04/捕获-300x112.jpg \"捕获\")](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/04/捕获.jpg)\n\n其中app.js就是负责爬取新闻列表页的url，而getNew.js是负责对新闻内容的抓取。这个项目的难点就是中文编码的转码问题，由于网易新闻主页的html编码方式是GBK，而Nodejs本身是不支持GBK字符的读写的，所以抓取下来的新闻内容就会出现乱码。这是Nodejs入门的一个经典案例，花了我很长时间来解决。后来查找资料得知使用iconv插件来进行转码，最终解决了这个烦人的问题。代码如下：\n\n```javascript\nvar cheerio = require('cheerio')\nvar request = require('request')\nvar fs = require('fs')\nvar iconv = require('iconv-lite')\nvar http = require('http')\n\n/*get one url from file urls.txt*/\nfs.readFile('urls.txt','utf-8',function (err,data) {\n\tif(err){\n\t\tconsole.log(err);\n\t\treturn ;\n\t}\n\n\tvar urlArray = data.split('\\\"},');\n\tvar urlstr = urlArray[0].split(':\\\"');\n\n\tvar url = urlstr[1];\n\tconsole.log(url);\n\thttp.get(url,function (res) {\n\t\t//this step is very important\n\t\t//it change gbk unicode into binary,avoid error\n\n\t\tres.setEncoding('binary');\n\t\tvar article = '';\n\t\tres.on('data',function (data) {\n\t\t\tarticle += data;\n\t\t}).on('end', function () {\n\t\t\tvar buf = new Buffer(article, 'binary');\n\n\t\t\t//decode the content in gbk unicode\n\t\t\t//depend on plus-in iconv\n\t\t\tvar gbkStr = iconv.decode(buf, 'GBK');\n\n\t\t\tvar $ = cheerio.load(gbkStr);\n\t\t\tvar result = [];\n\t\t\tvar title = $('#h1title').text();\n\t\t\tvar cont  = '';\n\t\t\t$('p','#endText').each(function(index,ele){\n\t\t\t\tcont+=$(this).text();\n\t\t\t});\n\n\t\t\tresult.push({ArticleTitle:title,ArticleContent:cont});\n\t\t\tvar file = 'article.txt';\n\t\t\tfs.writeFile(file,JSON.stringify(result),function(err){\n\t\t\t\tif(err){\n\t\t\t\t\tconsole.log(\"write file failed\"+err);\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t});\n\n\t\t})\n\t\t}).on('error', function (err) {\n\t\t\tconsole.log(err);\n\t\t});\n});\n\n```\n\n这就是整个项目的核心代码所在。如果要想查看app.js是如何写的，可以查看我的github地址，https://github.com/hugzh/node。 这里就不贴代码了。","source":"_posts/node-spider.md","raw":"title: 使用nodejs做一个新闻网页爬虫——Nodejs初体验\nid: 71\ncategories:\n  - Nodejs\ndate: 2015-04-16 20:45:12\ntags:\n---\n\n昨天在leader的要求下做了一个小小的作业，作为近期项目的一个入门练习。要写的是一个网页爬虫，使用node来爬取网易新闻页 http://news.163.com 的首页所有的新闻连接，存入urls.txt文件。然后从urls.txt文件中选取一条url进行新闻内容的爬取，存入news.txt文件中。\n<!--more-->\n本来对nodejs的了解仅仅停留在“hello world”的水平，虽然很早就曾打算学习这们传说中无比流弊的语言，无奈最近因为找实习各种事务缠身，始终没时间深入研究node。好在leader给我们的任务恰恰成为我学习node的推动力，哈哈。\n\n回到刚才说的任务，网页爬虫。既然是对网页内容的提取，首先必须得搭建好一个良好的架构。主要是两个方面：一个是对整个页面的爬取，另一个就是对页面关键词的提取。爬取页面肯定要用到node的http模块，在这里我是用了http.get的方法。对于页面元素的提取，我是用了最近刚刚接触过的cheerio这样一个库，这是一个非常轻量型的第三方插件，它的使用语法和jQuery几乎完全一样。比如选择器的语法：\n$(selectior,[context],[root])\n\n选择器在 Context 范围内搜索，Context又在Root范围内搜索。selector 和context可是一个字符串表达式，DOM元素，和DOM元素的数组，或者chreeio对象。root 是通常是HTML 文档字符串。\n\n```javascript\n$('.apple', '#fruits').text()\n//=&gt; Apple\n\n$('ul .pear').attr('class')\n//=&gt; pear\n\n$('li[class=orange]').html()\n//=&gt; &lt;li class=\"orange\"&gt;Orange&lt;/li&gt;\n```\n\n又比如获取html元素内容的语法：.text( [textString] )\n\n```javascript\n$('.orange').text()\n//=&gt; Orange\n\n$('ul').text()\n//=&gt;  Apple\n//    Orange\n//    Pear</pre>\n\n```\n\n下面是我整个代码的目录结构\n\n[![](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/04/捕获-300x112.jpg \"捕获\")](http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/04/捕获.jpg)\n\n其中app.js就是负责爬取新闻列表页的url，而getNew.js是负责对新闻内容的抓取。这个项目的难点就是中文编码的转码问题，由于网易新闻主页的html编码方式是GBK，而Nodejs本身是不支持GBK字符的读写的，所以抓取下来的新闻内容就会出现乱码。这是Nodejs入门的一个经典案例，花了我很长时间来解决。后来查找资料得知使用iconv插件来进行转码，最终解决了这个烦人的问题。代码如下：\n\n```javascript\nvar cheerio = require('cheerio')\nvar request = require('request')\nvar fs = require('fs')\nvar iconv = require('iconv-lite')\nvar http = require('http')\n\n/*get one url from file urls.txt*/\nfs.readFile('urls.txt','utf-8',function (err,data) {\n\tif(err){\n\t\tconsole.log(err);\n\t\treturn ;\n\t}\n\n\tvar urlArray = data.split('\\\"},');\n\tvar urlstr = urlArray[0].split(':\\\"');\n\n\tvar url = urlstr[1];\n\tconsole.log(url);\n\thttp.get(url,function (res) {\n\t\t//this step is very important\n\t\t//it change gbk unicode into binary,avoid error\n\n\t\tres.setEncoding('binary');\n\t\tvar article = '';\n\t\tres.on('data',function (data) {\n\t\t\tarticle += data;\n\t\t}).on('end', function () {\n\t\t\tvar buf = new Buffer(article, 'binary');\n\n\t\t\t//decode the content in gbk unicode\n\t\t\t//depend on plus-in iconv\n\t\t\tvar gbkStr = iconv.decode(buf, 'GBK');\n\n\t\t\tvar $ = cheerio.load(gbkStr);\n\t\t\tvar result = [];\n\t\t\tvar title = $('#h1title').text();\n\t\t\tvar cont  = '';\n\t\t\t$('p','#endText').each(function(index,ele){\n\t\t\t\tcont+=$(this).text();\n\t\t\t});\n\n\t\t\tresult.push({ArticleTitle:title,ArticleContent:cont});\n\t\t\tvar file = 'article.txt';\n\t\t\tfs.writeFile(file,JSON.stringify(result),function(err){\n\t\t\t\tif(err){\n\t\t\t\t\tconsole.log(\"write file failed\"+err);\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t});\n\n\t\t})\n\t\t}).on('error', function (err) {\n\t\t\tconsole.log(err);\n\t\t});\n});\n\n```\n\n这就是整个项目的核心代码所在。如果要想查看app.js是如何写的，可以查看我的github地址，https://github.com/hugzh/node。 这里就不贴代码了。","slug":"node-spider","published":1,"updated":"2016-08-13T03:08:44.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtre001l7kau20des9c0","content":"<p>昨天在leader的要求下做了一个小小的作业，作为近期项目的一个入门练习。要写的是一个网页爬虫，使用node来爬取网易新闻页 <a href=\"http://news.163.com\" target=\"_blank\" rel=\"external\">http://news.163.com</a> 的首页所有的新闻连接，存入urls.txt文件。然后从urls.txt文件中选取一条url进行新闻内容的爬取，存入news.txt文件中。<br><a id=\"more\"></a><br>本来对nodejs的了解仅仅停留在“hello world”的水平，虽然很早就曾打算学习这们传说中无比流弊的语言，无奈最近因为找实习各种事务缠身，始终没时间深入研究node。好在leader给我们的任务恰恰成为我学习node的推动力，哈哈。</p>\n<p>回到刚才说的任务，网页爬虫。既然是对网页内容的提取，首先必须得搭建好一个良好的架构。主要是两个方面：一个是对整个页面的爬取，另一个就是对页面关键词的提取。爬取页面肯定要用到node的http模块，在这里我是用了http.get的方法。对于页面元素的提取，我是用了最近刚刚接触过的cheerio这样一个库，这是一个非常轻量型的第三方插件，它的使用语法和jQuery几乎完全一样。比如选择器的语法：<br>$(selectior,[context],[root])</p>\n<p>选择器在 Context 范围内搜索，Context又在Root范围内搜索。selector 和context可是一个字符串表达式，DOM元素，和DOM元素的数组，或者chreeio对象。root 是通常是HTML 文档字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'.apple'</span>, <span class=\"string\">'#fruits'</span>).text()</div><div class=\"line\"><span class=\"comment\">//=&amp;gt; Apple</span></div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'ul .pear'</span>).attr(<span class=\"string\">'class'</span>)</div><div class=\"line\"><span class=\"comment\">//=&amp;gt; pear</span></div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'li[class=orange]'</span>).html()</div><div class=\"line\"><span class=\"comment\">//=&amp;gt; &amp;lt;li class=\"orange\"&amp;gt;Orange&amp;lt;/li&amp;gt;</span></div></pre></td></tr></table></figure>\n<p>又比如获取html元素内容的语法：.text( [textString] )</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'.orange'</span>).text()</div><div class=\"line\"><span class=\"comment\">//=&amp;gt; Orange</span></div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'ul'</span>).text()</div><div class=\"line\"><span class=\"comment\">//=&amp;gt;  Apple</span></div><div class=\"line\"><span class=\"comment\">//    Orange</span></div><div class=\"line\"><span class=\"comment\">//    Pear&lt;/pre&gt;</span></div></pre></td></tr></table></figure>\n<p>下面是我整个代码的目录结构</p>\n<p><a href=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/04/捕获.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/04/捕获-300x112.jpg\" alt=\"\" title=\"捕获\"></a></p>\n<p>其中app.js就是负责爬取新闻列表页的url，而getNew.js是负责对新闻内容的抓取。这个项目的难点就是中文编码的转码问题，由于网易新闻主页的html编码方式是GBK，而Nodejs本身是不支持GBK字符的读写的，所以抓取下来的新闻内容就会出现乱码。这是Nodejs入门的一个经典案例，花了我很长时间来解决。后来查找资料得知使用iconv插件来进行转码，最终解决了这个烦人的问题。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">'cheerio'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">'request'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> iconv = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*get one url from file urls.txt*/</span></div><div class=\"line\">fs.readFile(<span class=\"string\">'urls.txt'</span>,<span class=\"string\">'utf-8'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err,data</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(err)&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> ;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">var</span> urlArray = data.split(<span class=\"string\">'\\\"&#125;,'</span>);</div><div class=\"line\">\t<span class=\"keyword\">var</span> urlstr = urlArray[<span class=\"number\">0</span>].split(<span class=\"string\">':\\\"'</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">var</span> url = urlstr[<span class=\"number\">1</span>];</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(url);</div><div class=\"line\">\thttp.get(url,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//this step is very important</span></div><div class=\"line\">\t\t<span class=\"comment\">//it change gbk unicode into binary,avoid error</span></div><div class=\"line\"></div><div class=\"line\">\t\tres.setEncoding(<span class=\"string\">'binary'</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> article = <span class=\"string\">''</span>;</div><div class=\"line\">\t\tres.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">\t\t\tarticle += data;</div><div class=\"line\">\t\t&#125;).on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> Buffer(article, <span class=\"string\">'binary'</span>);</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"comment\">//decode the content in gbk unicode</span></div><div class=\"line\">\t\t\t<span class=\"comment\">//depend on plus-in iconv</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> gbkStr = iconv.decode(buf, <span class=\"string\">'GBK'</span>);</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> $ = cheerio.load(gbkStr);</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> result = [];</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> title = $(<span class=\"string\">'#h1title'</span>).text();</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> cont  = <span class=\"string\">''</span>;</div><div class=\"line\">\t\t\t$(<span class=\"string\">'p'</span>,<span class=\"string\">'#endText'</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">index,ele</span>)</span>&#123;</div><div class=\"line\">\t\t\t\tcont+=$(<span class=\"keyword\">this</span>).text();</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\t\t\tresult.push(&#123;ArticleTitle:title,ArticleContent:cont&#125;);</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> file = <span class=\"string\">'article.txt'</span>;</div><div class=\"line\">\t\t\tfs.writeFile(file,<span class=\"built_in\">JSON</span>.stringify(result),<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(err)&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"write file failed\"</span>+err);</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> ;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t\t&#125;).on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这就是整个项目的核心代码所在。如果要想查看app.js是如何写的，可以查看我的github地址，<a href=\"https://github.com/hugzh/node。\" target=\"_blank\" rel=\"external\">https://github.com/hugzh/node。</a> 这里就不贴代码了。</p>\n","excerpt":"<p>昨天在leader的要求下做了一个小小的作业，作为近期项目的一个入门练习。要写的是一个网页爬虫，使用node来爬取网易新闻页 <a href=\"http://news.163.com\">http://news.163.com</a> 的首页所有的新闻连接，存入urls.txt文件。然后从urls.txt文件中选取一条url进行新闻内容的爬取，存入news.txt文件中。<br>","more":"<br>本来对nodejs的了解仅仅停留在“hello world”的水平，虽然很早就曾打算学习这们传说中无比流弊的语言，无奈最近因为找实习各种事务缠身，始终没时间深入研究node。好在leader给我们的任务恰恰成为我学习node的推动力，哈哈。</p>\n<p>回到刚才说的任务，网页爬虫。既然是对网页内容的提取，首先必须得搭建好一个良好的架构。主要是两个方面：一个是对整个页面的爬取，另一个就是对页面关键词的提取。爬取页面肯定要用到node的http模块，在这里我是用了http.get的方法。对于页面元素的提取，我是用了最近刚刚接触过的cheerio这样一个库，这是一个非常轻量型的第三方插件，它的使用语法和jQuery几乎完全一样。比如选择器的语法：<br>$(selectior,[context],[root])</p>\n<p>选择器在 Context 范围内搜索，Context又在Root范围内搜索。selector 和context可是一个字符串表达式，DOM元素，和DOM元素的数组，或者chreeio对象。root 是通常是HTML 文档字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'.apple'</span>, <span class=\"string\">'#fruits'</span>).text()</div><div class=\"line\"><span class=\"comment\">//=&amp;gt; Apple</span></div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'ul .pear'</span>).attr(<span class=\"string\">'class'</span>)</div><div class=\"line\"><span class=\"comment\">//=&amp;gt; pear</span></div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'li[class=orange]'</span>).html()</div><div class=\"line\"><span class=\"comment\">//=&amp;gt; &amp;lt;li class=\"orange\"&amp;gt;Orange&amp;lt;/li&amp;gt;</span></div></pre></td></tr></table></figure>\n<p>又比如获取html元素内容的语法：.text( [textString] )</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'.orange'</span>).text()</div><div class=\"line\"><span class=\"comment\">//=&amp;gt; Orange</span></div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'ul'</span>).text()</div><div class=\"line\"><span class=\"comment\">//=&amp;gt;  Apple</span></div><div class=\"line\"><span class=\"comment\">//    Orange</span></div><div class=\"line\"><span class=\"comment\">//    Pear&lt;/pre&gt;</span></div></pre></td></tr></table></figure>\n<p>下面是我整个代码的目录结构</p>\n<p><a href=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/04/捕获.jpg\"><img src=\"http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/04/捕获-300x112.jpg\" alt=\"\" title=\"捕获\"></a></p>\n<p>其中app.js就是负责爬取新闻列表页的url，而getNew.js是负责对新闻内容的抓取。这个项目的难点就是中文编码的转码问题，由于网易新闻主页的html编码方式是GBK，而Nodejs本身是不支持GBK字符的读写的，所以抓取下来的新闻内容就会出现乱码。这是Nodejs入门的一个经典案例，花了我很长时间来解决。后来查找资料得知使用iconv插件来进行转码，最终解决了这个烦人的问题。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">'cheerio'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">'request'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> iconv = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*get one url from file urls.txt*/</span></div><div class=\"line\">fs.readFile(<span class=\"string\">'urls.txt'</span>,<span class=\"string\">'utf-8'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err,data</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(err)&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> ;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">var</span> urlArray = data.split(<span class=\"string\">'\\\"&#125;,'</span>);</div><div class=\"line\">\t<span class=\"keyword\">var</span> urlstr = urlArray[<span class=\"number\">0</span>].split(<span class=\"string\">':\\\"'</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">var</span> url = urlstr[<span class=\"number\">1</span>];</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(url);</div><div class=\"line\">\thttp.get(url,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//this step is very important</span></div><div class=\"line\">\t\t<span class=\"comment\">//it change gbk unicode into binary,avoid error</span></div><div class=\"line\"></div><div class=\"line\">\t\tres.setEncoding(<span class=\"string\">'binary'</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> article = <span class=\"string\">''</span>;</div><div class=\"line\">\t\tres.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">\t\t\tarticle += data;</div><div class=\"line\">\t\t&#125;).on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> Buffer(article, <span class=\"string\">'binary'</span>);</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"comment\">//decode the content in gbk unicode</span></div><div class=\"line\">\t\t\t<span class=\"comment\">//depend on plus-in iconv</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> gbkStr = iconv.decode(buf, <span class=\"string\">'GBK'</span>);</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> $ = cheerio.load(gbkStr);</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> result = [];</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> title = $(<span class=\"string\">'#h1title'</span>).text();</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> cont  = <span class=\"string\">''</span>;</div><div class=\"line\">\t\t\t$(<span class=\"string\">'p'</span>,<span class=\"string\">'#endText'</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">index,ele</span>)</span>&#123;</div><div class=\"line\">\t\t\t\tcont+=$(<span class=\"keyword\">this</span>).text();</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\t\t\tresult.push(&#123;ArticleTitle:title,ArticleContent:cont&#125;);</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> file = <span class=\"string\">'article.txt'</span>;</div><div class=\"line\">\t\t\tfs.writeFile(file,<span class=\"built_in\">JSON</span>.stringify(result),<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(err)&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"write file failed\"</span>+err);</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> ;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t\t&#125;).on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这就是整个项目的核心代码所在。如果要想查看app.js是如何写的，可以查看我的github地址，<a href=\"https://github.com/hugzh/node。\">https://github.com/hugzh/node。</a> 这里就不贴代码了。</p>"},{"title":"使用哈希密码的安全性问题","date":"2014-11-20T16:00:00.000Z","_content":"\n## 一、 哈希密码\n哈希是一种散列函数，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。\n在密码学当中，HASH主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码里,叫做HASH值. 也可以说，hash就是找到一种数据内容和数据存放地址之间的映射关系。MD4和MD5是哈希密码的主要算法。\n<!--more-->\n## 二、 哈希密码的安全隐患\n哈希函数本来是不可逆的函数，也就是说知道了哈希值也不能使用算法把原文推算出来。但是由于常见字符串的哈希值，可以通过查表的方式找到原文，比如彩虹表等等。所以目前还是存在一些数据库可以查到简单字符串的哈希值的，这样就造成了用哈希函数加密的密文安全性不可靠。\n\n## 三、 哈希盐值\n盐值就是程序随机产生的随机字符串组合。\n加盐后的散列值，可以极大的降低由于用户数据被盗而带来的密码泄漏风险，即使通过彩虹表寻找到了散列后的数值所对应的原始内容，但是由于经过了加盐，插入的字符串扰乱了真正的密码，使得获得真实密码的概率大大降低。那么它的原理是什么呢？\n查表法和彩虹表只有在所有密码都以相同方式进行哈希加密时才有效。如果两个用户密码相同，那么他们密码的哈希值也是相同的。我们可以通过“随机化”哈希来阻止这类攻击，于是当相同的密码被哈希两次之后，得到的值就不相同了。为了校验密码是否正确，我们需要储存盐值。通常和密码哈希值一起存放在账户数据库中，或者直接存为哈希字符串的一部分。\n加盐值的时候需要注意以下几点：\n1、 盐值不能重复。两个相同的密码会得到相同的哈希值。攻击者可以使用反向查表法对每个值进行字典攻击，只需要把盐值应用到每个猜测的密码上再进行哈希即可。如果盐值被硬编码到某个流行的软件里，可以专门为这个软件制作查询表和彩虹表，那么破解它生成的哈希值就变得很简单了。用户创建账户或每次修改密码时，都应该重新生成新的盐值进行加密。\n2、 盐值不能太短。如果盐值太短，攻击者可以构造一个查询表包含所有可能的盐值。以只有3个ASCII字符的盐值为例，一共有95x95x95=857,375种可能。同样地，用户名也不应该被用作盐值。尽管在一个网站中用户名是唯一的，但是它们是可预测的，并且经常重复用于其他服务中。攻击者可以针对常见用户名构建查询表，然后对用户名盐值哈希发起进攻。\n为了使攻击者无法构造包含所有可能盐值的查询表，盐值必须足够长。一个好的做法是使用和哈希函数输出的字符串等长的盐值，比如SHA256算法的输出是256bits(32 bytes)，那么盐值也至少应该是32个随机字节。\n3、 不使用组合哈希。人们经常不由自主地认为将不同的哈希函数组合起来，结果会更加安全。实际上这样做几乎没有好处，仅仅造成了函数之间互相影响的问题，甚至有时候会变得更加不安全。\n## 四、哈希加盐存储密码的步骤\n\n存储密码的步骤\n1\\. 使用CSPRNG（伪随机数生成器）生成一个长度足够的盐值\n2\\. 将盐值混入密码，并使用标准的加密哈希函数进行加密，如MD5\n3\\. 把哈希值和盐值一起存入数据库中对应此用户的那条记录\n校验密码的步骤\n1\\. 从数据库取出用户的密码哈希值和对应盐值\n2\\. 将盐值混入用户输入的密码，并且使用同样的哈希函数进行加密\n3\\. 比较上一步的结果和数据库储存的哈希值是否相同，如果相同那么密码正确，反之密码错误","source":"_posts/problem-of-hash.md","raw":"title: 使用哈希密码的安全性问题\ncategories:\n  - 其它\ndate: 2014-11-21 00:00:00\ntags:\n---\n\n## 一、 哈希密码\n哈希是一种散列函数，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。\n在密码学当中，HASH主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码里,叫做HASH值. 也可以说，hash就是找到一种数据内容和数据存放地址之间的映射关系。MD4和MD5是哈希密码的主要算法。\n<!--more-->\n## 二、 哈希密码的安全隐患\n哈希函数本来是不可逆的函数，也就是说知道了哈希值也不能使用算法把原文推算出来。但是由于常见字符串的哈希值，可以通过查表的方式找到原文，比如彩虹表等等。所以目前还是存在一些数据库可以查到简单字符串的哈希值的，这样就造成了用哈希函数加密的密文安全性不可靠。\n\n## 三、 哈希盐值\n盐值就是程序随机产生的随机字符串组合。\n加盐后的散列值，可以极大的降低由于用户数据被盗而带来的密码泄漏风险，即使通过彩虹表寻找到了散列后的数值所对应的原始内容，但是由于经过了加盐，插入的字符串扰乱了真正的密码，使得获得真实密码的概率大大降低。那么它的原理是什么呢？\n查表法和彩虹表只有在所有密码都以相同方式进行哈希加密时才有效。如果两个用户密码相同，那么他们密码的哈希值也是相同的。我们可以通过“随机化”哈希来阻止这类攻击，于是当相同的密码被哈希两次之后，得到的值就不相同了。为了校验密码是否正确，我们需要储存盐值。通常和密码哈希值一起存放在账户数据库中，或者直接存为哈希字符串的一部分。\n加盐值的时候需要注意以下几点：\n1、 盐值不能重复。两个相同的密码会得到相同的哈希值。攻击者可以使用反向查表法对每个值进行字典攻击，只需要把盐值应用到每个猜测的密码上再进行哈希即可。如果盐值被硬编码到某个流行的软件里，可以专门为这个软件制作查询表和彩虹表，那么破解它生成的哈希值就变得很简单了。用户创建账户或每次修改密码时，都应该重新生成新的盐值进行加密。\n2、 盐值不能太短。如果盐值太短，攻击者可以构造一个查询表包含所有可能的盐值。以只有3个ASCII字符的盐值为例，一共有95x95x95=857,375种可能。同样地，用户名也不应该被用作盐值。尽管在一个网站中用户名是唯一的，但是它们是可预测的，并且经常重复用于其他服务中。攻击者可以针对常见用户名构建查询表，然后对用户名盐值哈希发起进攻。\n为了使攻击者无法构造包含所有可能盐值的查询表，盐值必须足够长。一个好的做法是使用和哈希函数输出的字符串等长的盐值，比如SHA256算法的输出是256bits(32 bytes)，那么盐值也至少应该是32个随机字节。\n3、 不使用组合哈希。人们经常不由自主地认为将不同的哈希函数组合起来，结果会更加安全。实际上这样做几乎没有好处，仅仅造成了函数之间互相影响的问题，甚至有时候会变得更加不安全。\n## 四、哈希加盐存储密码的步骤\n\n存储密码的步骤\n1\\. 使用CSPRNG（伪随机数生成器）生成一个长度足够的盐值\n2\\. 将盐值混入密码，并使用标准的加密哈希函数进行加密，如MD5\n3\\. 把哈希值和盐值一起存入数据库中对应此用户的那条记录\n校验密码的步骤\n1\\. 从数据库取出用户的密码哈希值和对应盐值\n2\\. 将盐值混入用户输入的密码，并且使用同样的哈希函数进行加密\n3\\. 比较上一步的结果和数据库储存的哈希值是否相同，如果相同那么密码正确，反之密码错误","slug":"problem-of-hash","published":1,"updated":"2016-08-13T03:08:44.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtrh001o7kau19wonjmv","content":"<h2 id=\"一、-哈希密码\"><a href=\"#一、-哈希密码\" class=\"headerlink\" title=\"一、 哈希密码\"></a>一、 哈希密码</h2><p>哈希是一种散列函数，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。<br>在密码学当中，HASH主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码里,叫做HASH值. 也可以说，hash就是找到一种数据内容和数据存放地址之间的映射关系。MD4和MD5是哈希密码的主要算法。<br><a id=\"more\"></a></p>\n<h2 id=\"二、-哈希密码的安全隐患\"><a href=\"#二、-哈希密码的安全隐患\" class=\"headerlink\" title=\"二、 哈希密码的安全隐患\"></a>二、 哈希密码的安全隐患</h2><p>哈希函数本来是不可逆的函数，也就是说知道了哈希值也不能使用算法把原文推算出来。但是由于常见字符串的哈希值，可以通过查表的方式找到原文，比如彩虹表等等。所以目前还是存在一些数据库可以查到简单字符串的哈希值的，这样就造成了用哈希函数加密的密文安全性不可靠。</p>\n<h2 id=\"三、-哈希盐值\"><a href=\"#三、-哈希盐值\" class=\"headerlink\" title=\"三、 哈希盐值\"></a>三、 哈希盐值</h2><p>盐值就是程序随机产生的随机字符串组合。<br>加盐后的散列值，可以极大的降低由于用户数据被盗而带来的密码泄漏风险，即使通过彩虹表寻找到了散列后的数值所对应的原始内容，但是由于经过了加盐，插入的字符串扰乱了真正的密码，使得获得真实密码的概率大大降低。那么它的原理是什么呢？<br>查表法和彩虹表只有在所有密码都以相同方式进行哈希加密时才有效。如果两个用户密码相同，那么他们密码的哈希值也是相同的。我们可以通过“随机化”哈希来阻止这类攻击，于是当相同的密码被哈希两次之后，得到的值就不相同了。为了校验密码是否正确，我们需要储存盐值。通常和密码哈希值一起存放在账户数据库中，或者直接存为哈希字符串的一部分。<br>加盐值的时候需要注意以下几点：<br>1、 盐值不能重复。两个相同的密码会得到相同的哈希值。攻击者可以使用反向查表法对每个值进行字典攻击，只需要把盐值应用到每个猜测的密码上再进行哈希即可。如果盐值被硬编码到某个流行的软件里，可以专门为这个软件制作查询表和彩虹表，那么破解它生成的哈希值就变得很简单了。用户创建账户或每次修改密码时，都应该重新生成新的盐值进行加密。<br>2、 盐值不能太短。如果盐值太短，攻击者可以构造一个查询表包含所有可能的盐值。以只有3个ASCII字符的盐值为例，一共有95x95x95=857,375种可能。同样地，用户名也不应该被用作盐值。尽管在一个网站中用户名是唯一的，但是它们是可预测的，并且经常重复用于其他服务中。攻击者可以针对常见用户名构建查询表，然后对用户名盐值哈希发起进攻。<br>为了使攻击者无法构造包含所有可能盐值的查询表，盐值必须足够长。一个好的做法是使用和哈希函数输出的字符串等长的盐值，比如SHA256算法的输出是256bits(32 bytes)，那么盐值也至少应该是32个随机字节。<br>3、 不使用组合哈希。人们经常不由自主地认为将不同的哈希函数组合起来，结果会更加安全。实际上这样做几乎没有好处，仅仅造成了函数之间互相影响的问题，甚至有时候会变得更加不安全。</p>\n<h2 id=\"四、哈希加盐存储密码的步骤\"><a href=\"#四、哈希加盐存储密码的步骤\" class=\"headerlink\" title=\"四、哈希加盐存储密码的步骤\"></a>四、哈希加盐存储密码的步骤</h2><p>存储密码的步骤<br>1. 使用CSPRNG（伪随机数生成器）生成一个长度足够的盐值<br>2. 将盐值混入密码，并使用标准的加密哈希函数进行加密，如MD5<br>3. 把哈希值和盐值一起存入数据库中对应此用户的那条记录<br>校验密码的步骤<br>1. 从数据库取出用户的密码哈希值和对应盐值<br>2. 将盐值混入用户输入的密码，并且使用同样的哈希函数进行加密<br>3. 比较上一步的结果和数据库储存的哈希值是否相同，如果相同那么密码正确，反之密码错误</p>\n","excerpt":"<h2 id=\"一、-哈希密码\"><a href=\"#一、-哈希密码\" class=\"headerlink\" title=\"一、 哈希密码\"></a>一、 哈希密码</h2><p>哈希是一种散列函数，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。<br>在密码学当中，HASH主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码里,叫做HASH值. 也可以说，hash就是找到一种数据内容和数据存放地址之间的映射关系。MD4和MD5是哈希密码的主要算法。<br>","more":"</p>\n<h2 id=\"二、-哈希密码的安全隐患\"><a href=\"#二、-哈希密码的安全隐患\" class=\"headerlink\" title=\"二、 哈希密码的安全隐患\"></a>二、 哈希密码的安全隐患</h2><p>哈希函数本来是不可逆的函数，也就是说知道了哈希值也不能使用算法把原文推算出来。但是由于常见字符串的哈希值，可以通过查表的方式找到原文，比如彩虹表等等。所以目前还是存在一些数据库可以查到简单字符串的哈希值的，这样就造成了用哈希函数加密的密文安全性不可靠。</p>\n<h2 id=\"三、-哈希盐值\"><a href=\"#三、-哈希盐值\" class=\"headerlink\" title=\"三、 哈希盐值\"></a>三、 哈希盐值</h2><p>盐值就是程序随机产生的随机字符串组合。<br>加盐后的散列值，可以极大的降低由于用户数据被盗而带来的密码泄漏风险，即使通过彩虹表寻找到了散列后的数值所对应的原始内容，但是由于经过了加盐，插入的字符串扰乱了真正的密码，使得获得真实密码的概率大大降低。那么它的原理是什么呢？<br>查表法和彩虹表只有在所有密码都以相同方式进行哈希加密时才有效。如果两个用户密码相同，那么他们密码的哈希值也是相同的。我们可以通过“随机化”哈希来阻止这类攻击，于是当相同的密码被哈希两次之后，得到的值就不相同了。为了校验密码是否正确，我们需要储存盐值。通常和密码哈希值一起存放在账户数据库中，或者直接存为哈希字符串的一部分。<br>加盐值的时候需要注意以下几点：<br>1、 盐值不能重复。两个相同的密码会得到相同的哈希值。攻击者可以使用反向查表法对每个值进行字典攻击，只需要把盐值应用到每个猜测的密码上再进行哈希即可。如果盐值被硬编码到某个流行的软件里，可以专门为这个软件制作查询表和彩虹表，那么破解它生成的哈希值就变得很简单了。用户创建账户或每次修改密码时，都应该重新生成新的盐值进行加密。<br>2、 盐值不能太短。如果盐值太短，攻击者可以构造一个查询表包含所有可能的盐值。以只有3个ASCII字符的盐值为例，一共有95x95x95=857,375种可能。同样地，用户名也不应该被用作盐值。尽管在一个网站中用户名是唯一的，但是它们是可预测的，并且经常重复用于其他服务中。攻击者可以针对常见用户名构建查询表，然后对用户名盐值哈希发起进攻。<br>为了使攻击者无法构造包含所有可能盐值的查询表，盐值必须足够长。一个好的做法是使用和哈希函数输出的字符串等长的盐值，比如SHA256算法的输出是256bits(32 bytes)，那么盐值也至少应该是32个随机字节。<br>3、 不使用组合哈希。人们经常不由自主地认为将不同的哈希函数组合起来，结果会更加安全。实际上这样做几乎没有好处，仅仅造成了函数之间互相影响的问题，甚至有时候会变得更加不安全。</p>\n<h2 id=\"四、哈希加盐存储密码的步骤\"><a href=\"#四、哈希加盐存储密码的步骤\" class=\"headerlink\" title=\"四、哈希加盐存储密码的步骤\"></a>四、哈希加盐存储密码的步骤</h2><p>存储密码的步骤<br>1. 使用CSPRNG（伪随机数生成器）生成一个长度足够的盐值<br>2. 将盐值混入密码，并使用标准的加密哈希函数进行加密，如MD5<br>3. 把哈希值和盐值一起存入数据库中对应此用户的那条记录<br>校验密码的步骤<br>1. 从数据库取出用户的密码哈希值和对应盐值<br>2. 将盐值混入用户输入的密码，并且使用同样的哈希函数进行加密<br>3. 比较上一步的结果和数据库储存的哈希值是否相同，如果相同那么密码正确，反之密码错误</p>"},{"title":"文件上传插件Uploadify的简单介绍","id":"29","date":"2014-09-30T16:00:00.000Z","_content":"\n熟悉使用php的人一定会对php文件上传不陌生，多文件上传以及重命名等都是文件上传的重要应用，我在这里介绍一个ajax+jQuery的插件，这个插件比较好的地方就是前端的效果比较炫酷，使用比较简单，大大简化了代码复杂度。uploadify.swf是插件的核心部分，（下载地址:http://www.uploadify.com/download/） 前端的效果主要由jquery.uploadify.js实现，所以这两个文件要包含进前端的源代码。我在这里主要是想介绍前端的接口函数以及php后台里面的文件重命名的技巧。\n前端比较简单，主要是文件包含以及文件上传表单和接口函数。需要包含这几个js文件\n<!--more-->\n```\n<script src=\"jquery.min.js\" type=\"text/javascript\"></script>\n<script src=\"jquery.uploadify.min.js\" type=\"text/javascript\"></script>\n```\n\n还有就是接口函数:\n\n```\n<script type=\"text/javascript\">\n\n$(function() {\n$('#file_upload').uploadify({\n'swf' : 'uploadify.swf',\n'uploader' : 'uploadify.php'\n});\n});\n</script>\n\n```\n\n接口函数里面的uploadify()是属于插件uploadify.swf的函数，所以必须先把文件包含进去。\n前端body部分的代码如下：\n\n```\n<form>\n<div id=\"queue\"></div>\n<input id=\"file_upload\" name=\"file_upload\" type=\"file\" multiple=\"true\">\n</form>\n```\n后台部分的php代码比较简单，比较关键的部分就是重命名，根据接口，后台处理函数命名为uploadify.php。由于多文件上传可以在一秒钟之内完成多个文件上传，所以把时间戳作为唯一命名的做法需要注意的地方就是不能把time函数作为字符串，这样会导致字符串相同，如此便没办法上传多个文件，我在这里的解决办法就是使用microtime()生成微秒级的时间，再转化为字符串，这样每个文件的命名就会唯一了。主要代码如下：\n\n```\n// Define a destination\n$targetFolder = '/uploads'; // Relative to the root\n\n/*$verifyToken = md5('unique_salt' . $_POST['timestamp']);*/\n\nif (!empty($_FILES) &amp;&amp; $_POST['token'] == $verifyToken) {\n$tempFile = $_FILES['Filedata']['tmp_name'];\n$targetPath = $_SERVER['DOCUMENT_ROOT'] . $targetFolder;\n\n/*文件以时间戳重命名，这6行代码为个人添加，可以删除，删除之后保持文件原名*/\n$date = microtime();//取得当前时间\n$nodot = explode(\".\",$date);//切割掉 microtime()函数返回数据格式 0.25139300 1138197510中的点\n$namestr = str_replace(' ','',$nodot[1]);//去除空格\n$uptype = explode(\".\", $_FILES[\"Filedata\"][\"name\"]);//分割留下文件类型\n$newname = $namestr.\".\".$uptype[1];\n$_FILES[\"Filedata\"][\"name\"] = $newname;//重命名\n$targetFile = rtrim($targetPath,'/').'/'.iconv(\"UTF-8\",\"GB2312\",$_FILES[\"Filedata\"][\"name\"]);\n\n// Validate the file type\n$fileTypes = array('jpg','jpeg','pjpeg','gif','png'); // File extensions\n$fileParts = pathinfo($_FILES['Filedata']['name']);\n\nif (in_array($fileParts['extension'],$fileTypes)) {\nmove_uploaded_file($tempFile,$targetFile);\necho '1';\n} else {\necho 'Invalid file type.';\n}\n}\n```","source":"_posts/uploadyfy-introduce.md","raw":"title: 文件上传插件uploadify的简单介绍\nid: 29\ncategories:\n  - php\ndate: 2014-10-01 00:00:00\ntags:\n---\n\n熟悉使用php的人一定会对php文件上传不陌生，多文件上传以及重命名等都是文件上传的重要应用，我在这里介绍一个ajax+jQuery的插件，这个插件比较好的地方就是前端的效果比较炫酷，使用比较简单，大大简化了代码复杂度。uploadify.swf是插件的核心部分，（下载地址:http://www.uploadify.com/download/） 前端的效果主要由jquery.uploadify.js实现，所以这两个文件要包含进前端的源代码。我在这里主要是想介绍前端的接口函数以及php后台里面的文件重命名的技巧。\n前端比较简单，主要是文件包含以及文件上传表单和接口函数。需要包含这几个js文件\n<!--more-->\n```\n<script src=\"jquery.min.js\" type=\"text/javascript\"></script>\n<script src=\"jquery.uploadify.min.js\" type=\"text/javascript\"></script>\n```\n\n还有就是接口函数:\n\n```\n<script type=\"text/javascript\">\n\n$(function() {\n$('#file_upload').uploadify({\n'swf' : 'uploadify.swf',\n'uploader' : 'uploadify.php'\n});\n});\n</script>\n\n```\n\n接口函数里面的uploadify()是属于插件uploadify.swf的函数，所以必须先把文件包含进去。\n前端body部分的代码如下：\n\n```\n<form>\n<div id=\"queue\"></div>\n<input id=\"file_upload\" name=\"file_upload\" type=\"file\" multiple=\"true\">\n</form>\n```\n后台部分的php代码比较简单，比较关键的部分就是重命名，根据接口，后台处理函数命名为uploadify.php。由于多文件上传可以在一秒钟之内完成多个文件上传，所以把时间戳作为唯一命名的做法需要注意的地方就是不能把time函数作为字符串，这样会导致字符串相同，如此便没办法上传多个文件，我在这里的解决办法就是使用microtime()生成微秒级的时间，再转化为字符串，这样每个文件的命名就会唯一了。主要代码如下：\n\n```\n// Define a destination\n$targetFolder = '/uploads'; // Relative to the root\n\n/*$verifyToken = md5('unique_salt' . $_POST['timestamp']);*/\n\nif (!empty($_FILES) &amp;&amp; $_POST['token'] == $verifyToken) {\n$tempFile = $_FILES['Filedata']['tmp_name'];\n$targetPath = $_SERVER['DOCUMENT_ROOT'] . $targetFolder;\n\n/*文件以时间戳重命名，这6行代码为个人添加，可以删除，删除之后保持文件原名*/\n$date = microtime();//取得当前时间\n$nodot = explode(\".\",$date);//切割掉 microtime()函数返回数据格式 0.25139300 1138197510中的点\n$namestr = str_replace(' ','',$nodot[1]);//去除空格\n$uptype = explode(\".\", $_FILES[\"Filedata\"][\"name\"]);//分割留下文件类型\n$newname = $namestr.\".\".$uptype[1];\n$_FILES[\"Filedata\"][\"name\"] = $newname;//重命名\n$targetFile = rtrim($targetPath,'/').'/'.iconv(\"UTF-8\",\"GB2312\",$_FILES[\"Filedata\"][\"name\"]);\n\n// Validate the file type\n$fileTypes = array('jpg','jpeg','pjpeg','gif','png'); // File extensions\n$fileParts = pathinfo($_FILES['Filedata']['name']);\n\nif (in_array($fileParts['extension'],$fileTypes)) {\nmove_uploaded_file($tempFile,$targetFile);\necho '1';\n} else {\necho 'Invalid file type.';\n}\n}\n```","slug":"uploadyfy-introduce","published":1,"updated":"2016-08-13T03:08:44.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtrk001s7kau5j6o4utg","content":"<p>熟悉使用php的人一定会对php文件上传不陌生，多文件上传以及重命名等都是文件上传的重要应用，我在这里介绍一个ajax+jQuery的插件，这个插件比较好的地方就是前端的效果比较炫酷，使用比较简单，大大简化了代码复杂度。uploadify.swf是插件的核心部分，（下载地址:<a href=\"http://www.uploadify.com/download/）\" target=\"_blank\" rel=\"external\">http://www.uploadify.com/download/）</a> 前端的效果主要由jquery.uploadify.js实现，所以这两个文件要包含进前端的源代码。我在这里主要是想介绍前端的接口函数以及php后台里面的文件重命名的技巧。<br>前端比较简单，主要是文件包含以及文件上传表单和接口函数。需要包含这几个js文件<br><a id=\"more\"></a><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"jquery.min.js\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"jquery.uploadify.min.js\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>还有就是接口函数:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"></div><div class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">$(<span class=\"string\">'#file_upload'</span>).uploadify(&#123;</div><div class=\"line\"><span class=\"string\">'swf'</span> : <span class=\"string\">'uploadify.swf'</span>,</div><div class=\"line\"><span class=\"string\">'uploader'</span> : <span class=\"string\">'uploadify.php'</span></div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>接口函数里面的uploadify()是属于插件uploadify.swf的函数，所以必须先把文件包含进去。<br>前端body部分的代码如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"queue\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"file_upload\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"file_upload\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">multiple</span>=<span class=\"string\">\"true\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>后台部分的php代码比较简单，比较关键的部分就是重命名，根据接口，后台处理函数命名为uploadify.php。由于多文件上传可以在一秒钟之内完成多个文件上传，所以把时间戳作为唯一命名的做法需要注意的地方就是不能把time函数作为字符串，这样会导致字符串相同，如此便没办法上传多个文件，我在这里的解决办法就是使用microtime()生成微秒级的时间，再转化为字符串，这样每个文件的命名就会唯一了。主要代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Define a destination</span></div><div class=\"line\">$targetFolder = <span class=\"string\">'/uploads'</span>; <span class=\"comment\">// Relative to the root</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*$verifyToken = md5('unique_salt' . $_POST['timestamp']);*/</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"keyword\">empty</span>($_FILES) &amp;amp;&amp;amp; $_POST[<span class=\"string\">'token'</span>] == $verifyToken) &#123;</div><div class=\"line\">$tempFile = $_FILES[<span class=\"string\">'Filedata'</span>][<span class=\"string\">'tmp_name'</span>];</div><div class=\"line\">$targetPath = $_SERVER[<span class=\"string\">'DOCUMENT_ROOT'</span>] . $targetFolder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*文件以时间戳重命名，这6行代码为个人添加，可以删除，删除之后保持文件原名*/</span></div><div class=\"line\">$date = microtime();<span class=\"comment\">//取得当前时间</span></div><div class=\"line\">$nodot = explode(<span class=\"string\">\".\"</span>,$date);<span class=\"comment\">//切割掉 microtime()函数返回数据格式 0.25139300 1138197510中的点</span></div><div class=\"line\">$namestr = str_replace(<span class=\"string\">' '</span>,<span class=\"string\">''</span>,$nodot[<span class=\"number\">1</span>]);<span class=\"comment\">//去除空格</span></div><div class=\"line\">$uptype = explode(<span class=\"string\">\".\"</span>, $_FILES[<span class=\"string\">\"Filedata\"</span>][<span class=\"string\">\"name\"</span>]);<span class=\"comment\">//分割留下文件类型</span></div><div class=\"line\">$newname = $namestr.<span class=\"string\">\".\"</span>.$uptype[<span class=\"number\">1</span>];</div><div class=\"line\">$_FILES[<span class=\"string\">\"Filedata\"</span>][<span class=\"string\">\"name\"</span>] = $newname;<span class=\"comment\">//重命名</span></div><div class=\"line\">$targetFile = rtrim($targetPath,<span class=\"string\">'/'</span>).<span class=\"string\">'/'</span>.iconv(<span class=\"string\">\"UTF-8\"</span>,<span class=\"string\">\"GB2312\"</span>,$_FILES[<span class=\"string\">\"Filedata\"</span>][<span class=\"string\">\"name\"</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Validate the file type</span></div><div class=\"line\">$fileTypes = <span class=\"keyword\">array</span>(<span class=\"string\">'jpg'</span>,<span class=\"string\">'jpeg'</span>,<span class=\"string\">'pjpeg'</span>,<span class=\"string\">'gif'</span>,<span class=\"string\">'png'</span>); <span class=\"comment\">// File extensions</span></div><div class=\"line\">$fileParts = pathinfo($_FILES[<span class=\"string\">'Filedata'</span>][<span class=\"string\">'name'</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (in_array($fileParts[<span class=\"string\">'extension'</span>],$fileTypes)) &#123;</div><div class=\"line\">move_uploaded_file($tempFile,$targetFile);</div><div class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">'1'</span>;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">'Invalid file type.'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"<p>熟悉使用php的人一定会对php文件上传不陌生，多文件上传以及重命名等都是文件上传的重要应用，我在这里介绍一个ajax+jQuery的插件，这个插件比较好的地方就是前端的效果比较炫酷，使用比较简单，大大简化了代码复杂度。uploadify.swf是插件的核心部分，（下载地址:<a href=\"http://www.uploadify.com/download/）\">http://www.uploadify.com/download/）</a> 前端的效果主要由jquery.uploadify.js实现，所以这两个文件要包含进前端的源代码。我在这里主要是想介绍前端的接口函数以及php后台里面的文件重命名的技巧。<br>前端比较简单，主要是文件包含以及文件上传表单和接口函数。需要包含这几个js文件<br>","more":"<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"jquery.min.js\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"jquery.uploadify.min.js\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>还有就是接口函数:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\"></div><div class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">$(<span class=\"string\">'#file_upload'</span>).uploadify(&#123;</div><div class=\"line\"><span class=\"string\">'swf'</span> : <span class=\"string\">'uploadify.swf'</span>,</div><div class=\"line\"><span class=\"string\">'uploader'</span> : <span class=\"string\">'uploadify.php'</span></div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>接口函数里面的uploadify()是属于插件uploadify.swf的函数，所以必须先把文件包含进去。<br>前端body部分的代码如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"queue\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"file_upload\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"file_upload\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">multiple</span>=<span class=\"string\">\"true\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>后台部分的php代码比较简单，比较关键的部分就是重命名，根据接口，后台处理函数命名为uploadify.php。由于多文件上传可以在一秒钟之内完成多个文件上传，所以把时间戳作为唯一命名的做法需要注意的地方就是不能把time函数作为字符串，这样会导致字符串相同，如此便没办法上传多个文件，我在这里的解决办法就是使用microtime()生成微秒级的时间，再转化为字符串，这样每个文件的命名就会唯一了。主要代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Define a destination</span></div><div class=\"line\">$targetFolder = <span class=\"string\">'/uploads'</span>; <span class=\"comment\">// Relative to the root</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*$verifyToken = md5('unique_salt' . $_POST['timestamp']);*/</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"keyword\">empty</span>($_FILES) &amp;amp;&amp;amp; $_POST[<span class=\"string\">'token'</span>] == $verifyToken) &#123;</div><div class=\"line\">$tempFile = $_FILES[<span class=\"string\">'Filedata'</span>][<span class=\"string\">'tmp_name'</span>];</div><div class=\"line\">$targetPath = $_SERVER[<span class=\"string\">'DOCUMENT_ROOT'</span>] . $targetFolder;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*文件以时间戳重命名，这6行代码为个人添加，可以删除，删除之后保持文件原名*/</span></div><div class=\"line\">$date = microtime();<span class=\"comment\">//取得当前时间</span></div><div class=\"line\">$nodot = explode(<span class=\"string\">\".\"</span>,$date);<span class=\"comment\">//切割掉 microtime()函数返回数据格式 0.25139300 1138197510中的点</span></div><div class=\"line\">$namestr = str_replace(<span class=\"string\">' '</span>,<span class=\"string\">''</span>,$nodot[<span class=\"number\">1</span>]);<span class=\"comment\">//去除空格</span></div><div class=\"line\">$uptype = explode(<span class=\"string\">\".\"</span>, $_FILES[<span class=\"string\">\"Filedata\"</span>][<span class=\"string\">\"name\"</span>]);<span class=\"comment\">//分割留下文件类型</span></div><div class=\"line\">$newname = $namestr.<span class=\"string\">\".\"</span>.$uptype[<span class=\"number\">1</span>];</div><div class=\"line\">$_FILES[<span class=\"string\">\"Filedata\"</span>][<span class=\"string\">\"name\"</span>] = $newname;<span class=\"comment\">//重命名</span></div><div class=\"line\">$targetFile = rtrim($targetPath,<span class=\"string\">'/'</span>).<span class=\"string\">'/'</span>.iconv(<span class=\"string\">\"UTF-8\"</span>,<span class=\"string\">\"GB2312\"</span>,$_FILES[<span class=\"string\">\"Filedata\"</span>][<span class=\"string\">\"name\"</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Validate the file type</span></div><div class=\"line\">$fileTypes = <span class=\"keyword\">array</span>(<span class=\"string\">'jpg'</span>,<span class=\"string\">'jpeg'</span>,<span class=\"string\">'pjpeg'</span>,<span class=\"string\">'gif'</span>,<span class=\"string\">'png'</span>); <span class=\"comment\">// File extensions</span></div><div class=\"line\">$fileParts = pathinfo($_FILES[<span class=\"string\">'Filedata'</span>][<span class=\"string\">'name'</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (in_array($fileParts[<span class=\"string\">'extension'</span>],$fileTypes)) &#123;</div><div class=\"line\">move_uploaded_file($tempFile,$targetFile);</div><div class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">'1'</span>;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">'Invalid file type.'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Php验证码制作","date":"2014-09-16T16:00:00.000Z","_content":"\n关于网页制作中的验证码部分是一个比较有趣的知识点，验证码的制作主要是基于PHP的图片处理拓展功能。 验证码制作的一般流程是：\n1、创建验证码显示的底图\n2、列出所有可能用到的字符内容以及字体颜色\n3、随机截取部分（4或者5个）字符作为验证码输出\n4、确定验证码显示的角度以及坐标\n5、增加干扰元素（点和线条等）\n6、php输出图片，并在脚本及时地destroy掉图片\n<!--more-->\n然后是一个值得注意的地方就是，一般来说验证码不应该出现容易混淆的字符，比如l和1,2和z,0和o等等，这是作为一个开发者从用户体验的角度来说需要注意的地方，另外就是干扰元素的颜色不应该使用鲜艳的颜色，一般来说颜色RGB值在50之后比较稳妥。\n以下是我的php代码，命名为yanzhengma.php:\n\n```php\n$image = imagecreatetruecolor(100,30);//100x30的图片生成\n$bgcolor = imagecolorallocate($image,255,255,255);//白色底色\nimagefill($image,0,0,$bgcolor);`\n\n//保存验证码内容便于服务器验证\n$capchcode='';\n\nfor($i = 0;$i&lt;4;$i++){\n$fontsize=12;\n$fontcolor = imagecolorallocate($image,rand(0,120),rand(0,120),rand(0,120));\n\n//$fontcotent = rand(0,9);//产生随机数字\n$data = 'ABCDEHJKYSWTRabcdefghjkmnpqstuwsy23456789';\n$fontcotent = substr($data,rand(0,strlen($data)),1);//随机截取一个字符\n$capchcode .= $fontcotent;\n\n$x = ($i*100/4)+rand(5,10);//定义内容的x坐标、y坐标，随机\n$y = rand(5,12);\nimagestring($image,$fontsize,$x,$y,$fontcotent,$fontcolor);//产生字符送到图片\n}\n\n$_SESSION['authcode'] = $capchcode;\n\n//添加点干扰元素\nfor($i = 0;$i&lt;300;$i++){\n$pointcolor = imagecolorallocate($image,rand(50,200),rand(50,200),rand(50,200));\nimagesetpixel($image,rand(1,99),rand(1,29),$pointcolor);//点元素分布\n}\n\n//添加线条干扰\nfor($i = 0;$i&lt;3;$i++){\n$linecolor = imagecolorallocate($image,rand(80,220),rand(80,220),rand(80,220));\nimageline($image,rand(1,99),rand(1,29),rand(1,99),rand(1,29),$linecolor);//线条元素分布,两点确定一条直线\n}\nheader('content-type:image/png');\nimagepng($image);\nimagedestroy($image);\n```\n\n总的来说，简单验证码的制作并不难，如果要做一些gif类型的验证码或者一些更加个性化的验证码就需要多花费一些时间去查找相关资料了，这里不做介绍。","source":"_posts/yanzhengma-php.md","raw":"title: php验证码制作\ncategories:\n  - php\ndate: 2014-09-17 00:00:00\ntags:\n---\n\n关于网页制作中的验证码部分是一个比较有趣的知识点，验证码的制作主要是基于PHP的图片处理拓展功能。 验证码制作的一般流程是：\n1、创建验证码显示的底图\n2、列出所有可能用到的字符内容以及字体颜色\n3、随机截取部分（4或者5个）字符作为验证码输出\n4、确定验证码显示的角度以及坐标\n5、增加干扰元素（点和线条等）\n6、php输出图片，并在脚本及时地destroy掉图片\n<!--more-->\n然后是一个值得注意的地方就是，一般来说验证码不应该出现容易混淆的字符，比如l和1,2和z,0和o等等，这是作为一个开发者从用户体验的角度来说需要注意的地方，另外就是干扰元素的颜色不应该使用鲜艳的颜色，一般来说颜色RGB值在50之后比较稳妥。\n以下是我的php代码，命名为yanzhengma.php:\n\n```php\n$image = imagecreatetruecolor(100,30);//100x30的图片生成\n$bgcolor = imagecolorallocate($image,255,255,255);//白色底色\nimagefill($image,0,0,$bgcolor);`\n\n//保存验证码内容便于服务器验证\n$capchcode='';\n\nfor($i = 0;$i&lt;4;$i++){\n$fontsize=12;\n$fontcolor = imagecolorallocate($image,rand(0,120),rand(0,120),rand(0,120));\n\n//$fontcotent = rand(0,9);//产生随机数字\n$data = 'ABCDEHJKYSWTRabcdefghjkmnpqstuwsy23456789';\n$fontcotent = substr($data,rand(0,strlen($data)),1);//随机截取一个字符\n$capchcode .= $fontcotent;\n\n$x = ($i*100/4)+rand(5,10);//定义内容的x坐标、y坐标，随机\n$y = rand(5,12);\nimagestring($image,$fontsize,$x,$y,$fontcotent,$fontcolor);//产生字符送到图片\n}\n\n$_SESSION['authcode'] = $capchcode;\n\n//添加点干扰元素\nfor($i = 0;$i&lt;300;$i++){\n$pointcolor = imagecolorallocate($image,rand(50,200),rand(50,200),rand(50,200));\nimagesetpixel($image,rand(1,99),rand(1,29),$pointcolor);//点元素分布\n}\n\n//添加线条干扰\nfor($i = 0;$i&lt;3;$i++){\n$linecolor = imagecolorallocate($image,rand(80,220),rand(80,220),rand(80,220));\nimageline($image,rand(1,99),rand(1,29),rand(1,99),rand(1,29),$linecolor);//线条元素分布,两点确定一条直线\n}\nheader('content-type:image/png');\nimagepng($image);\nimagedestroy($image);\n```\n\n总的来说，简单验证码的制作并不难，如果要做一些gif类型的验证码或者一些更加个性化的验证码就需要多花费一些时间去查找相关资料了，这里不做介绍。","slug":"yanzhengma-php","published":1,"updated":"2016-08-13T03:08:44.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtrm001u7kauge04aq61","content":"<p>关于网页制作中的验证码部分是一个比较有趣的知识点，验证码的制作主要是基于PHP的图片处理拓展功能。 验证码制作的一般流程是：<br>1、创建验证码显示的底图<br>2、列出所有可能用到的字符内容以及字体颜色<br>3、随机截取部分（4或者5个）字符作为验证码输出<br>4、确定验证码显示的角度以及坐标<br>5、增加干扰元素（点和线条等）<br>6、php输出图片，并在脚本及时地destroy掉图片<br><a id=\"more\"></a><br>然后是一个值得注意的地方就是，一般来说验证码不应该出现容易混淆的字符，比如l和1,2和z,0和o等等，这是作为一个开发者从用户体验的角度来说需要注意的地方，另外就是干扰元素的颜色不应该使用鲜艳的颜色，一般来说颜色RGB值在50之后比较稳妥。<br>以下是我的php代码，命名为yanzhengma.php:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">$image = imagecreatetruecolor(<span class=\"number\">100</span>,<span class=\"number\">30</span>);<span class=\"comment\">//100x30的图片生成</span></div><div class=\"line\">$bgcolor = imagecolorallocate($image,<span class=\"number\">255</span>,<span class=\"number\">255</span>,<span class=\"number\">255</span>);<span class=\"comment\">//白色底色</span></div><div class=\"line\">imagefill($image,<span class=\"number\">0</span>,<span class=\"number\">0</span>,$bgcolor);`</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//保存验证码内容便于服务器验证</span></div><div class=\"line\">$capchcode=<span class=\"string\">''</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span>($i = <span class=\"number\">0</span>;$i&amp;lt;<span class=\"number\">4</span>;$i++)&#123;</div><div class=\"line\">$fontsize=<span class=\"number\">12</span>;</div><div class=\"line\">$fontcolor = imagecolorallocate($image,rand(<span class=\"number\">0</span>,<span class=\"number\">120</span>),rand(<span class=\"number\">0</span>,<span class=\"number\">120</span>),rand(<span class=\"number\">0</span>,<span class=\"number\">120</span>));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//$fontcotent = rand(0,9);//产生随机数字</span></div><div class=\"line\">$data = <span class=\"string\">'ABCDEHJKYSWTRabcdefghjkmnpqstuwsy23456789'</span>;</div><div class=\"line\">$fontcotent = substr($data,rand(<span class=\"number\">0</span>,strlen($data)),<span class=\"number\">1</span>);<span class=\"comment\">//随机截取一个字符</span></div><div class=\"line\">$capchcode .= $fontcotent;</div><div class=\"line\"></div><div class=\"line\">$x = ($i*<span class=\"number\">100</span>/<span class=\"number\">4</span>)+rand(<span class=\"number\">5</span>,<span class=\"number\">10</span>);<span class=\"comment\">//定义内容的x坐标、y坐标，随机</span></div><div class=\"line\">$y = rand(<span class=\"number\">5</span>,<span class=\"number\">12</span>);</div><div class=\"line\">imagestring($image,$fontsize,$x,$y,$fontcotent,$fontcolor);<span class=\"comment\">//产生字符送到图片</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$_SESSION[<span class=\"string\">'authcode'</span>] = $capchcode;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//添加点干扰元素</span></div><div class=\"line\"><span class=\"keyword\">for</span>($i = <span class=\"number\">0</span>;$i&amp;lt;<span class=\"number\">300</span>;$i++)&#123;</div><div class=\"line\">$pointcolor = imagecolorallocate($image,rand(<span class=\"number\">50</span>,<span class=\"number\">200</span>),rand(<span class=\"number\">50</span>,<span class=\"number\">200</span>),rand(<span class=\"number\">50</span>,<span class=\"number\">200</span>));</div><div class=\"line\">imagesetpixel($image,rand(<span class=\"number\">1</span>,<span class=\"number\">99</span>),rand(<span class=\"number\">1</span>,<span class=\"number\">29</span>),$pointcolor);<span class=\"comment\">//点元素分布</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//添加线条干扰</span></div><div class=\"line\"><span class=\"keyword\">for</span>($i = <span class=\"number\">0</span>;$i&amp;lt;<span class=\"number\">3</span>;$i++)&#123;</div><div class=\"line\">$linecolor = imagecolorallocate($image,rand(<span class=\"number\">80</span>,<span class=\"number\">220</span>),rand(<span class=\"number\">80</span>,<span class=\"number\">220</span>),rand(<span class=\"number\">80</span>,<span class=\"number\">220</span>));</div><div class=\"line\">imageline($image,rand(<span class=\"number\">1</span>,<span class=\"number\">99</span>),rand(<span class=\"number\">1</span>,<span class=\"number\">29</span>),rand(<span class=\"number\">1</span>,<span class=\"number\">99</span>),rand(<span class=\"number\">1</span>,<span class=\"number\">29</span>),$linecolor);<span class=\"comment\">//线条元素分布,两点确定一条直线</span></div><div class=\"line\">&#125;</div><div class=\"line\">header(<span class=\"string\">'content-type:image/png'</span>);</div><div class=\"line\">imagepng($image);</div><div class=\"line\">imagedestroy($image);</div></pre></td></tr></table></figure>\n<p>总的来说，简单验证码的制作并不难，如果要做一些gif类型的验证码或者一些更加个性化的验证码就需要多花费一些时间去查找相关资料了，这里不做介绍。</p>\n","excerpt":"<p>关于网页制作中的验证码部分是一个比较有趣的知识点，验证码的制作主要是基于PHP的图片处理拓展功能。 验证码制作的一般流程是：<br>1、创建验证码显示的底图<br>2、列出所有可能用到的字符内容以及字体颜色<br>3、随机截取部分（4或者5个）字符作为验证码输出<br>4、确定验证码显示的角度以及坐标<br>5、增加干扰元素（点和线条等）<br>6、php输出图片，并在脚本及时地destroy掉图片<br>","more":"<br>然后是一个值得注意的地方就是，一般来说验证码不应该出现容易混淆的字符，比如l和1,2和z,0和o等等，这是作为一个开发者从用户体验的角度来说需要注意的地方，另外就是干扰元素的颜色不应该使用鲜艳的颜色，一般来说颜色RGB值在50之后比较稳妥。<br>以下是我的php代码，命名为yanzhengma.php:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">$image = imagecreatetruecolor(<span class=\"number\">100</span>,<span class=\"number\">30</span>);<span class=\"comment\">//100x30的图片生成</span></div><div class=\"line\">$bgcolor = imagecolorallocate($image,<span class=\"number\">255</span>,<span class=\"number\">255</span>,<span class=\"number\">255</span>);<span class=\"comment\">//白色底色</span></div><div class=\"line\">imagefill($image,<span class=\"number\">0</span>,<span class=\"number\">0</span>,$bgcolor);`</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//保存验证码内容便于服务器验证</span></div><div class=\"line\">$capchcode=<span class=\"string\">''</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span>($i = <span class=\"number\">0</span>;$i&amp;lt;<span class=\"number\">4</span>;$i++)&#123;</div><div class=\"line\">$fontsize=<span class=\"number\">12</span>;</div><div class=\"line\">$fontcolor = imagecolorallocate($image,rand(<span class=\"number\">0</span>,<span class=\"number\">120</span>),rand(<span class=\"number\">0</span>,<span class=\"number\">120</span>),rand(<span class=\"number\">0</span>,<span class=\"number\">120</span>));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//$fontcotent = rand(0,9);//产生随机数字</span></div><div class=\"line\">$data = <span class=\"string\">'ABCDEHJKYSWTRabcdefghjkmnpqstuwsy23456789'</span>;</div><div class=\"line\">$fontcotent = substr($data,rand(<span class=\"number\">0</span>,strlen($data)),<span class=\"number\">1</span>);<span class=\"comment\">//随机截取一个字符</span></div><div class=\"line\">$capchcode .= $fontcotent;</div><div class=\"line\"></div><div class=\"line\">$x = ($i*<span class=\"number\">100</span>/<span class=\"number\">4</span>)+rand(<span class=\"number\">5</span>,<span class=\"number\">10</span>);<span class=\"comment\">//定义内容的x坐标、y坐标，随机</span></div><div class=\"line\">$y = rand(<span class=\"number\">5</span>,<span class=\"number\">12</span>);</div><div class=\"line\">imagestring($image,$fontsize,$x,$y,$fontcotent,$fontcolor);<span class=\"comment\">//产生字符送到图片</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$_SESSION[<span class=\"string\">'authcode'</span>] = $capchcode;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//添加点干扰元素</span></div><div class=\"line\"><span class=\"keyword\">for</span>($i = <span class=\"number\">0</span>;$i&amp;lt;<span class=\"number\">300</span>;$i++)&#123;</div><div class=\"line\">$pointcolor = imagecolorallocate($image,rand(<span class=\"number\">50</span>,<span class=\"number\">200</span>),rand(<span class=\"number\">50</span>,<span class=\"number\">200</span>),rand(<span class=\"number\">50</span>,<span class=\"number\">200</span>));</div><div class=\"line\">imagesetpixel($image,rand(<span class=\"number\">1</span>,<span class=\"number\">99</span>),rand(<span class=\"number\">1</span>,<span class=\"number\">29</span>),$pointcolor);<span class=\"comment\">//点元素分布</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//添加线条干扰</span></div><div class=\"line\"><span class=\"keyword\">for</span>($i = <span class=\"number\">0</span>;$i&amp;lt;<span class=\"number\">3</span>;$i++)&#123;</div><div class=\"line\">$linecolor = imagecolorallocate($image,rand(<span class=\"number\">80</span>,<span class=\"number\">220</span>),rand(<span class=\"number\">80</span>,<span class=\"number\">220</span>),rand(<span class=\"number\">80</span>,<span class=\"number\">220</span>));</div><div class=\"line\">imageline($image,rand(<span class=\"number\">1</span>,<span class=\"number\">99</span>),rand(<span class=\"number\">1</span>,<span class=\"number\">29</span>),rand(<span class=\"number\">1</span>,<span class=\"number\">99</span>),rand(<span class=\"number\">1</span>,<span class=\"number\">29</span>),$linecolor);<span class=\"comment\">//线条元素分布,两点确定一条直线</span></div><div class=\"line\">&#125;</div><div class=\"line\">header(<span class=\"string\">'content-type:image/png'</span>);</div><div class=\"line\">imagepng($image);</div><div class=\"line\">imagedestroy($image);</div></pre></td></tr></table></figure>\n<p>总的来说，简单验证码的制作并不难，如果要做一些gif类型的验证码或者一些更加个性化的验证码就需要多花费一些时间去查找相关资料了，这里不做介绍。</p>"},{"title":"一个应届生对近来前端界流派之争的一点思考","date":"2016-01-23T12:05:36.000Z","_content":"回家躲避寒潮，忽然发现自己又变成无所事事的状态了。果然以后工作的话，远程办公这种东西不适合我，毕竟在家效率太低。最近几天刷微博的时候发现业界大神们沉寂了十天半月之后也许被寒潮冻出来寂寞感，关于“真伪前端”的话题又被拿出来辩(si)论(bi)了。<!--more-->其实最近两三年关于前端新技术的“抵触”和“拥抱”两种态度一直存在，爆发不少口水大战。尤其是react-native以及ES6在2015年横空出世以后，关于前端工程师的技术栈应该如何构建的话题引发了一轮又一轮的“世界大战”。作为一个还没毕业的应届生前端小白，自己对于业界前辈的华山论剑一直是秉持理性观战、汲取众家所长的态度，毕竟年轻，不敢妄加评论。所以这篇文章的基调也是从毕业生小白的视角对前端领域“真伪前端”话题进行肤浅的总结。\n## 一、现状\n其实对于前端界两种态度的持有者，按照流派划分大约可以对应为“保守派”和“狂热派”。“保守派”的特征是对CSS有深入的研究，可以说是CSS专家；“狂热派”的代表是像淘宝前端团队这样的成熟前端团队成员，他们在javascript和nodejs方面造诣非凡。所以呢，从技术的角度来讲，也可以把两大阵营划分为CSS流派和JS流派。\n“保守派”也不是说这些开发者对于前端技术不欢迎或者抵触什么的，他们的观点是，当前前端的发展有点偏离轨道，前端人员玩像react-native这样的技术是雀占鸠巢，有点不务正业。保守派认为诸如Angular、React-native、SASS这样的热门技术并不能维持长久的适用度，它们必将会像之前的很多曾经火得一塌糊涂的框架一样仅仅是昙花一现，不值得前端开发者去花大量精力研究，而热衷于这些东西的狂热派都是“伪前端”。另外一个批判点就是，当前对于形形色色框架的狂热追捧会导致前端小白迷失方向，随大流去捣鼓RN、Babel这样的技术框架和工具，本末倒置，忽视了对CSS和javascript本身的研究。\n“狂热派”是前端社区比较活跃的存在，他们热衷于捣鼓各类横空出世的新技术，是Facebook、Google以及Twitter等国外互联网企业开源出的新技术的忠实追随者。狂热派大多处于或者曾经处于国内一线互联网企业的成熟团队，工作中接触新技术较多，是实实在在的“技术潮人”。狂热派认为，ES6、react、Webpack这样的新技术是可以真正解决当前的业界痛点，是前端发展的主流和正确方向。他们鄙视还在捣鼓jQuery的前端开发者，认为这是真真切切的“切图仔”，没有真正步入现代前端。狂热派觉得保守派是一批不思进取的懒人，只有新技术才能推动前端的进一步发展。\n## 二、分析\n之所以像现在这样出现两种不同的对立阵营，是因为web前端的发展现在正进入一个全新的时代，一个真正的鼎盛时代，一个技术界的工业革命时代。随着互联网网民增加特别是移动互联网网民的比重逆转PC端网民，大型前端项目在接受来自移动端的大规模访问时出现了相对于PC端时代更大的挑战。移动互联网对流量和速度的极致要求推动了相关技术的迅猛发展。“快”和“省”成为前端开发的技术中心点。所以FB的天才工程师们才会孵化出虚拟DOM这样的前端技术。另外，工业化时代的自动化生产流程也是大型前端项目的产儿，是推动新技术诞生的核心力量。种种因素之下，各种工具和框架满天飞，每天都有新玩意儿出现在github和相关社区。在这样的情况下，一部分业务繁忙的工程师们无暇顾及充斥眼球的各种新名词。一般来说，如果只专注于自己的业务领域的话是根本用不到RN、AG之类的乱七八糟的东西。再加上资深的前端开发者见过太多的新玩意起起落落，大部分昙花一现，所以对当前新技术的热衷潮流不屑一顾的态度也就是自然而然形成了。\n但是呢，另外一批来自成熟团队的成员（也可能是其他类型的开发者），由于他们产品大多数已经成熟，平时的业务范围也就局限于内部框架之上的二次开发，他们的工作重心是造轮子、研究新技术。很自然地，这批人的关注点在于新技术，对业界的新技术也就格外推崇。再加上国内的互联网技术环境决定了前端工程师更多地是使用外国佬的技术而不是创造出颠覆业界的技术，对技术的狂热可以把逼格满满提升几格，何乐而不为呢。\n那为什么程序员那么喜欢争(si)论(bi)？要知道，程序员是一群特立独行的人，骨子里天生就有一种优越感。在码农的世界里，对就是对，错就是错。我认为对的东西你不认同你就是错的，既然你是错的，我就要嘲讽这种错误的存在。所以有人说，毁掉一个团队最简单的办法就是把写java、python和PHP的人都丢进去，这样这个团队基本上就完了。在前端的世界里，要毁掉一个团队也许更简单，把使用不同框架的人丢进去就可以了。这虽然是一个段子，但是折射出来的结论就是：程序员的眼里揉不得沙子。那么在风风火火的前端界，这种争论的存在就更不用说了。\n## 三、一点思考\n上面分析了这么多，只是对前端界的不同观点进行阐述。那么作为知识水平low几个等级的小白们来说，面对纷纷扰扰的前端世界，宝宝应该怎么样去辨析真假，调整自己的学习方向呢？都说web前端正处于一个最好的时代，可是面对眼花缭乱的选择，小白们也许无所适从。从我的角度来讲，首先，我不属于保守派(也没有资格列入任何流派)，我是很欢迎新技术的（毕竟一穷二白，学什么都无所谓）。但是从一个小白的角度来看，最佳的态度应该是将精力放在研究CSS、原生javascript、架构思考等基础知识上，同时要关注业界技术动向，了解新技术的思想和基本用法。至于说是否要对新技术深入研究，可以根据工作业务需要决定，毕竟最适合的才是最好的。如若不然，本末倒置，即使把最新的某项技术研究透了，到最后连CSS兼容都处理不好，那么等到热潮过去之后，新的替代者出现，可能就会发现自己一无所长了。","source":"_posts/一个应届生对近来前端界流派之争的一点思考.md","raw":"title: 一个应届生对近来前端界流派之争的一点思考\ndate: 2016-01-23 20:05:36\ntags: \n    - 前端杂谈\ncategories:\n    - 杂谈\n---\n回家躲避寒潮，忽然发现自己又变成无所事事的状态了。果然以后工作的话，远程办公这种东西不适合我，毕竟在家效率太低。最近几天刷微博的时候发现业界大神们沉寂了十天半月之后也许被寒潮冻出来寂寞感，关于“真伪前端”的话题又被拿出来辩(si)论(bi)了。<!--more-->其实最近两三年关于前端新技术的“抵触”和“拥抱”两种态度一直存在，爆发不少口水大战。尤其是react-native以及ES6在2015年横空出世以后，关于前端工程师的技术栈应该如何构建的话题引发了一轮又一轮的“世界大战”。作为一个还没毕业的应届生前端小白，自己对于业界前辈的华山论剑一直是秉持理性观战、汲取众家所长的态度，毕竟年轻，不敢妄加评论。所以这篇文章的基调也是从毕业生小白的视角对前端领域“真伪前端”话题进行肤浅的总结。\n## 一、现状\n其实对于前端界两种态度的持有者，按照流派划分大约可以对应为“保守派”和“狂热派”。“保守派”的特征是对CSS有深入的研究，可以说是CSS专家；“狂热派”的代表是像淘宝前端团队这样的成熟前端团队成员，他们在javascript和nodejs方面造诣非凡。所以呢，从技术的角度来讲，也可以把两大阵营划分为CSS流派和JS流派。\n“保守派”也不是说这些开发者对于前端技术不欢迎或者抵触什么的，他们的观点是，当前前端的发展有点偏离轨道，前端人员玩像react-native这样的技术是雀占鸠巢，有点不务正业。保守派认为诸如Angular、React-native、SASS这样的热门技术并不能维持长久的适用度，它们必将会像之前的很多曾经火得一塌糊涂的框架一样仅仅是昙花一现，不值得前端开发者去花大量精力研究，而热衷于这些东西的狂热派都是“伪前端”。另外一个批判点就是，当前对于形形色色框架的狂热追捧会导致前端小白迷失方向，随大流去捣鼓RN、Babel这样的技术框架和工具，本末倒置，忽视了对CSS和javascript本身的研究。\n“狂热派”是前端社区比较活跃的存在，他们热衷于捣鼓各类横空出世的新技术，是Facebook、Google以及Twitter等国外互联网企业开源出的新技术的忠实追随者。狂热派大多处于或者曾经处于国内一线互联网企业的成熟团队，工作中接触新技术较多，是实实在在的“技术潮人”。狂热派认为，ES6、react、Webpack这样的新技术是可以真正解决当前的业界痛点，是前端发展的主流和正确方向。他们鄙视还在捣鼓jQuery的前端开发者，认为这是真真切切的“切图仔”，没有真正步入现代前端。狂热派觉得保守派是一批不思进取的懒人，只有新技术才能推动前端的进一步发展。\n## 二、分析\n之所以像现在这样出现两种不同的对立阵营，是因为web前端的发展现在正进入一个全新的时代，一个真正的鼎盛时代，一个技术界的工业革命时代。随着互联网网民增加特别是移动互联网网民的比重逆转PC端网民，大型前端项目在接受来自移动端的大规模访问时出现了相对于PC端时代更大的挑战。移动互联网对流量和速度的极致要求推动了相关技术的迅猛发展。“快”和“省”成为前端开发的技术中心点。所以FB的天才工程师们才会孵化出虚拟DOM这样的前端技术。另外，工业化时代的自动化生产流程也是大型前端项目的产儿，是推动新技术诞生的核心力量。种种因素之下，各种工具和框架满天飞，每天都有新玩意儿出现在github和相关社区。在这样的情况下，一部分业务繁忙的工程师们无暇顾及充斥眼球的各种新名词。一般来说，如果只专注于自己的业务领域的话是根本用不到RN、AG之类的乱七八糟的东西。再加上资深的前端开发者见过太多的新玩意起起落落，大部分昙花一现，所以对当前新技术的热衷潮流不屑一顾的态度也就是自然而然形成了。\n但是呢，另外一批来自成熟团队的成员（也可能是其他类型的开发者），由于他们产品大多数已经成熟，平时的业务范围也就局限于内部框架之上的二次开发，他们的工作重心是造轮子、研究新技术。很自然地，这批人的关注点在于新技术，对业界的新技术也就格外推崇。再加上国内的互联网技术环境决定了前端工程师更多地是使用外国佬的技术而不是创造出颠覆业界的技术，对技术的狂热可以把逼格满满提升几格，何乐而不为呢。\n那为什么程序员那么喜欢争(si)论(bi)？要知道，程序员是一群特立独行的人，骨子里天生就有一种优越感。在码农的世界里，对就是对，错就是错。我认为对的东西你不认同你就是错的，既然你是错的，我就要嘲讽这种错误的存在。所以有人说，毁掉一个团队最简单的办法就是把写java、python和PHP的人都丢进去，这样这个团队基本上就完了。在前端的世界里，要毁掉一个团队也许更简单，把使用不同框架的人丢进去就可以了。这虽然是一个段子，但是折射出来的结论就是：程序员的眼里揉不得沙子。那么在风风火火的前端界，这种争论的存在就更不用说了。\n## 三、一点思考\n上面分析了这么多，只是对前端界的不同观点进行阐述。那么作为知识水平low几个等级的小白们来说，面对纷纷扰扰的前端世界，宝宝应该怎么样去辨析真假，调整自己的学习方向呢？都说web前端正处于一个最好的时代，可是面对眼花缭乱的选择，小白们也许无所适从。从我的角度来讲，首先，我不属于保守派(也没有资格列入任何流派)，我是很欢迎新技术的（毕竟一穷二白，学什么都无所谓）。但是从一个小白的角度来看，最佳的态度应该是将精力放在研究CSS、原生javascript、架构思考等基础知识上，同时要关注业界技术动向，了解新技术的思想和基本用法。至于说是否要对新技术深入研究，可以根据工作业务需要决定，毕竟最适合的才是最好的。如若不然，本末倒置，即使把最新的某项技术研究透了，到最后连CSS兼容都处理不好，那么等到热潮过去之后，新的替代者出现，可能就会发现自己一无所长了。","slug":"一个应届生对近来前端界流派之争的一点思考","published":1,"updated":"2016-08-13T03:08:44.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtro001y7kauijijdulb","content":"<p>回家躲避寒潮，忽然发现自己又变成无所事事的状态了。果然以后工作的话，远程办公这种东西不适合我，毕竟在家效率太低。最近几天刷微博的时候发现业界大神们沉寂了十天半月之后也许被寒潮冻出来寂寞感，关于“真伪前端”的话题又被拿出来辩(si)论(bi)了。<a id=\"more\"></a>其实最近两三年关于前端新技术的“抵触”和“拥抱”两种态度一直存在，爆发不少口水大战。尤其是react-native以及ES6在2015年横空出世以后，关于前端工程师的技术栈应该如何构建的话题引发了一轮又一轮的“世界大战”。作为一个还没毕业的应届生前端小白，自己对于业界前辈的华山论剑一直是秉持理性观战、汲取众家所长的态度，毕竟年轻，不敢妄加评论。所以这篇文章的基调也是从毕业生小白的视角对前端领域“真伪前端”话题进行肤浅的总结。</p>\n<h2 id=\"一、现状\"><a href=\"#一、现状\" class=\"headerlink\" title=\"一、现状\"></a>一、现状</h2><p>其实对于前端界两种态度的持有者，按照流派划分大约可以对应为“保守派”和“狂热派”。“保守派”的特征是对CSS有深入的研究，可以说是CSS专家；“狂热派”的代表是像淘宝前端团队这样的成熟前端团队成员，他们在javascript和nodejs方面造诣非凡。所以呢，从技术的角度来讲，也可以把两大阵营划分为CSS流派和JS流派。<br>“保守派”也不是说这些开发者对于前端技术不欢迎或者抵触什么的，他们的观点是，当前前端的发展有点偏离轨道，前端人员玩像react-native这样的技术是雀占鸠巢，有点不务正业。保守派认为诸如Angular、React-native、SASS这样的热门技术并不能维持长久的适用度，它们必将会像之前的很多曾经火得一塌糊涂的框架一样仅仅是昙花一现，不值得前端开发者去花大量精力研究，而热衷于这些东西的狂热派都是“伪前端”。另外一个批判点就是，当前对于形形色色框架的狂热追捧会导致前端小白迷失方向，随大流去捣鼓RN、Babel这样的技术框架和工具，本末倒置，忽视了对CSS和javascript本身的研究。<br>“狂热派”是前端社区比较活跃的存在，他们热衷于捣鼓各类横空出世的新技术，是Facebook、Google以及Twitter等国外互联网企业开源出的新技术的忠实追随者。狂热派大多处于或者曾经处于国内一线互联网企业的成熟团队，工作中接触新技术较多，是实实在在的“技术潮人”。狂热派认为，ES6、react、Webpack这样的新技术是可以真正解决当前的业界痛点，是前端发展的主流和正确方向。他们鄙视还在捣鼓jQuery的前端开发者，认为这是真真切切的“切图仔”，没有真正步入现代前端。狂热派觉得保守派是一批不思进取的懒人，只有新技术才能推动前端的进一步发展。</p>\n<h2 id=\"二、分析\"><a href=\"#二、分析\" class=\"headerlink\" title=\"二、分析\"></a>二、分析</h2><p>之所以像现在这样出现两种不同的对立阵营，是因为web前端的发展现在正进入一个全新的时代，一个真正的鼎盛时代，一个技术界的工业革命时代。随着互联网网民增加特别是移动互联网网民的比重逆转PC端网民，大型前端项目在接受来自移动端的大规模访问时出现了相对于PC端时代更大的挑战。移动互联网对流量和速度的极致要求推动了相关技术的迅猛发展。“快”和“省”成为前端开发的技术中心点。所以FB的天才工程师们才会孵化出虚拟DOM这样的前端技术。另外，工业化时代的自动化生产流程也是大型前端项目的产儿，是推动新技术诞生的核心力量。种种因素之下，各种工具和框架满天飞，每天都有新玩意儿出现在github和相关社区。在这样的情况下，一部分业务繁忙的工程师们无暇顾及充斥眼球的各种新名词。一般来说，如果只专注于自己的业务领域的话是根本用不到RN、AG之类的乱七八糟的东西。再加上资深的前端开发者见过太多的新玩意起起落落，大部分昙花一现，所以对当前新技术的热衷潮流不屑一顾的态度也就是自然而然形成了。<br>但是呢，另外一批来自成熟团队的成员（也可能是其他类型的开发者），由于他们产品大多数已经成熟，平时的业务范围也就局限于内部框架之上的二次开发，他们的工作重心是造轮子、研究新技术。很自然地，这批人的关注点在于新技术，对业界的新技术也就格外推崇。再加上国内的互联网技术环境决定了前端工程师更多地是使用外国佬的技术而不是创造出颠覆业界的技术，对技术的狂热可以把逼格满满提升几格，何乐而不为呢。<br>那为什么程序员那么喜欢争(si)论(bi)？要知道，程序员是一群特立独行的人，骨子里天生就有一种优越感。在码农的世界里，对就是对，错就是错。我认为对的东西你不认同你就是错的，既然你是错的，我就要嘲讽这种错误的存在。所以有人说，毁掉一个团队最简单的办法就是把写java、python和PHP的人都丢进去，这样这个团队基本上就完了。在前端的世界里，要毁掉一个团队也许更简单，把使用不同框架的人丢进去就可以了。这虽然是一个段子，但是折射出来的结论就是：程序员的眼里揉不得沙子。那么在风风火火的前端界，这种争论的存在就更不用说了。</p>\n<h2 id=\"三、一点思考\"><a href=\"#三、一点思考\" class=\"headerlink\" title=\"三、一点思考\"></a>三、一点思考</h2><p>上面分析了这么多，只是对前端界的不同观点进行阐述。那么作为知识水平low几个等级的小白们来说，面对纷纷扰扰的前端世界，宝宝应该怎么样去辨析真假，调整自己的学习方向呢？都说web前端正处于一个最好的时代，可是面对眼花缭乱的选择，小白们也许无所适从。从我的角度来讲，首先，我不属于保守派(也没有资格列入任何流派)，我是很欢迎新技术的（毕竟一穷二白，学什么都无所谓）。但是从一个小白的角度来看，最佳的态度应该是将精力放在研究CSS、原生javascript、架构思考等基础知识上，同时要关注业界技术动向，了解新技术的思想和基本用法。至于说是否要对新技术深入研究，可以根据工作业务需要决定，毕竟最适合的才是最好的。如若不然，本末倒置，即使把最新的某项技术研究透了，到最后连CSS兼容都处理不好，那么等到热潮过去之后，新的替代者出现，可能就会发现自己一无所长了。</p>\n","excerpt":"<p>回家躲避寒潮，忽然发现自己又变成无所事事的状态了。果然以后工作的话，远程办公这种东西不适合我，毕竟在家效率太低。最近几天刷微博的时候发现业界大神们沉寂了十天半月之后也许被寒潮冻出来寂寞感，关于“真伪前端”的话题又被拿出来辩(si)论(bi)了。","more":"其实最近两三年关于前端新技术的“抵触”和“拥抱”两种态度一直存在，爆发不少口水大战。尤其是react-native以及ES6在2015年横空出世以后，关于前端工程师的技术栈应该如何构建的话题引发了一轮又一轮的“世界大战”。作为一个还没毕业的应届生前端小白，自己对于业界前辈的华山论剑一直是秉持理性观战、汲取众家所长的态度，毕竟年轻，不敢妄加评论。所以这篇文章的基调也是从毕业生小白的视角对前端领域“真伪前端”话题进行肤浅的总结。</p>\n<h2 id=\"一、现状\"><a href=\"#一、现状\" class=\"headerlink\" title=\"一、现状\"></a>一、现状</h2><p>其实对于前端界两种态度的持有者，按照流派划分大约可以对应为“保守派”和“狂热派”。“保守派”的特征是对CSS有深入的研究，可以说是CSS专家；“狂热派”的代表是像淘宝前端团队这样的成熟前端团队成员，他们在javascript和nodejs方面造诣非凡。所以呢，从技术的角度来讲，也可以把两大阵营划分为CSS流派和JS流派。<br>“保守派”也不是说这些开发者对于前端技术不欢迎或者抵触什么的，他们的观点是，当前前端的发展有点偏离轨道，前端人员玩像react-native这样的技术是雀占鸠巢，有点不务正业。保守派认为诸如Angular、React-native、SASS这样的热门技术并不能维持长久的适用度，它们必将会像之前的很多曾经火得一塌糊涂的框架一样仅仅是昙花一现，不值得前端开发者去花大量精力研究，而热衷于这些东西的狂热派都是“伪前端”。另外一个批判点就是，当前对于形形色色框架的狂热追捧会导致前端小白迷失方向，随大流去捣鼓RN、Babel这样的技术框架和工具，本末倒置，忽视了对CSS和javascript本身的研究。<br>“狂热派”是前端社区比较活跃的存在，他们热衷于捣鼓各类横空出世的新技术，是Facebook、Google以及Twitter等国外互联网企业开源出的新技术的忠实追随者。狂热派大多处于或者曾经处于国内一线互联网企业的成熟团队，工作中接触新技术较多，是实实在在的“技术潮人”。狂热派认为，ES6、react、Webpack这样的新技术是可以真正解决当前的业界痛点，是前端发展的主流和正确方向。他们鄙视还在捣鼓jQuery的前端开发者，认为这是真真切切的“切图仔”，没有真正步入现代前端。狂热派觉得保守派是一批不思进取的懒人，只有新技术才能推动前端的进一步发展。</p>\n<h2 id=\"二、分析\"><a href=\"#二、分析\" class=\"headerlink\" title=\"二、分析\"></a>二、分析</h2><p>之所以像现在这样出现两种不同的对立阵营，是因为web前端的发展现在正进入一个全新的时代，一个真正的鼎盛时代，一个技术界的工业革命时代。随着互联网网民增加特别是移动互联网网民的比重逆转PC端网民，大型前端项目在接受来自移动端的大规模访问时出现了相对于PC端时代更大的挑战。移动互联网对流量和速度的极致要求推动了相关技术的迅猛发展。“快”和“省”成为前端开发的技术中心点。所以FB的天才工程师们才会孵化出虚拟DOM这样的前端技术。另外，工业化时代的自动化生产流程也是大型前端项目的产儿，是推动新技术诞生的核心力量。种种因素之下，各种工具和框架满天飞，每天都有新玩意儿出现在github和相关社区。在这样的情况下，一部分业务繁忙的工程师们无暇顾及充斥眼球的各种新名词。一般来说，如果只专注于自己的业务领域的话是根本用不到RN、AG之类的乱七八糟的东西。再加上资深的前端开发者见过太多的新玩意起起落落，大部分昙花一现，所以对当前新技术的热衷潮流不屑一顾的态度也就是自然而然形成了。<br>但是呢，另外一批来自成熟团队的成员（也可能是其他类型的开发者），由于他们产品大多数已经成熟，平时的业务范围也就局限于内部框架之上的二次开发，他们的工作重心是造轮子、研究新技术。很自然地，这批人的关注点在于新技术，对业界的新技术也就格外推崇。再加上国内的互联网技术环境决定了前端工程师更多地是使用外国佬的技术而不是创造出颠覆业界的技术，对技术的狂热可以把逼格满满提升几格，何乐而不为呢。<br>那为什么程序员那么喜欢争(si)论(bi)？要知道，程序员是一群特立独行的人，骨子里天生就有一种优越感。在码农的世界里，对就是对，错就是错。我认为对的东西你不认同你就是错的，既然你是错的，我就要嘲讽这种错误的存在。所以有人说，毁掉一个团队最简单的办法就是把写java、python和PHP的人都丢进去，这样这个团队基本上就完了。在前端的世界里，要毁掉一个团队也许更简单，把使用不同框架的人丢进去就可以了。这虽然是一个段子，但是折射出来的结论就是：程序员的眼里揉不得沙子。那么在风风火火的前端界，这种争论的存在就更不用说了。</p>\n<h2 id=\"三、一点思考\"><a href=\"#三、一点思考\" class=\"headerlink\" title=\"三、一点思考\"></a>三、一点思考</h2><p>上面分析了这么多，只是对前端界的不同观点进行阐述。那么作为知识水平low几个等级的小白们来说，面对纷纷扰扰的前端世界，宝宝应该怎么样去辨析真假，调整自己的学习方向呢？都说web前端正处于一个最好的时代，可是面对眼花缭乱的选择，小白们也许无所适从。从我的角度来讲，首先，我不属于保守派(也没有资格列入任何流派)，我是很欢迎新技术的（毕竟一穷二白，学什么都无所谓）。但是从一个小白的角度来看，最佳的态度应该是将精力放在研究CSS、原生javascript、架构思考等基础知识上，同时要关注业界技术动向，了解新技术的思想和基本用法。至于说是否要对新技术深入研究，可以根据工作业务需要决定，毕竟最适合的才是最好的。如若不然，本末倒置，即使把最新的某项技术研究透了，到最后连CSS兼容都处理不好，那么等到热潮过去之后，新的替代者出现，可能就会发现自己一无所长了。</p>"},{"title":"前端笔试面试中的常用到的CSS知识点总结","date":"2015-12-15T14:41:23.000Z","_content":"在前端开发领域，CSS是比较特殊的一种存在。理论上说，它是一种属性大杂烩，并不属于编程语言的范畴，当然SASS和LESS这两种预编译机制除外。所以CSS的学习是需要不断地去记忆和积累的。在前端笔试和面试过程中，CSS的考察是比较琐碎的，而且往往考察点比较偏，需要我们平时养成做笔记的习惯。这篇文章是我之前发布在慕课社区的一篇小笔记，原文[前端笔试面试中的常用知识点总结(CSS)](http://www.imooc.com/article/2181)，主要记录的是自己在校招过程当中关于CSS知识的总结。\n<!--more-->\n### 1、CSS选择器的优先级\n!important  > 内联 > id选择器 > 类选择器 > 标签选择器\n多个类选择器叠加（256）之后的优先级大于一个id选择器\n!important 用于强调CSS属性具有最高的优先级。IE6不支持这种用法。\nCSS选择器的种类：\n1.id选择器(# myid)\n2.类选择器(.myclassname)\n3.标签选择器(div, h1, p)\n4.相邻选择器(h1 + p)\n5.子选择器(ul > li)\n6.后代选择器(li a)\n7.通配符选择器( * )\n8.属性选择器(a[rel = \"external\"])\n9.伪类选择器(a: hover, li:nth-child)\n### 2、CSS优先级权重计算法\nCSS优先级的计算规则如下：\n元素标签中定义的样式（Style属性）,加1,0,0,0\n每个ID选择符(如 #id),加0,1,0,0\n每个Class选择符、每个属性选择符、每个伪类（:hover）加0,0,1,0\n每个元素选择符（如p）或伪元素选择符(如 :firstchild)等，加0,0,0,1\n然后，将这四个数字分别累加，就得到每个CSS定义的优先级的值\n然后从左到右逐位比较大小，数字大的CSS样式的优先级就高。\n### 3、超链接访问过后hover样式就不出现的问题是什么？如何解决？\n被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）\n### 4、什么是Css Hack？ie6,7,8的hack分别是什么？\n针对不同的浏览器写不同的CSS code的过程，就是CSS hack。常见的hack手法：\n```\n#test       {   \n        width:300px;   \n        height:300px;   \n        background-color:blue;      /*firefox*/\n        background-color:red\\9;      /*all ie*/\n        background-color:yellow\\0;    /*ie8*/\n        +background-color:pink;        /*ie7*/\n        _background-color:orange;       /*ie6*/    }  \n        :root #test { background-color:purple\\9; }  /*ie9*/\n    @media all and (min-width:0px){ \n          #test {background-color:black\\0;} \n     }  /*opera*/\n    @media screen and (-webkit-min-device-pixel-ratio:0){ \n#test {background-color:gray;} \n}       /*chrome and safari*/\n```\n### 5、描述一个\"reset\"的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？\n不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。\n　　你可能会用Normalize来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。\n### 6、display:none与visibility:hidden的区别是什么？\ndisplay : 隐藏对应的元素但不挤占该元素原来的空间。\nvisibility: 隐藏对应的元素并且挤占该元素原来的空间。\n 　　即是，使用CSS display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。\n### 7、CSS盒子模型\nBox Model规定了元素框处理元素内容（element content）、内边距（padding）、边框（border） 和 外边距（margin） 的方式。盒子模型有 block,inline-block,inline,flex,table-cell等几种显示方式。\n![CSS盒模型](http://img.mukewang.com/5649f2ab0001b95904640464.png)\n如图所示，元素的高度和宽度指的是盒子模型的content区域的高度和宽度，不包括内边距以外的部分。(IE的content则是包含border、内边距和content)。盒子模型有两种，W3C标准盒子模型（content-box）以及IE盒子模型（border-box）。\n### 8、相对定位relative、浮动float以及绝对定位absolute的区别？\n1）相对定位是在常规流中的定位。一旦一个框按照常规流或者是浮动得到定位，它还可以相对该位置而偏移， 这就是相对定位。偏移后，在常规流中依然占据原有位置，偏移量并不会对后续的block产生挤占，后续的块就好像没有感知到偏移，依然按照常规流位置排位。\n2）绝对定位（Absolute positioning）元素定位的参照物是其包含块（第一个relative定位的祖先元素）进行定位，不一定是其父元素。绝对定位元素完全脱离了常规流，每个绝对定位的框都可以看做一个单独的图层，不会对其他层框的定位产生影响。绝对元素定位的 top 和 left 值跟绝对元素未脱离常规流之前在常规流中位置有关。\n3）浮动框就是一个框在当前行被向左或向右挪动(偏移)，它不在常规流中。在该浮动框之前或之后创建的非定位框垂直排列，就好象浮动框并不存在一样。当前行里浮动框前的任何内容，都将被重新排列到该浮动另一侧的第一个可用行里。\n### 9、清除浮动的用法？\n在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。\n使用方法：\n1、在浮动元素后使用一个空元素如<div class=\"clear\"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。\n2、给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动\n3、什么都不做，给浮动元素后面的元素添加clear属性。\n4、利用伪类清除浮动，给浮动元素的容器添加一个clearfix的class，然 后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。\n```\n//一种常见利用伪类清除浮动的代码\n .clearfix:after {\n    content:\".\";       //这里利用到了content属性\n    display:block; \n    height:0;\n    visibility:hidden; \n    clear:both; \n}\n.clearfix { \n    *zoom:1; \n}\n```\n### 10、BOX模型的margin在IE比在其他浏览器大2px的解决办法\n\ndiv{margin:30px!important;margin:28px;}\n注意这两个margin的顺序一定不能写反，据阿捷的说法!important这个 属性IE不能识别，但别的浏览器可以识别。所以在IE下其实解释成这样：\n```\ndiv{maring:30px;margin:28px}\n```\n重复定义的话按照最后一个来执行，所以不可以只写\n```\nmargin:XXpx!important;\n```\n也可以这样子hack\n```\ndiv { _margin:28px;margin:28px\\9;margin:30px;}\n```\n### 11、IE 3像素Bug的产生原因及解决办法\n当在同一行相邻出现一个浮动的块元素和一个非浮动的块元素时，两块元素之间就会出现3px的裂痕。\n解决办法就是：对其中一个元素添加“_margin-*:-3px”的CSS属性，或者将另外一个非浮动的元素设为浮动。\n\n### 12、IE6 双边距Bug的产生原因及解决办法\n当我们在浮动元素上面添加margin-*的属性的时候，比如在float:left的元素CSS添加margin-left:50px，那么最终在IE6下面的显示就是该元素的margin-left最终变为100px，边距翻倍。\n解决办法：添加_display:inline\n\n### 13、FOUC - Flash Of Unstyled Content 文档样式闪烁\n```\n<style type=\"text/css\" media=\"all\">@import \"../fouc.css\";</style> \n```\n而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。\n解决方法简单的出奇，只要在 head 之间加入一个 link 或者 script 元素就可以了。\n\n### 14、文本溢出省略的处理方法\n1)单行文本溢出\n```\n.inline{\n  overflow:hidden;\n         white-space:nowrap;\n         text-overflow:ellipsis; \n}\n```\n2)多行文本溢出\n```\n.foo{\n  display:-webkit-box!important;\n  overflow:hidden;\n  text-overflow:ellipsis;\n  work-break:break-all;\n  -webkit-box-orient:vertical; /*方向*/\n  -webkit-line-clamp:4; /*显示多少行文本*/\n}\n```\n但是这里只适用于webkit内核浏览器，不兼容IE和其他非webkit浏览器。\n\n### 15、CSS实现垂直水平居中\n方法1：\n```\n.parent {\n          width:800px;\n          height:500px;\n          border:2px solid #000;\n          position:relative;\n}\n .child {\n        width:200px;\n        height:200px;\n        margin: auto;  \n        position: absolute;  \n        top: 0; left: 0; bottom: 0; right: 0; \n        background-color: red;\n}\n```\n方法2：\n```\n    .parent {\n        width:800px;\n        height:500px;\n        border:2px solid #000;\n        display:table-cell;\n        vertical-align:middle;\n        text-align: center;\n    }\n    .child {\n        width:200px;\n        height:200px;\n        display:inline-block;\n        background-color: red;\n    }\n```\n方法3：\n```\n    .parent {\n        width:800px;\n        height:500px;\n        border:2px solid #000;\n        display:flex;\n        justify-content:center;\n        align-items:center;\n    }\n    .child {\n        width:200px;\n        height:200px;\n        background-color: red;\n    }\n```\n方法4：\n```\n    .parent {\n            width:800px;\n            height:500px;\n            border:2px solid #000;\n            position:relative;\n        }\n    .child {\n        width:300px;\n        height:200px;\n        margin:auto;\n        position:absolute;\n    //设定水平和垂直偏移父元素的50%，\n    //再根据实际长度将子元素上左挪回一半大小\n        left:50%;\n        top:50%;\n        margin-left: -150px;\n        margin-top:-100px;\n        background-color: red;\n    }  \n```\n### 16、BFC\n块格式上下文是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。\n\nBFC的创建方法：\n根元素或其它包含它的元素；\n浮动 (元素的float不为none)；\n绝对定位元素 (元素的position为absolute或fixed)；\n行内块inline-blocks(元素的 display: inline-block)；\n表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；\noverflow的值不为visible的元素；\n弹性盒 flex boxes (元素的display: flex或inline-flex)；\n\n### 17、响应式图片的CSS\n所谓响应式图片，就是根据图片所在容器的大小来实时地按比例缩放。实现的办法非常简单，只需要设置img标签的width:100%即可。\n```\nimg {\nwidth:100%;\n}\n```\n如果 max-width 属性设置为 100%, 图片永远不会大于其原始大小：\n```\nimg {\nmax-width: 100%;\n}\n```\n### 18、CSS响应式网格系统原理\n总的来说，网格系统就是利用百分比把视口等分为12个，然后利用float属性使之并列显示。\n```\n* {\n    box-sizing: border-box;\n}\n[class*=\"col-\"] {\n    float: left;\n    padding: 15px;\n    border: 1px solid red;\n}\n.col-1 {width: 8.33%;}\n.col-2 {width: 16.66%;}\n.col-3 {width: 25%;}\n.col-4 {width: 33.33%;}\n.col-5 {width: 41.66%;}\n.col-6 {width: 50%;}\n.col-7 {width: 58.33%;}\n.col-8 {width: 66.66%;}\n.col-9 {width: 75%;}\n.col-10 {width: 83.33%;}\n.col-11 {width: 91.66%;}\n.col-12 {width: 100%;}\n```\n### 19、用LESS循环实现栅格类\n```\n.generate-columns(12);\n.generate-columns(@n; @i: 1) when (@i =< @n) {\n  .column-@{i} {\n    width: (@i * 100% / @n);\n  }\n.generate-columns(@n, (@i + 1));\n}\n```\n### 20、使用perspective属性和transform：perspective()函数的区别\n以上的两种书写格式都会生成一个3D立体效果，但是它们之间有一些区别。使用功能函数的方式可以很方便的在单个元素上应用3D transform，但是当在多个元素上使用时，转换的元素不会得到预期的效果。如果你为不同的元素使用相同的transform，每一个元素都会有自己的消失点。为了解决这个问题，可以在父元素上使用perspective属性，这样，所有的子元素都可以共享同一个3D空间。\nperspective-origin: 25% 75%，等价于perspective-origin x和perspective-origin y的合体，用来设置镜头聚焦点的位置(舞台中心)\ntransform-style: preserve-3d,transform-style属性也是3D效果中经常使用的，其两个参数，flat|preserve-3d. 前者flat为默认值，表示平面的；后者preserve-3d表示3D透视。\nbackface-visibility：hidden|visibility设置背后元素是否可见\n","source":"_posts/前端笔试面试中的常用到的CSS知识点总结.md","raw":"title: 前端笔试面试中的常用到的CSS知识点总结\ndate: 2015-12-15 22:41:23\ntags:\n    - css\ncategories:\n    - 前端开发\n---\n在前端开发领域，CSS是比较特殊的一种存在。理论上说，它是一种属性大杂烩，并不属于编程语言的范畴，当然SASS和LESS这两种预编译机制除外。所以CSS的学习是需要不断地去记忆和积累的。在前端笔试和面试过程中，CSS的考察是比较琐碎的，而且往往考察点比较偏，需要我们平时养成做笔记的习惯。这篇文章是我之前发布在慕课社区的一篇小笔记，原文[前端笔试面试中的常用知识点总结(CSS)](http://www.imooc.com/article/2181)，主要记录的是自己在校招过程当中关于CSS知识的总结。\n<!--more-->\n### 1、CSS选择器的优先级\n!important  > 内联 > id选择器 > 类选择器 > 标签选择器\n多个类选择器叠加（256）之后的优先级大于一个id选择器\n!important 用于强调CSS属性具有最高的优先级。IE6不支持这种用法。\nCSS选择器的种类：\n1.id选择器(# myid)\n2.类选择器(.myclassname)\n3.标签选择器(div, h1, p)\n4.相邻选择器(h1 + p)\n5.子选择器(ul > li)\n6.后代选择器(li a)\n7.通配符选择器( * )\n8.属性选择器(a[rel = \"external\"])\n9.伪类选择器(a: hover, li:nth-child)\n### 2、CSS优先级权重计算法\nCSS优先级的计算规则如下：\n元素标签中定义的样式（Style属性）,加1,0,0,0\n每个ID选择符(如 #id),加0,1,0,0\n每个Class选择符、每个属性选择符、每个伪类（:hover）加0,0,1,0\n每个元素选择符（如p）或伪元素选择符(如 :firstchild)等，加0,0,0,1\n然后，将这四个数字分别累加，就得到每个CSS定义的优先级的值\n然后从左到右逐位比较大小，数字大的CSS样式的优先级就高。\n### 3、超链接访问过后hover样式就不出现的问题是什么？如何解决？\n被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）\n### 4、什么是Css Hack？ie6,7,8的hack分别是什么？\n针对不同的浏览器写不同的CSS code的过程，就是CSS hack。常见的hack手法：\n```\n#test       {   \n        width:300px;   \n        height:300px;   \n        background-color:blue;      /*firefox*/\n        background-color:red\\9;      /*all ie*/\n        background-color:yellow\\0;    /*ie8*/\n        +background-color:pink;        /*ie7*/\n        _background-color:orange;       /*ie6*/    }  \n        :root #test { background-color:purple\\9; }  /*ie9*/\n    @media all and (min-width:0px){ \n          #test {background-color:black\\0;} \n     }  /*opera*/\n    @media screen and (-webkit-min-device-pixel-ratio:0){ \n#test {background-color:gray;} \n}       /*chrome and safari*/\n```\n### 5、描述一个\"reset\"的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？\n不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。\n　　你可能会用Normalize来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。\n### 6、display:none与visibility:hidden的区别是什么？\ndisplay : 隐藏对应的元素但不挤占该元素原来的空间。\nvisibility: 隐藏对应的元素并且挤占该元素原来的空间。\n 　　即是，使用CSS display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。\n### 7、CSS盒子模型\nBox Model规定了元素框处理元素内容（element content）、内边距（padding）、边框（border） 和 外边距（margin） 的方式。盒子模型有 block,inline-block,inline,flex,table-cell等几种显示方式。\n![CSS盒模型](http://img.mukewang.com/5649f2ab0001b95904640464.png)\n如图所示，元素的高度和宽度指的是盒子模型的content区域的高度和宽度，不包括内边距以外的部分。(IE的content则是包含border、内边距和content)。盒子模型有两种，W3C标准盒子模型（content-box）以及IE盒子模型（border-box）。\n### 8、相对定位relative、浮动float以及绝对定位absolute的区别？\n1）相对定位是在常规流中的定位。一旦一个框按照常规流或者是浮动得到定位，它还可以相对该位置而偏移， 这就是相对定位。偏移后，在常规流中依然占据原有位置，偏移量并不会对后续的block产生挤占，后续的块就好像没有感知到偏移，依然按照常规流位置排位。\n2）绝对定位（Absolute positioning）元素定位的参照物是其包含块（第一个relative定位的祖先元素）进行定位，不一定是其父元素。绝对定位元素完全脱离了常规流，每个绝对定位的框都可以看做一个单独的图层，不会对其他层框的定位产生影响。绝对元素定位的 top 和 left 值跟绝对元素未脱离常规流之前在常规流中位置有关。\n3）浮动框就是一个框在当前行被向左或向右挪动(偏移)，它不在常规流中。在该浮动框之前或之后创建的非定位框垂直排列，就好象浮动框并不存在一样。当前行里浮动框前的任何内容，都将被重新排列到该浮动另一侧的第一个可用行里。\n### 9、清除浮动的用法？\n在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。\n使用方法：\n1、在浮动元素后使用一个空元素如<div class=\"clear\"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。\n2、给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动\n3、什么都不做，给浮动元素后面的元素添加clear属性。\n4、利用伪类清除浮动，给浮动元素的容器添加一个clearfix的class，然 后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。\n```\n//一种常见利用伪类清除浮动的代码\n .clearfix:after {\n    content:\".\";       //这里利用到了content属性\n    display:block; \n    height:0;\n    visibility:hidden; \n    clear:both; \n}\n.clearfix { \n    *zoom:1; \n}\n```\n### 10、BOX模型的margin在IE比在其他浏览器大2px的解决办法\n\ndiv{margin:30px!important;margin:28px;}\n注意这两个margin的顺序一定不能写反，据阿捷的说法!important这个 属性IE不能识别，但别的浏览器可以识别。所以在IE下其实解释成这样：\n```\ndiv{maring:30px;margin:28px}\n```\n重复定义的话按照最后一个来执行，所以不可以只写\n```\nmargin:XXpx!important;\n```\n也可以这样子hack\n```\ndiv { _margin:28px;margin:28px\\9;margin:30px;}\n```\n### 11、IE 3像素Bug的产生原因及解决办法\n当在同一行相邻出现一个浮动的块元素和一个非浮动的块元素时，两块元素之间就会出现3px的裂痕。\n解决办法就是：对其中一个元素添加“_margin-*:-3px”的CSS属性，或者将另外一个非浮动的元素设为浮动。\n\n### 12、IE6 双边距Bug的产生原因及解决办法\n当我们在浮动元素上面添加margin-*的属性的时候，比如在float:left的元素CSS添加margin-left:50px，那么最终在IE6下面的显示就是该元素的margin-left最终变为100px，边距翻倍。\n解决办法：添加_display:inline\n\n### 13、FOUC - Flash Of Unstyled Content 文档样式闪烁\n```\n<style type=\"text/css\" media=\"all\">@import \"../fouc.css\";</style> \n```\n而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。\n解决方法简单的出奇，只要在 head 之间加入一个 link 或者 script 元素就可以了。\n\n### 14、文本溢出省略的处理方法\n1)单行文本溢出\n```\n.inline{\n  overflow:hidden;\n         white-space:nowrap;\n         text-overflow:ellipsis; \n}\n```\n2)多行文本溢出\n```\n.foo{\n  display:-webkit-box!important;\n  overflow:hidden;\n  text-overflow:ellipsis;\n  work-break:break-all;\n  -webkit-box-orient:vertical; /*方向*/\n  -webkit-line-clamp:4; /*显示多少行文本*/\n}\n```\n但是这里只适用于webkit内核浏览器，不兼容IE和其他非webkit浏览器。\n\n### 15、CSS实现垂直水平居中\n方法1：\n```\n.parent {\n          width:800px;\n          height:500px;\n          border:2px solid #000;\n          position:relative;\n}\n .child {\n        width:200px;\n        height:200px;\n        margin: auto;  \n        position: absolute;  \n        top: 0; left: 0; bottom: 0; right: 0; \n        background-color: red;\n}\n```\n方法2：\n```\n    .parent {\n        width:800px;\n        height:500px;\n        border:2px solid #000;\n        display:table-cell;\n        vertical-align:middle;\n        text-align: center;\n    }\n    .child {\n        width:200px;\n        height:200px;\n        display:inline-block;\n        background-color: red;\n    }\n```\n方法3：\n```\n    .parent {\n        width:800px;\n        height:500px;\n        border:2px solid #000;\n        display:flex;\n        justify-content:center;\n        align-items:center;\n    }\n    .child {\n        width:200px;\n        height:200px;\n        background-color: red;\n    }\n```\n方法4：\n```\n    .parent {\n            width:800px;\n            height:500px;\n            border:2px solid #000;\n            position:relative;\n        }\n    .child {\n        width:300px;\n        height:200px;\n        margin:auto;\n        position:absolute;\n    //设定水平和垂直偏移父元素的50%，\n    //再根据实际长度将子元素上左挪回一半大小\n        left:50%;\n        top:50%;\n        margin-left: -150px;\n        margin-top:-100px;\n        background-color: red;\n    }  \n```\n### 16、BFC\n块格式上下文是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。\n\nBFC的创建方法：\n根元素或其它包含它的元素；\n浮动 (元素的float不为none)；\n绝对定位元素 (元素的position为absolute或fixed)；\n行内块inline-blocks(元素的 display: inline-block)；\n表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；\noverflow的值不为visible的元素；\n弹性盒 flex boxes (元素的display: flex或inline-flex)；\n\n### 17、响应式图片的CSS\n所谓响应式图片，就是根据图片所在容器的大小来实时地按比例缩放。实现的办法非常简单，只需要设置img标签的width:100%即可。\n```\nimg {\nwidth:100%;\n}\n```\n如果 max-width 属性设置为 100%, 图片永远不会大于其原始大小：\n```\nimg {\nmax-width: 100%;\n}\n```\n### 18、CSS响应式网格系统原理\n总的来说，网格系统就是利用百分比把视口等分为12个，然后利用float属性使之并列显示。\n```\n* {\n    box-sizing: border-box;\n}\n[class*=\"col-\"] {\n    float: left;\n    padding: 15px;\n    border: 1px solid red;\n}\n.col-1 {width: 8.33%;}\n.col-2 {width: 16.66%;}\n.col-3 {width: 25%;}\n.col-4 {width: 33.33%;}\n.col-5 {width: 41.66%;}\n.col-6 {width: 50%;}\n.col-7 {width: 58.33%;}\n.col-8 {width: 66.66%;}\n.col-9 {width: 75%;}\n.col-10 {width: 83.33%;}\n.col-11 {width: 91.66%;}\n.col-12 {width: 100%;}\n```\n### 19、用LESS循环实现栅格类\n```\n.generate-columns(12);\n.generate-columns(@n; @i: 1) when (@i =< @n) {\n  .column-@{i} {\n    width: (@i * 100% / @n);\n  }\n.generate-columns(@n, (@i + 1));\n}\n```\n### 20、使用perspective属性和transform：perspective()函数的区别\n以上的两种书写格式都会生成一个3D立体效果，但是它们之间有一些区别。使用功能函数的方式可以很方便的在单个元素上应用3D transform，但是当在多个元素上使用时，转换的元素不会得到预期的效果。如果你为不同的元素使用相同的transform，每一个元素都会有自己的消失点。为了解决这个问题，可以在父元素上使用perspective属性，这样，所有的子元素都可以共享同一个3D空间。\nperspective-origin: 25% 75%，等价于perspective-origin x和perspective-origin y的合体，用来设置镜头聚焦点的位置(舞台中心)\ntransform-style: preserve-3d,transform-style属性也是3D效果中经常使用的，其两个参数，flat|preserve-3d. 前者flat为默认值，表示平面的；后者preserve-3d表示3D透视。\nbackface-visibility：hidden|visibility设置背后元素是否可见\n","slug":"前端笔试面试中的常用到的CSS知识点总结","published":1,"updated":"2016-08-13T03:08:44.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtrq00217kauzigm2ha1","content":"<p>在前端开发领域，CSS是比较特殊的一种存在。理论上说，它是一种属性大杂烩，并不属于编程语言的范畴，当然SASS和LESS这两种预编译机制除外。所以CSS的学习是需要不断地去记忆和积累的。在前端笔试和面试过程中，CSS的考察是比较琐碎的，而且往往考察点比较偏，需要我们平时养成做笔记的习惯。这篇文章是我之前发布在慕课社区的一篇小笔记，原文<a href=\"http://www.imooc.com/article/2181\" target=\"_blank\" rel=\"external\">前端笔试面试中的常用知识点总结(CSS)</a>，主要记录的是自己在校招过程当中关于CSS知识的总结。<br><a id=\"more\"></a></p>\n<h3 id=\"1、CSS选择器的优先级\"><a href=\"#1、CSS选择器的优先级\" class=\"headerlink\" title=\"1、CSS选择器的优先级\"></a>1、CSS选择器的优先级</h3><p>!important  &gt; 内联 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器<br>多个类选择器叠加（256）之后的优先级大于一个id选择器<br>!important 用于强调CSS属性具有最高的优先级。IE6不支持这种用法。<br>CSS选择器的种类：<br>1.id选择器(# myid)<br>2.类选择器(.myclassname)<br>3.标签选择器(div, h1, p)<br>4.相邻选择器(h1 + p)<br>5.子选择器(ul &gt; li)<br>6.后代选择器(li a)<br>7.通配符选择器( * )<br>8.属性选择器(a[rel = “external”])<br>9.伪类选择器(a: hover, li:nth-child)</p>\n<h3 id=\"2、CSS优先级权重计算法\"><a href=\"#2、CSS优先级权重计算法\" class=\"headerlink\" title=\"2、CSS优先级权重计算法\"></a>2、CSS优先级权重计算法</h3><p>CSS优先级的计算规则如下：<br>元素标签中定义的样式（Style属性）,加1,0,0,0<br>每个ID选择符(如 #id),加0,1,0,0<br>每个Class选择符、每个属性选择符、每个伪类（:hover）加0,0,1,0<br>每个元素选择符（如p）或伪元素选择符(如 :firstchild)等，加0,0,0,1<br>然后，将这四个数字分别累加，就得到每个CSS定义的优先级的值<br>然后从左到右逐位比较大小，数字大的CSS样式的优先级就高。</p>\n<h3 id=\"3、超链接访问过后hover样式就不出现的问题是什么？如何解决？\"><a href=\"#3、超链接访问过后hover样式就不出现的问题是什么？如何解决？\" class=\"headerlink\" title=\"3、超链接访问过后hover样式就不出现的问题是什么？如何解决？\"></a>3、超链接访问过后hover样式就不出现的问题是什么？如何解决？</h3><p>被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）</p>\n<h3 id=\"4、什么是Css-Hack？ie6-7-8的hack分别是什么？\"><a href=\"#4、什么是Css-Hack？ie6-7-8的hack分别是什么？\" class=\"headerlink\" title=\"4、什么是Css Hack？ie6,7,8的hack分别是什么？\"></a>4、什么是Css Hack？ie6,7,8的hack分别是什么？</h3><p>针对不同的浏览器写不同的CSS code的过程，就是CSS hack。常见的hack手法：<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#test</span>       &#123;   </div><div class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">300px</span>;   </div><div class=\"line\">        <span class=\"attribute\">height</span>:<span class=\"number\">300px</span>;   </div><div class=\"line\">        <span class=\"attribute\">background-color</span>:blue;      <span class=\"comment\">/*firefox*/</span></div><div class=\"line\">        <span class=\"attribute\">background-color</span>:red\\<span class=\"number\">9</span>;      <span class=\"comment\">/*all ie*/</span></div><div class=\"line\">        <span class=\"attribute\">background-color</span>:yellow\\<span class=\"number\">0</span>;    <span class=\"comment\">/*ie8*/</span></div><div class=\"line\">        +<span class=\"attribute\">background-color</span>:pink;        <span class=\"comment\">/*ie7*/</span></div><div class=\"line\">        _background-<span class=\"attribute\">color</span>:orange;       <span class=\"comment\">/*ie6*/</span>    &#125;  </div><div class=\"line\">        :root <span class=\"selector-id\">#test</span> &#123; <span class=\"attribute\">background-color</span>:purple\\<span class=\"number\">9</span>; &#125;  <span class=\"comment\">/*ie9*/</span></div><div class=\"line\">    @<span class=\"keyword\">media</span> all and (min-width:<span class=\"number\">0px</span>)&#123; </div><div class=\"line\">          <span class=\"selector-id\">#test</span> &#123;<span class=\"attribute\">background-color</span>:black\\<span class=\"number\">0</span>;&#125; </div><div class=\"line\">     &#125;  <span class=\"comment\">/*opera*/</span></div><div class=\"line\">    @<span class=\"keyword\">media</span> screen and (-webkit-min-device-pixel-ratio:<span class=\"number\">0</span>)&#123; </div><div class=\"line\"><span class=\"selector-id\">#test</span> &#123;<span class=\"attribute\">background-color</span>:gray;&#125; </div><div class=\"line\">&#125;       <span class=\"comment\">/*chrome and safari*/</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"5、描述一个”reset”的CSS文件并如何使用它。知道normalize-css吗？你了解他们的不同之处？\"><a href=\"#5、描述一个”reset”的CSS文件并如何使用它。知道normalize-css吗？你了解他们的不同之处？\" class=\"headerlink\" title=\"5、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？\"></a>5、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？</h3><p>不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。<br>　　你可能会用Normalize来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。</p>\n<h3 id=\"6、display-none与visibility-hidden的区别是什么？\"><a href=\"#6、display-none与visibility-hidden的区别是什么？\" class=\"headerlink\" title=\"6、display:none与visibility:hidden的区别是什么？\"></a>6、display:none与visibility:hidden的区别是什么？</h3><p>display : 隐藏对应的元素但不挤占该元素原来的空间。<br>visibility: 隐藏对应的元素并且挤占该元素原来的空间。<br> 　　即是，使用CSS display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。</p>\n<h3 id=\"7、CSS盒子模型\"><a href=\"#7、CSS盒子模型\" class=\"headerlink\" title=\"7、CSS盒子模型\"></a>7、CSS盒子模型</h3><p>Box Model规定了元素框处理元素内容（element content）、内边距（padding）、边框（border） 和 外边距（margin） 的方式。盒子模型有 block,inline-block,inline,flex,table-cell等几种显示方式。<br><img src=\"http://img.mukewang.com/5649f2ab0001b95904640464.png\" alt=\"CSS盒模型\"><br>如图所示，元素的高度和宽度指的是盒子模型的content区域的高度和宽度，不包括内边距以外的部分。(IE的content则是包含border、内边距和content)。盒子模型有两种，W3C标准盒子模型（content-box）以及IE盒子模型（border-box）。</p>\n<h3 id=\"8、相对定位relative、浮动float以及绝对定位absolute的区别？\"><a href=\"#8、相对定位relative、浮动float以及绝对定位absolute的区别？\" class=\"headerlink\" title=\"8、相对定位relative、浮动float以及绝对定位absolute的区别？\"></a>8、相对定位relative、浮动float以及绝对定位absolute的区别？</h3><p>1）相对定位是在常规流中的定位。一旦一个框按照常规流或者是浮动得到定位，它还可以相对该位置而偏移， 这就是相对定位。偏移后，在常规流中依然占据原有位置，偏移量并不会对后续的block产生挤占，后续的块就好像没有感知到偏移，依然按照常规流位置排位。<br>2）绝对定位（Absolute positioning）元素定位的参照物是其包含块（第一个relative定位的祖先元素）进行定位，不一定是其父元素。绝对定位元素完全脱离了常规流，每个绝对定位的框都可以看做一个单独的图层，不会对其他层框的定位产生影响。绝对元素定位的 top 和 left 值跟绝对元素未脱离常规流之前在常规流中位置有关。<br>3）浮动框就是一个框在当前行被向左或向右挪动(偏移)，它不在常规流中。在该浮动框之前或之后创建的非定位框垂直排列，就好象浮动框并不存在一样。当前行里浮动框前的任何内容，都将被重新排列到该浮动另一侧的第一个可用行里。</p>\n<h3 id=\"9、清除浮动的用法？\"><a href=\"#9、清除浮动的用法？\" class=\"headerlink\" title=\"9、清除浮动的用法？\"></a>9、清除浮动的用法？</h3><p>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。<br>使用方法：<br>1、在浮动元素后使用一个空元素如<div class=\"clear\"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。<br>2、给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动<br>3、什么都不做，给浮动元素后面的元素添加clear属性。<br>4、利用伪类清除浮动，给浮动元素的容器添加一个clearfix的class，然 后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//一种常见利用伪类清除浮动的代码</span></div><div class=\"line\"> <span class=\"selector-class\">.clearfix</span>:after &#123;</div><div class=\"line\">    <span class=\"attribute\">content</span>:<span class=\"string\">\".\"</span>;       <span class=\"comment\">//这里利用到了content属性</span></div><div class=\"line\">    <span class=\"attribute\">display</span>:block; </div><div class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">visibility</span>:hidden; </div><div class=\"line\">    <span class=\"attribute\">clear</span>:both; </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.clearfix</span> &#123; </div><div class=\"line\">    *zoom:<span class=\"number\">1</span>; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"10、BOX模型的margin在IE比在其他浏览器大2px的解决办法\"><a href=\"#10、BOX模型的margin在IE比在其他浏览器大2px的解决办法\" class=\"headerlink\" title=\"10、BOX模型的margin在IE比在其他浏览器大2px的解决办法\"></a>10、BOX模型的margin在IE比在其他浏览器大2px的解决办法</h3><p>div{margin:30px!important;margin:28px;}<br>注意这两个margin的顺序一定不能写反，据阿捷的说法!important这个 属性IE不能识别，但别的浏览器可以识别。所以在IE下其实解释成这样：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">div</span>&#123;<span class=\"attribute\">maring</span>:<span class=\"number\">30px</span>;<span class=\"attribute\">margin</span>:<span class=\"number\">28px</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>重复定义的话按照最后一个来执行，所以不可以只写<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">margin</span>:XXpx<span class=\"meta\">!important</span>;</div></pre></td></tr></table></figure></p>\n<p>也可以这样子hack<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">div</span> &#123; <span class=\"attribute\">_margin</span>:<span class=\"number\">28px</span>;<span class=\"attribute\">margin</span>:<span class=\"number\">28px</span>\\<span class=\"number\">9</span>;<span class=\"attribute\">margin</span>:<span class=\"number\">30px</span>;&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"11、IE-3像素Bug的产生原因及解决办法\"><a href=\"#11、IE-3像素Bug的产生原因及解决办法\" class=\"headerlink\" title=\"11、IE 3像素Bug的产生原因及解决办法\"></a>11、IE 3像素Bug的产生原因及解决办法</h3><p>当在同一行相邻出现一个浮动的块元素和一个非浮动的块元素时，两块元素之间就会出现3px的裂痕。<br>解决办法就是：对其中一个元素添加“_margin-*:-3px”的CSS属性，或者将另外一个非浮动的元素设为浮动。</p>\n<h3 id=\"12、IE6-双边距Bug的产生原因及解决办法\"><a href=\"#12、IE6-双边距Bug的产生原因及解决办法\" class=\"headerlink\" title=\"12、IE6 双边距Bug的产生原因及解决办法\"></a>12、IE6 双边距Bug的产生原因及解决办法</h3><p>当我们在浮动元素上面添加margin-*的属性的时候，比如在float:left的元素CSS添加margin-left:50px，那么最终在IE6下面的显示就是该元素的margin-left最终变为100px，边距翻倍。<br>解决办法：添加_display:inline</p>\n<h3 id=\"13、FOUC-Flash-Of-Unstyled-Content-文档样式闪烁\"><a href=\"#13、FOUC-Flash-Of-Unstyled-Content-文档样式闪烁\" class=\"headerlink\" title=\"13、FOUC - Flash Of Unstyled Content 文档样式闪烁\"></a>13、FOUC - Flash Of Unstyled Content 文档样式闪烁</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"all\"</span>&gt;</span><span class=\"css\">@<span class=\"keyword\">import</span> <span class=\"string\">\"../fouc.css\"</span>;</span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。<br>解决方法简单的出奇，只要在 head 之间加入一个 link 或者 script 元素就可以了。</p>\n<h3 id=\"14、文本溢出省略的处理方法\"><a href=\"#14、文本溢出省略的处理方法\" class=\"headerlink\" title=\"14、文本溢出省略的处理方法\"></a>14、文本溢出省略的处理方法</h3><p>1)单行文本溢出<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.inline</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">overflow</span>:hidden;</div><div class=\"line\">         <span class=\"attribute\">white-space</span>:nowrap;</div><div class=\"line\">         <span class=\"attribute\">text-overflow</span>:ellipsis; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>2)多行文本溢出<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.foo</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>:-webkit-box<span class=\"meta\">!important</span>;</div><div class=\"line\">  <span class=\"attribute\">overflow</span>:hidden;</div><div class=\"line\">  <span class=\"attribute\">text-overflow</span>:ellipsis;</div><div class=\"line\">  <span class=\"attribute\">work-break</span>:break-all;</div><div class=\"line\">  <span class=\"attribute\">-webkit-box-orient</span>:vertical; <span class=\"comment\">/*方向*/</span></div><div class=\"line\">  <span class=\"attribute\">-webkit-line-clamp</span>:<span class=\"number\">4</span>; <span class=\"comment\">/*显示多少行文本*/</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>但是这里只适用于webkit内核浏览器，不兼容IE和其他非webkit浏览器。</p>\n<h3 id=\"15、CSS实现垂直水平居中\"><a href=\"#15、CSS实现垂直水平居中\" class=\"headerlink\" title=\"15、CSS实现垂直水平居中\"></a>15、CSS实现垂直水平居中</h3><p>方法1：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">          <span class=\"attribute\">width</span>:<span class=\"number\">800px</span>;</div><div class=\"line\">          <span class=\"attribute\">height</span>:<span class=\"number\">500px</span>;</div><div class=\"line\">          <span class=\"attribute\">border</span>:<span class=\"number\">2px</span> solid <span class=\"number\">#000</span>;</div><div class=\"line\">          <span class=\"attribute\">position</span>:relative;</div><div class=\"line\">&#125;</div><div class=\"line\"> <span class=\"selector-class\">.child</span> &#123;</div><div class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</div><div class=\"line\">        <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</div><div class=\"line\">        <span class=\"attribute\">margin</span>: auto;  </div><div class=\"line\">        <span class=\"attribute\">position</span>: absolute;  </div><div class=\"line\">        <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>; <span class=\"attribute\">right</span>: <span class=\"number\">0</span>; </div><div class=\"line\">        <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>方法2：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">800px</span>;</div><div class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">500px</span>;</div><div class=\"line\">    <span class=\"attribute\">border</span>:<span class=\"number\">2px</span> solid <span class=\"number\">#000</span>;</div><div class=\"line\">    <span class=\"attribute\">display</span>:table-cell;</div><div class=\"line\">    <span class=\"attribute\">vertical-align</span>:middle;</div><div class=\"line\">    <span class=\"attribute\">text-align</span>: center;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.child</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">display</span>:inline-block;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>方法3：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">800px</span>;</div><div class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">500px</span>;</div><div class=\"line\">    <span class=\"attribute\">border</span>:<span class=\"number\">2px</span> solid <span class=\"number\">#000</span>;</div><div class=\"line\">    <span class=\"attribute\">display</span>:flex;</div><div class=\"line\">    <span class=\"attribute\">justify-content</span>:center;</div><div class=\"line\">    <span class=\"attribute\">align-items</span>:center;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.child</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>方法4：<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">800px</span>;</div><div class=\"line\">        <span class=\"attribute\">height</span>:<span class=\"number\">500px</span>;</div><div class=\"line\">        <span class=\"attribute\">border</span>:<span class=\"number\">2px</span> solid <span class=\"number\">#000</span>;</div><div class=\"line\">        <span class=\"attribute\">position</span>:relative;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"selector-class\">.child</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">300px</span>;</div><div class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">margin</span>:auto;</div><div class=\"line\">    <span class=\"attribute\">position</span>:absolute;</div><div class=\"line\"><span class=\"comment\">//设定水平和垂直偏移父元素的50%，</span></div><div class=\"line\"><span class=\"comment\">//再根据实际长度将子元素上左挪回一半大小</span></div><div class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">50%</span>;</div><div class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">50%</span>;</div><div class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">150px</span>;</div><div class=\"line\">    <span class=\"attribute\">margin-top</span>:-<span class=\"number\">100px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"16、BFC\"><a href=\"#16、BFC\" class=\"headerlink\" title=\"16、BFC\"></a>16、BFC</h3><p>块格式上下文是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。</p>\n<p>BFC的创建方法：<br>根元素或其它包含它的元素；<br>浮动 (元素的float不为none)；<br>绝对定位元素 (元素的position为absolute或fixed)；<br>行内块inline-blocks(元素的 display: inline-block)；<br>表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；<br>overflow的值不为visible的元素；<br>弹性盒 flex boxes (元素的display: flex或inline-flex)；</p>\n<h3 id=\"17、响应式图片的CSS\"><a href=\"#17、响应式图片的CSS\" class=\"headerlink\" title=\"17、响应式图片的CSS\"></a>17、响应式图片的CSS</h3><p>所谓响应式图片，就是根据图片所在容器的大小来实时地按比例缩放。实现的办法非常简单，只需要设置img标签的width:100%即可。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">img</span> &#123;</div><div class=\"line\"><span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果 max-width 属性设置为 100%, 图片永远不会大于其原始大小：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">img</span> &#123;</div><div class=\"line\"><span class=\"attribute\">max-width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"18、CSS响应式网格系统原理\"><a href=\"#18、CSS响应式网格系统原理\" class=\"headerlink\" title=\"18、CSS响应式网格系统原理\"></a>18、CSS响应式网格系统原理</h3><p>总的来说，网格系统就是利用百分比把视口等分为12个，然后利用float属性使之并列显示。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">* &#123;</div><div class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-attr\">[class*=\"col-\"]</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">float</span>: left;</div><div class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">15px</span>;</div><div class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-1</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">8.33%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-2</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-3</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">25%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-4</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">33.33%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-5</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">41.66%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-6</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-7</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">58.33%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-8</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">66.66%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-9</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">75%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-10</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">83.33%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-11</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">91.66%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-12</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"19、用LESS循环实现栅格类\"><a href=\"#19、用LESS循环实现栅格类\" class=\"headerlink\" title=\"19、用LESS循环实现栅格类\"></a>19、用LESS循环实现栅格类</h3><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.generate-columns</span>(<span class=\"number\">12</span>);</div><div class=\"line\"><span class=\"selector-class\">.generate-columns</span>(<span class=\"variable\">@n</span>; <span class=\"variable\">@i</span>: <span class=\"number\">1</span>) <span class=\"keyword\">when</span> (<span class=\"variable\">@i</span> =&lt; <span class=\"variable\">@n</span>) &#123;</div><div class=\"line\">  <span class=\"selector-class\">.column-</span><span class=\"variable\">@&#123;i&#125;</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>: (<span class=\"variable\">@i</span> * <span class=\"number\">100%</span> / <span class=\"variable\">@n</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"selector-class\">.generate-columns</span>(<span class=\"variable\">@n</span>, (<span class=\"variable\">@i</span> + <span class=\"number\">1</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"20、使用perspective属性和transform：perspective-函数的区别\"><a href=\"#20、使用perspective属性和transform：perspective-函数的区别\" class=\"headerlink\" title=\"20、使用perspective属性和transform：perspective()函数的区别\"></a>20、使用perspective属性和transform：perspective()函数的区别</h3><p>以上的两种书写格式都会生成一个3D立体效果，但是它们之间有一些区别。使用功能函数的方式可以很方便的在单个元素上应用3D transform，但是当在多个元素上使用时，转换的元素不会得到预期的效果。如果你为不同的元素使用相同的transform，每一个元素都会有自己的消失点。为了解决这个问题，可以在父元素上使用perspective属性，这样，所有的子元素都可以共享同一个3D空间。<br>perspective-origin: 25% 75%，等价于perspective-origin x和perspective-origin y的合体，用来设置镜头聚焦点的位置(舞台中心)<br>transform-style: preserve-3d,transform-style属性也是3D效果中经常使用的，其两个参数，flat|preserve-3d. 前者flat为默认值，表示平面的；后者preserve-3d表示3D透视。<br>backface-visibility：hidden|visibility设置背后元素是否可见</p>\n","excerpt":"<p>在前端开发领域，CSS是比较特殊的一种存在。理论上说，它是一种属性大杂烩，并不属于编程语言的范畴，当然SASS和LESS这两种预编译机制除外。所以CSS的学习是需要不断地去记忆和积累的。在前端笔试和面试过程中，CSS的考察是比较琐碎的，而且往往考察点比较偏，需要我们平时养成做笔记的习惯。这篇文章是我之前发布在慕课社区的一篇小笔记，原文<a href=\"http://www.imooc.com/article/2181\">前端笔试面试中的常用知识点总结(CSS)</a>，主要记录的是自己在校招过程当中关于CSS知识的总结。<br>","more":"</p>\n<h3 id=\"1、CSS选择器的优先级\"><a href=\"#1、CSS选择器的优先级\" class=\"headerlink\" title=\"1、CSS选择器的优先级\"></a>1、CSS选择器的优先级</h3><p>!important  &gt; 内联 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器<br>多个类选择器叠加（256）之后的优先级大于一个id选择器<br>!important 用于强调CSS属性具有最高的优先级。IE6不支持这种用法。<br>CSS选择器的种类：<br>1.id选择器(# myid)<br>2.类选择器(.myclassname)<br>3.标签选择器(div, h1, p)<br>4.相邻选择器(h1 + p)<br>5.子选择器(ul &gt; li)<br>6.后代选择器(li a)<br>7.通配符选择器( * )<br>8.属性选择器(a[rel = “external”])<br>9.伪类选择器(a: hover, li:nth-child)</p>\n<h3 id=\"2、CSS优先级权重计算法\"><a href=\"#2、CSS优先级权重计算法\" class=\"headerlink\" title=\"2、CSS优先级权重计算法\"></a>2、CSS优先级权重计算法</h3><p>CSS优先级的计算规则如下：<br>元素标签中定义的样式（Style属性）,加1,0,0,0<br>每个ID选择符(如 #id),加0,1,0,0<br>每个Class选择符、每个属性选择符、每个伪类（:hover）加0,0,1,0<br>每个元素选择符（如p）或伪元素选择符(如 :firstchild)等，加0,0,0,1<br>然后，将这四个数字分别累加，就得到每个CSS定义的优先级的值<br>然后从左到右逐位比较大小，数字大的CSS样式的优先级就高。</p>\n<h3 id=\"3、超链接访问过后hover样式就不出现的问题是什么？如何解决？\"><a href=\"#3、超链接访问过后hover样式就不出现的问题是什么？如何解决？\" class=\"headerlink\" title=\"3、超链接访问过后hover样式就不出现的问题是什么？如何解决？\"></a>3、超链接访问过后hover样式就不出现的问题是什么？如何解决？</h3><p>被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）</p>\n<h3 id=\"4、什么是Css-Hack？ie6-7-8的hack分别是什么？\"><a href=\"#4、什么是Css-Hack？ie6-7-8的hack分别是什么？\" class=\"headerlink\" title=\"4、什么是Css Hack？ie6,7,8的hack分别是什么？\"></a>4、什么是Css Hack？ie6,7,8的hack分别是什么？</h3><p>针对不同的浏览器写不同的CSS code的过程，就是CSS hack。常见的hack手法：<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#test</span>       &#123;   </div><div class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">300px</span>;   </div><div class=\"line\">        <span class=\"attribute\">height</span>:<span class=\"number\">300px</span>;   </div><div class=\"line\">        <span class=\"attribute\">background-color</span>:blue;      <span class=\"comment\">/*firefox*/</span></div><div class=\"line\">        <span class=\"attribute\">background-color</span>:red\\<span class=\"number\">9</span>;      <span class=\"comment\">/*all ie*/</span></div><div class=\"line\">        <span class=\"attribute\">background-color</span>:yellow\\<span class=\"number\">0</span>;    <span class=\"comment\">/*ie8*/</span></div><div class=\"line\">        +<span class=\"attribute\">background-color</span>:pink;        <span class=\"comment\">/*ie7*/</span></div><div class=\"line\">        _background-<span class=\"attribute\">color</span>:orange;       <span class=\"comment\">/*ie6*/</span>    &#125;  </div><div class=\"line\">        :root <span class=\"selector-id\">#test</span> &#123; <span class=\"attribute\">background-color</span>:purple\\<span class=\"number\">9</span>; &#125;  <span class=\"comment\">/*ie9*/</span></div><div class=\"line\">    @<span class=\"keyword\">media</span> all and (min-width:<span class=\"number\">0px</span>)&#123; </div><div class=\"line\">          <span class=\"selector-id\">#test</span> &#123;<span class=\"attribute\">background-color</span>:black\\<span class=\"number\">0</span>;&#125; </div><div class=\"line\">     &#125;  <span class=\"comment\">/*opera*/</span></div><div class=\"line\">    @<span class=\"keyword\">media</span> screen and (-webkit-min-device-pixel-ratio:<span class=\"number\">0</span>)&#123; </div><div class=\"line\"><span class=\"selector-id\">#test</span> &#123;<span class=\"attribute\">background-color</span>:gray;&#125; </div><div class=\"line\">&#125;       <span class=\"comment\">/*chrome and safari*/</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"5、描述一个”reset”的CSS文件并如何使用它。知道normalize-css吗？你了解他们的不同之处？\"><a href=\"#5、描述一个”reset”的CSS文件并如何使用它。知道normalize-css吗？你了解他们的不同之处？\" class=\"headerlink\" title=\"5、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？\"></a>5、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？</h3><p>不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。<br>　　你可能会用Normalize来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。</p>\n<h3 id=\"6、display-none与visibility-hidden的区别是什么？\"><a href=\"#6、display-none与visibility-hidden的区别是什么？\" class=\"headerlink\" title=\"6、display:none与visibility:hidden的区别是什么？\"></a>6、display:none与visibility:hidden的区别是什么？</h3><p>display : 隐藏对应的元素但不挤占该元素原来的空间。<br>visibility: 隐藏对应的元素并且挤占该元素原来的空间。<br> 　　即是，使用CSS display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。</p>\n<h3 id=\"7、CSS盒子模型\"><a href=\"#7、CSS盒子模型\" class=\"headerlink\" title=\"7、CSS盒子模型\"></a>7、CSS盒子模型</h3><p>Box Model规定了元素框处理元素内容（element content）、内边距（padding）、边框（border） 和 外边距（margin） 的方式。盒子模型有 block,inline-block,inline,flex,table-cell等几种显示方式。<br><img src=\"http://img.mukewang.com/5649f2ab0001b95904640464.png\" alt=\"CSS盒模型\"><br>如图所示，元素的高度和宽度指的是盒子模型的content区域的高度和宽度，不包括内边距以外的部分。(IE的content则是包含border、内边距和content)。盒子模型有两种，W3C标准盒子模型（content-box）以及IE盒子模型（border-box）。</p>\n<h3 id=\"8、相对定位relative、浮动float以及绝对定位absolute的区别？\"><a href=\"#8、相对定位relative、浮动float以及绝对定位absolute的区别？\" class=\"headerlink\" title=\"8、相对定位relative、浮动float以及绝对定位absolute的区别？\"></a>8、相对定位relative、浮动float以及绝对定位absolute的区别？</h3><p>1）相对定位是在常规流中的定位。一旦一个框按照常规流或者是浮动得到定位，它还可以相对该位置而偏移， 这就是相对定位。偏移后，在常规流中依然占据原有位置，偏移量并不会对后续的block产生挤占，后续的块就好像没有感知到偏移，依然按照常规流位置排位。<br>2）绝对定位（Absolute positioning）元素定位的参照物是其包含块（第一个relative定位的祖先元素）进行定位，不一定是其父元素。绝对定位元素完全脱离了常规流，每个绝对定位的框都可以看做一个单独的图层，不会对其他层框的定位产生影响。绝对元素定位的 top 和 left 值跟绝对元素未脱离常规流之前在常规流中位置有关。<br>3）浮动框就是一个框在当前行被向左或向右挪动(偏移)，它不在常规流中。在该浮动框之前或之后创建的非定位框垂直排列，就好象浮动框并不存在一样。当前行里浮动框前的任何内容，都将被重新排列到该浮动另一侧的第一个可用行里。</p>\n<h3 id=\"9、清除浮动的用法？\"><a href=\"#9、清除浮动的用法？\" class=\"headerlink\" title=\"9、清除浮动的用法？\"></a>9、清除浮动的用法？</h3><p>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。<br>使用方法：<br>1、在浮动元素后使用一个空元素如<div class=\"clear\"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。<br>2、给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动<br>3、什么都不做，给浮动元素后面的元素添加clear属性。<br>4、利用伪类清除浮动，给浮动元素的容器添加一个clearfix的class，然 后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//一种常见利用伪类清除浮动的代码</span></div><div class=\"line\"> <span class=\"selector-class\">.clearfix</span>:after &#123;</div><div class=\"line\">    <span class=\"attribute\">content</span>:<span class=\"string\">\".\"</span>;       <span class=\"comment\">//这里利用到了content属性</span></div><div class=\"line\">    <span class=\"attribute\">display</span>:block; </div><div class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">visibility</span>:hidden; </div><div class=\"line\">    <span class=\"attribute\">clear</span>:both; </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.clearfix</span> &#123; </div><div class=\"line\">    *zoom:<span class=\"number\">1</span>; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"10、BOX模型的margin在IE比在其他浏览器大2px的解决办法\"><a href=\"#10、BOX模型的margin在IE比在其他浏览器大2px的解决办法\" class=\"headerlink\" title=\"10、BOX模型的margin在IE比在其他浏览器大2px的解决办法\"></a>10、BOX模型的margin在IE比在其他浏览器大2px的解决办法</h3><p>div{margin:30px!important;margin:28px;}<br>注意这两个margin的顺序一定不能写反，据阿捷的说法!important这个 属性IE不能识别，但别的浏览器可以识别。所以在IE下其实解释成这样：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">div</span>&#123;<span class=\"attribute\">maring</span>:<span class=\"number\">30px</span>;<span class=\"attribute\">margin</span>:<span class=\"number\">28px</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>重复定义的话按照最后一个来执行，所以不可以只写<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">margin</span>:XXpx<span class=\"meta\">!important</span>;</div></pre></td></tr></table></figure></p>\n<p>也可以这样子hack<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">div</span> &#123; <span class=\"attribute\">_margin</span>:<span class=\"number\">28px</span>;<span class=\"attribute\">margin</span>:<span class=\"number\">28px</span>\\<span class=\"number\">9</span>;<span class=\"attribute\">margin</span>:<span class=\"number\">30px</span>;&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"11、IE-3像素Bug的产生原因及解决办法\"><a href=\"#11、IE-3像素Bug的产生原因及解决办法\" class=\"headerlink\" title=\"11、IE 3像素Bug的产生原因及解决办法\"></a>11、IE 3像素Bug的产生原因及解决办法</h3><p>当在同一行相邻出现一个浮动的块元素和一个非浮动的块元素时，两块元素之间就会出现3px的裂痕。<br>解决办法就是：对其中一个元素添加“_margin-*:-3px”的CSS属性，或者将另外一个非浮动的元素设为浮动。</p>\n<h3 id=\"12、IE6-双边距Bug的产生原因及解决办法\"><a href=\"#12、IE6-双边距Bug的产生原因及解决办法\" class=\"headerlink\" title=\"12、IE6 双边距Bug的产生原因及解决办法\"></a>12、IE6 双边距Bug的产生原因及解决办法</h3><p>当我们在浮动元素上面添加margin-*的属性的时候，比如在float:left的元素CSS添加margin-left:50px，那么最终在IE6下面的显示就是该元素的margin-left最终变为100px，边距翻倍。<br>解决办法：添加_display:inline</p>\n<h3 id=\"13、FOUC-Flash-Of-Unstyled-Content-文档样式闪烁\"><a href=\"#13、FOUC-Flash-Of-Unstyled-Content-文档样式闪烁\" class=\"headerlink\" title=\"13、FOUC - Flash Of Unstyled Content 文档样式闪烁\"></a>13、FOUC - Flash Of Unstyled Content 文档样式闪烁</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"all\"</span>&gt;</span><span class=\"css\">@<span class=\"keyword\">import</span> <span class=\"string\">\"../fouc.css\"</span>;</span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。<br>解决方法简单的出奇，只要在 head 之间加入一个 link 或者 script 元素就可以了。</p>\n<h3 id=\"14、文本溢出省略的处理方法\"><a href=\"#14、文本溢出省略的处理方法\" class=\"headerlink\" title=\"14、文本溢出省略的处理方法\"></a>14、文本溢出省略的处理方法</h3><p>1)单行文本溢出<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.inline</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">overflow</span>:hidden;</div><div class=\"line\">         <span class=\"attribute\">white-space</span>:nowrap;</div><div class=\"line\">         <span class=\"attribute\">text-overflow</span>:ellipsis; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>2)多行文本溢出<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.foo</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>:-webkit-box<span class=\"meta\">!important</span>;</div><div class=\"line\">  <span class=\"attribute\">overflow</span>:hidden;</div><div class=\"line\">  <span class=\"attribute\">text-overflow</span>:ellipsis;</div><div class=\"line\">  <span class=\"attribute\">work-break</span>:break-all;</div><div class=\"line\">  <span class=\"attribute\">-webkit-box-orient</span>:vertical; <span class=\"comment\">/*方向*/</span></div><div class=\"line\">  <span class=\"attribute\">-webkit-line-clamp</span>:<span class=\"number\">4</span>; <span class=\"comment\">/*显示多少行文本*/</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>但是这里只适用于webkit内核浏览器，不兼容IE和其他非webkit浏览器。</p>\n<h3 id=\"15、CSS实现垂直水平居中\"><a href=\"#15、CSS实现垂直水平居中\" class=\"headerlink\" title=\"15、CSS实现垂直水平居中\"></a>15、CSS实现垂直水平居中</h3><p>方法1：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">          <span class=\"attribute\">width</span>:<span class=\"number\">800px</span>;</div><div class=\"line\">          <span class=\"attribute\">height</span>:<span class=\"number\">500px</span>;</div><div class=\"line\">          <span class=\"attribute\">border</span>:<span class=\"number\">2px</span> solid <span class=\"number\">#000</span>;</div><div class=\"line\">          <span class=\"attribute\">position</span>:relative;</div><div class=\"line\">&#125;</div><div class=\"line\"> <span class=\"selector-class\">.child</span> &#123;</div><div class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</div><div class=\"line\">        <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</div><div class=\"line\">        <span class=\"attribute\">margin</span>: auto;  </div><div class=\"line\">        <span class=\"attribute\">position</span>: absolute;  </div><div class=\"line\">        <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>; <span class=\"attribute\">right</span>: <span class=\"number\">0</span>; </div><div class=\"line\">        <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>方法2：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">800px</span>;</div><div class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">500px</span>;</div><div class=\"line\">    <span class=\"attribute\">border</span>:<span class=\"number\">2px</span> solid <span class=\"number\">#000</span>;</div><div class=\"line\">    <span class=\"attribute\">display</span>:table-cell;</div><div class=\"line\">    <span class=\"attribute\">vertical-align</span>:middle;</div><div class=\"line\">    <span class=\"attribute\">text-align</span>: center;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.child</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">display</span>:inline-block;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>方法3：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">800px</span>;</div><div class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">500px</span>;</div><div class=\"line\">    <span class=\"attribute\">border</span>:<span class=\"number\">2px</span> solid <span class=\"number\">#000</span>;</div><div class=\"line\">    <span class=\"attribute\">display</span>:flex;</div><div class=\"line\">    <span class=\"attribute\">justify-content</span>:center;</div><div class=\"line\">    <span class=\"attribute\">align-items</span>:center;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.child</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>方法4：<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">800px</span>;</div><div class=\"line\">        <span class=\"attribute\">height</span>:<span class=\"number\">500px</span>;</div><div class=\"line\">        <span class=\"attribute\">border</span>:<span class=\"number\">2px</span> solid <span class=\"number\">#000</span>;</div><div class=\"line\">        <span class=\"attribute\">position</span>:relative;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"selector-class\">.child</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">300px</span>;</div><div class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">margin</span>:auto;</div><div class=\"line\">    <span class=\"attribute\">position</span>:absolute;</div><div class=\"line\"><span class=\"comment\">//设定水平和垂直偏移父元素的50%，</span></div><div class=\"line\"><span class=\"comment\">//再根据实际长度将子元素上左挪回一半大小</span></div><div class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">50%</span>;</div><div class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">50%</span>;</div><div class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">150px</span>;</div><div class=\"line\">    <span class=\"attribute\">margin-top</span>:-<span class=\"number\">100px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"16、BFC\"><a href=\"#16、BFC\" class=\"headerlink\" title=\"16、BFC\"></a>16、BFC</h3><p>块格式上下文是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。</p>\n<p>BFC的创建方法：<br>根元素或其它包含它的元素；<br>浮动 (元素的float不为none)；<br>绝对定位元素 (元素的position为absolute或fixed)；<br>行内块inline-blocks(元素的 display: inline-block)；<br>表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；<br>overflow的值不为visible的元素；<br>弹性盒 flex boxes (元素的display: flex或inline-flex)；</p>\n<h3 id=\"17、响应式图片的CSS\"><a href=\"#17、响应式图片的CSS\" class=\"headerlink\" title=\"17、响应式图片的CSS\"></a>17、响应式图片的CSS</h3><p>所谓响应式图片，就是根据图片所在容器的大小来实时地按比例缩放。实现的办法非常简单，只需要设置img标签的width:100%即可。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">img</span> &#123;</div><div class=\"line\"><span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果 max-width 属性设置为 100%, 图片永远不会大于其原始大小：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">img</span> &#123;</div><div class=\"line\"><span class=\"attribute\">max-width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"18、CSS响应式网格系统原理\"><a href=\"#18、CSS响应式网格系统原理\" class=\"headerlink\" title=\"18、CSS响应式网格系统原理\"></a>18、CSS响应式网格系统原理</h3><p>总的来说，网格系统就是利用百分比把视口等分为12个，然后利用float属性使之并列显示。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">* &#123;</div><div class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-attr\">[class*=\"col-\"]</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">float</span>: left;</div><div class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">15px</span>;</div><div class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-1</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">8.33%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-2</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-3</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">25%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-4</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">33.33%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-5</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">41.66%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-6</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-7</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">58.33%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-8</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">66.66%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-9</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">75%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-10</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">83.33%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-11</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">91.66%</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.col-12</span> &#123;<span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"19、用LESS循环实现栅格类\"><a href=\"#19、用LESS循环实现栅格类\" class=\"headerlink\" title=\"19、用LESS循环实现栅格类\"></a>19、用LESS循环实现栅格类</h3><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.generate-columns</span>(<span class=\"number\">12</span>);</div><div class=\"line\"><span class=\"selector-class\">.generate-columns</span>(<span class=\"variable\">@n</span>; <span class=\"variable\">@i</span>: <span class=\"number\">1</span>) <span class=\"keyword\">when</span> (<span class=\"variable\">@i</span> =&lt; <span class=\"variable\">@n</span>) &#123;</div><div class=\"line\">  <span class=\"selector-class\">.column-</span><span class=\"variable\">@&#123;i&#125;</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>: (<span class=\"variable\">@i</span> * <span class=\"number\">100%</span> / <span class=\"variable\">@n</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"selector-class\">.generate-columns</span>(<span class=\"variable\">@n</span>, (<span class=\"variable\">@i</span> + <span class=\"number\">1</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"20、使用perspective属性和transform：perspective-函数的区别\"><a href=\"#20、使用perspective属性和transform：perspective-函数的区别\" class=\"headerlink\" title=\"20、使用perspective属性和transform：perspective()函数的区别\"></a>20、使用perspective属性和transform：perspective()函数的区别</h3><p>以上的两种书写格式都会生成一个3D立体效果，但是它们之间有一些区别。使用功能函数的方式可以很方便的在单个元素上应用3D transform，但是当在多个元素上使用时，转换的元素不会得到预期的效果。如果你为不同的元素使用相同的transform，每一个元素都会有自己的消失点。为了解决这个问题，可以在父元素上使用perspective属性，这样，所有的子元素都可以共享同一个3D空间。<br>perspective-origin: 25% 75%，等价于perspective-origin x和perspective-origin y的合体，用来设置镜头聚焦点的位置(舞台中心)<br>transform-style: preserve-3d,transform-style属性也是3D效果中经常使用的，其两个参数，flat|preserve-3d. 前者flat为默认值，表示平面的；后者preserve-3d表示3D透视。<br>backface-visibility：hidden|visibility设置背后元素是否可见</p>"},{"title":"单元测试工具Mocha和SuperTest组合","date":"2015-12-08T12:07:57.000Z","_content":"\n毕业季，一堆乱七八糟的事情搞得已经整整两个月没有时间写写笔记了。最近进行着一个Node小项目，其中关于单元测试部分花了不少时间去踩坑。所以在这里简单总结一下关于Node开发测试框架Mocha(摩卡)的一些基础用法。由于本人是入门级别的Node开发者，所以这篇文章也是仅适用于和我一样的初级Node开发者，如有不正确的地方欢迎大神们指正！\n<!--more-->\n## 一、Mocha\nMocha是非常流行JavaScript测试框架之一，在浏览器和Node环境都可以使用。这里主要是针对Node环境。\n### 1、安装\n关于Mocha的安装当然是万能的npm了，直接npm install就OK，这里不再罗嗦了。\n### 2、使用\n然后就是Mocha的语法了。首先来看一下最简单例子：\n```\n// 这是一个简单的加法函数\n//add.js\nfunction add(a, b){\n    return a+b;\n}\nmodule.exports = add;\n```\n现在用Mocha写一个测试脚本去测试这个函数。一般来说，测试脚本的命名要和测试的模块一致，后缀为.test.js。这里测试脚本的名称为add.test.js，表示对add模块进行测试。\n```\n//add.test.js\nvar add = require('./add');\nvar should = require('should');\n\ndescribe('test add', function() {\n    it('1 + 1 should be equal to 2', function(done){\n        (add(1,1) === 2).should.be.true;\n    });\n});\n```\n然后保存代码之后进入终端，执行mocha add.test 即可。其中describe()函数是测试描述，表示一组相关测试用例是对哪个模块的测试。it()是一个测试用例，在一个describe块的内部可以执行对个测试用例(it块)。\n\n这是同步函数的测试。在Node环境中，绝大部分的业务逻辑都是异步的，所以测试结果的回调是JavaScript测试框架需要解决的首要问题。Mocha提供了一个回调函数done，在业务代码执行完毕之后调用done()结束测试用例，不然的话测试用例就会出现timeout的情况导致测试用例失败。Mocha默认的超时时间是2000毫秒，如果由于测试用例的执行时间比较长需要延长超时时间，可以在命令行添加 -t 参数，比如mocha -t 3000 add.test.js。当然还有其他命令行参数，比如 mocha -w 用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。查看更多的命令行参数可以通过 mocha -h 查找。\n\n那么接下来看一个异步测试例子：\n```\ndescribe('test async function', function(){\n    it('supertest example', function(done){\n        request.post('/')\n        .expect(200)\n        .end(function(err, res) {\n            should.not.exist(err);\n            done();\n        })\n    })\n})\n```\n在request请求执行完毕end()之后，一定要调用done()，否则测试用例超时，那么这个用例就失败了。当然这里用到了断言库should，稍后再介绍它的语法。\n\n### 3、钩子(hooks)\nMocha的Hooks主要是用来设置前置条件和后置处理。比如说一个业务请求之前必须先登录，那个登录操作就在before()里面完成。Mocha提供了before,after,beforeEach,afterEach四个钩子。\n```\ndescribe('hooks', function() {\n  before(function() {\n    // runs before all tests in this block\n  });\n\n  after(function() {\n    // runs after all tests in this block\n  });\n\n  beforeEach(function() {\n    // runs before each test in this block\n  });\n\n  afterEach(function() {\n    // runs after each test in this block\n  });\n\n  it('test',function(done){\n    //test here\n  })\n});\n```\n如果说某个测试需要跳过，使用it.skip()，Mocha跳过这个用例而不影响其他it块；只测试某个测试用例，使用it.only()，Mocha只执行.only用例，无视其他it块。\n\n## 二、断言库should\nMocha本身是不包含断言库的，所以我们需要自己选择断言库。should是一个很简单的、贴近自然语言的断言库。当然，Mocha是适配所有的断言库的，如果你喜欢其他的断言库比如expect之类的，你也可以把它包含进来使用。\n\nshould的语法非常贴近自然语言，简单易懂，常见的should断言如下：\n```\n// 全等，相当于===\n.exactly\n(5).should.be.exactly(5)\n \n// 对象存在\n.ok\ntrue.should.be.ok;\n'yay'.should.be.ok;\n(1).should.be.ok;\n({}).should.be.ok;\nfalse.should.not.be.ok;\n\n// 真\n.true\n(5===5).should.be.true\n(err === null).should.be.true;\n\n// 相等,相当于 ==\n.eql\n({ foo: 'bar' }).should.eql({ foo: 'bar' });\n[1,2,3].should.eql([1,2,3]);\n// see next example it is correct, even if it is different types, but actual content the same\n[1, 2, 3].should.eql({ '0': 1, '1': 2, '2': 3 });\n\n// 非数字\n.NaN\n(undefined + 0).should.be.NaN;\n\n// 判断类型\n.typeof\nuser.should.be.type('object');\n'test'.should.be.type('string');\n\n// 构造函数的一个实例\n.instanceof\nuser.should.be.an.instanceof(User);\n[].should.be.an.instanceOf(Array);\n\n// 存在\n.exist()\nshould.not.exist(err)\n\n//深度包含\n.containDeep()\n[[1],[2],[3]].should.containDeep([[3]]);\n[[1],[2],[3, 4]].should.containDeep([[3]]);\n[{a: 'a'}, {b: 'b', c: 'c'}].should.containDeep([{a: 'a'}]);\n[{a: 'a'}, {b: 'b', c: 'c'}].should.containDeep([{b: 'b'}]);\n\n// 抛出异常\n.throw()和throwError()\n(function(){\n  throw new Error('fail');\n}).should.throw();\n(function(){\n  throw new Error('fail');\n}).should.throw('fail');\n\n// http响应的头部包含\n.header\nres.should.have.header('content-length');\nres.should.have.header('Content-Length', '123');\n\n// 包含或等价于\n.containEql\n({ b: 10 }).should.containEql({ b: 10 });\n([1, 2, { a: 10 }]).should.containEql({ a: 10 });\n```\n\n## 三、SuperTest\n单单使用Mocha和should就几乎可以满足所有JavaScript函数的单元测试。但是对于Node应用而言，不仅仅是函数的集合，比如一个web应用的测试。这时候就需要配合一个http代理，完成Http请求和路由的测试。\nSupertest是一个HTTP代理服务引擎，可以模拟一切HTTP请求行为。Supertest可以搭配任意的应用框架，从而进行应用的单元测试。\n\n### 1、用法\n#### API\n首先，传入应用来实例化supertest,比如说实例化一个express：\n```\nvar supertest = require('supertest'), \n    express = require('express');\nvar app = express();\nvar request = supertest(app);\n```\n接下来就可以在Mocha测试用例中直接使用request发出一个基于该web应用的http请求了。\n\n1、.set()\n如果需要设置数据，supertest的API提供了 .set 来设置，比如：\n```\ndescribe('GET /users', function(){\n  it('respond with json', function(done){\n    request(app)\n      .get('/user')\n      .set('Accept', 'application/json')\n      .expect(200)\n      .end(function(err, res){\n        should.not.exist(err);\n        res.text.should.containEql('success');\n        done();\n      });\n  });\n});\n```\n\n2、.expect()\n.expect 是一个断言，上述测试代码在执行之后期望的状态码是200(OK)。如果接收到的数据为html页面，.expect('Content-Type', 'text/html;charset=utf-8')\n\n3、.end()\n.end 是执行一个request请求，在回调函数里面根据业务逻辑的返回数据做断言分析。\n\n4、.send()\n很多情况下，项目需要测试一个表单业务。supertest提供了.send()方法来发送表单域数据。比如一个登录模块，需要发送用户名密码：\n```\ndescribe('test login', function(){\n    it('login sucessfully', function (done) {\n        request.post('/user')\n        .send({\n            username: 'username',\n            password: '123456'\n        })\n        .end(function (err, res) {\n            should.not.exists(err);\n            done();\n        });\n    });\n})\n```\n\n5、.attach()\n.attach方法主要用来测试文件上传，由于.send()只能上传文本域，所以关于multipart -file的上传需要通过附件来绑定。\n```\nrequest(app)\n.post('/')\n.field('name', 'my awesome avatar')\n.attach('avatar', 'test/fixtures/homeboy.jpg')\n...\n```\n\n#### 持久化Cookie\n在很多业务测试中，需要用户先登录才有权限执行操作。这个时候作为HTTP请求模拟，必须要可以保存一些Cookie数据，也就是Cookie的持久化。这一般有两种解决思路。\n1、在 supertest 中，可以通过 var request = supertest.agent(app) 获取一个 agent 对象，这个对象的 API 跟直接在 superagent 上调用各种方法是一样的。这个request在被多次调用 get 和 post 之后，可以一路把 cookie 都保存下来。\n```\nvar supertest = require('supertest');\n  var app = express();\n  var request = supertest.agent(app);\n\n  request.post('login').end(...);\n  // then ..\n  request.post('create_topic').end(...); // 此时的request中有用户登陆后的 cookie\n```\n2、通过.set()，在发起请求时，调用 .set('Cookie', 'a cookie string') 这样的方式。\n```\nvar request = require('supertest');\nvar userCookie;\nrequest.post('login')\n.end(function (err, res) {\n    userCookie = res.headers['Cookie']\n});\n// then ..\n\nrequest.post('create_topic')\n    .set('Cookie', userCookie)\n    .end(...)\n```\n\n### 2、实战demo\n为了更好地帮助理解SuperTest的强大功能，这里放上我的一个项目模块的测试demo。\n#### 项目源文件\n首先，这是一个express应用的登录注册和用户信息修改模块，要测试的就是这个user模块。为了节省篇幅，这里只放上UserController和Router两个项目文件。\n```\nUserController.js\n// 用户首页\nexports.getUser = function (req, res) {\n    if (!req.user) {\n        res.send({status: false, info: '未登录'});\n    } else {\n        res.render('user', {status: true, userdata: req.user});\n    }\n};\n\nexports.login =  function (req, res, next) {\n    req.session.save(function (err) {\n        if (err) {\n            log.error(err);\n            return next(err);\n        }\n        res.redirect('/user/' + req.user.username);\n    });\n};\n\nexports.logout = function (req, res, next) {\n    req.logout();\n    req.session.save(function (err) {\n        if (err) {\n            log.error(err);\n            return next (err);\n        }\n        res.redirect('/user');\n        res.end();\n    });\n};\n\n// 用户注册\nexports.addUser = function (req, res, next) {\n    if (!req.body.username || !req.body.password) {\n        return res.send({status: false, info: '用户名或密码不能为空'});\n    } else if (req.body.password.length < 6) {\n        return res.send({status: false, info: '密码长度太短'});\n    } \n\n    User.register(new User({username: req.body.username}), req.body.password, function (err, user) {\n        if (err) {\n            log.error(err);\n            return res.render('register', {info: '用户名已被使用'});\n        } \n        passport.authenticate('local')(req, res, function () {\n            req.session.save(function (err) {\n                if (err) {\n                    log.error(err);\n                    return next(err);\n                }\n                res.redirect('/user/' + req.body.username);\n            });\n        });\n\n    });\n};\n\n// 更新用户信息文字资料\nexports.updateInfo = function (req, res, next) {\n    User.findOne({username: req.user.username}, function (err, doc) {\n        if (doc) {\n            doc.update(req.body, function (err, data) {\n                if (err) {\n                    log.error(err);\n                    return next(err);\n                }\n                res.send({status: true});\n            });\n        } else {\n            next();\n        }\n    });\n};\n\n// 更换头像\nexports.updateAvator = function (req, res,next) {\n    upload(req, res, function (err) {\n        if (err) {\n            log.error(err);\n            return next(err);\n        }\n        User.findOne({username: req.user.username}, function (err, doc) {\n            if (err) {\n                log.error(err);\n                return next(err);\n            } else if (doc) {\n                doc.update({avator: req.file.filename}, function (err, data) {\n                    if (err) {\n                        log.error(err);\n                        return next(err);\n                    }\n                    res.type('html');\n                    res.send({status: true, avator: req.file.filename});\n                });\n            } else {\n                return next();\n            }\n        });\n    });\n};\n```\nRouter文件\n```\nrouter.get('/:uid', isAuthenticated, user.getUser);\nrouter.get('/', function (req, res) {\n    res.render('login', {info: ''});\n});\nrouter.post('/',passport.authenticate('local'), /*{failureRedirect: '/user'}),*/ user.login);\n\nrouter.post('/authenticate/logout', user.logout);\n\nrouter.get('/authenticate/register', function (req, res) {\n    res.render('register', {info: ''});\n});\n\nrouter.post('/authenticate/register', user.addUser);\n\n// 用户相关的资料\nrouter.post('/update/info', user.updateInfo);\nrouter.post('/update/avator', user.updateAvator);\n\nmodule.exports = router;\n```\n\n#### 测试脚本\n首先，测试注册功能。为了防止用户名冲突，在测试用例之前设置钩子before块，清除User集合。\n```\n // user.test.js\n describe('test user.addUser()', function () {\n        before(function (done) {\n            User.remove({}, function (err) {\n                done();\n            });\n        });\n\n        it('register sucessfully', function (done) {\n            request.post('/user/authenticate/register')\n            .send({\n                username: 'username',\n                password: '123456'\n            })\n            //注册成功之后重定向\n            .expect(302, function (err, res) {\n                should.not.exists(err);\n                done();\n            });\n        });\n        //测试用户名存在的用例\n        it('username already exist', function (done) {\n            request.post('/user/authenticate/register')\n            .send({\n                username: 'username',\n                password: '123456'\n            })\n            .end(function (err, res) {\n                should.not.exists(err);\n                res.text.should.containEql('用户名已被使用');\n                done();\n            });\n        });\n    });\n    // 测试头像上传\n    describe('test user.updateAvator()', function () {\n        //bofore HOOKS，测试业务逻辑之前先登录，并持久化cookie\n        before(function (done) {\n            request.post('/user')\n            .send({\n                username: 'username',\n                password: '123456'\n            })\n            .end(function (err, res) {\n                done();\n            });\n        });\n\n        it('update avator upload sucessfully', function (done) {\n            request.post('/user/update/avator')\n            .attach('avator','test/image/test.jpg')\n            .end(function (err, res) {\n                should.not.exists(err);\n                res.text.should.containEql('\"status\":true');\n                done();\n            });\n        }); \n    });\n```\n\n","source":"_posts/单元测试工具Mocha和SuperTest组合.md","raw":"title: 单元测试工具Mocha和SuperTest组合\ndate: 2015-12-08 20:07:57\ntags:\n    - mocha\n    - node\ncategories:\n    - Nodejs\n---\n\n毕业季，一堆乱七八糟的事情搞得已经整整两个月没有时间写写笔记了。最近进行着一个Node小项目，其中关于单元测试部分花了不少时间去踩坑。所以在这里简单总结一下关于Node开发测试框架Mocha(摩卡)的一些基础用法。由于本人是入门级别的Node开发者，所以这篇文章也是仅适用于和我一样的初级Node开发者，如有不正确的地方欢迎大神们指正！\n<!--more-->\n## 一、Mocha\nMocha是非常流行JavaScript测试框架之一，在浏览器和Node环境都可以使用。这里主要是针对Node环境。\n### 1、安装\n关于Mocha的安装当然是万能的npm了，直接npm install就OK，这里不再罗嗦了。\n### 2、使用\n然后就是Mocha的语法了。首先来看一下最简单例子：\n```\n// 这是一个简单的加法函数\n//add.js\nfunction add(a, b){\n    return a+b;\n}\nmodule.exports = add;\n```\n现在用Mocha写一个测试脚本去测试这个函数。一般来说，测试脚本的命名要和测试的模块一致，后缀为.test.js。这里测试脚本的名称为add.test.js，表示对add模块进行测试。\n```\n//add.test.js\nvar add = require('./add');\nvar should = require('should');\n\ndescribe('test add', function() {\n    it('1 + 1 should be equal to 2', function(done){\n        (add(1,1) === 2).should.be.true;\n    });\n});\n```\n然后保存代码之后进入终端，执行mocha add.test 即可。其中describe()函数是测试描述，表示一组相关测试用例是对哪个模块的测试。it()是一个测试用例，在一个describe块的内部可以执行对个测试用例(it块)。\n\n这是同步函数的测试。在Node环境中，绝大部分的业务逻辑都是异步的，所以测试结果的回调是JavaScript测试框架需要解决的首要问题。Mocha提供了一个回调函数done，在业务代码执行完毕之后调用done()结束测试用例，不然的话测试用例就会出现timeout的情况导致测试用例失败。Mocha默认的超时时间是2000毫秒，如果由于测试用例的执行时间比较长需要延长超时时间，可以在命令行添加 -t 参数，比如mocha -t 3000 add.test.js。当然还有其他命令行参数，比如 mocha -w 用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。查看更多的命令行参数可以通过 mocha -h 查找。\n\n那么接下来看一个异步测试例子：\n```\ndescribe('test async function', function(){\n    it('supertest example', function(done){\n        request.post('/')\n        .expect(200)\n        .end(function(err, res) {\n            should.not.exist(err);\n            done();\n        })\n    })\n})\n```\n在request请求执行完毕end()之后，一定要调用done()，否则测试用例超时，那么这个用例就失败了。当然这里用到了断言库should，稍后再介绍它的语法。\n\n### 3、钩子(hooks)\nMocha的Hooks主要是用来设置前置条件和后置处理。比如说一个业务请求之前必须先登录，那个登录操作就在before()里面完成。Mocha提供了before,after,beforeEach,afterEach四个钩子。\n```\ndescribe('hooks', function() {\n  before(function() {\n    // runs before all tests in this block\n  });\n\n  after(function() {\n    // runs after all tests in this block\n  });\n\n  beforeEach(function() {\n    // runs before each test in this block\n  });\n\n  afterEach(function() {\n    // runs after each test in this block\n  });\n\n  it('test',function(done){\n    //test here\n  })\n});\n```\n如果说某个测试需要跳过，使用it.skip()，Mocha跳过这个用例而不影响其他it块；只测试某个测试用例，使用it.only()，Mocha只执行.only用例，无视其他it块。\n\n## 二、断言库should\nMocha本身是不包含断言库的，所以我们需要自己选择断言库。should是一个很简单的、贴近自然语言的断言库。当然，Mocha是适配所有的断言库的，如果你喜欢其他的断言库比如expect之类的，你也可以把它包含进来使用。\n\nshould的语法非常贴近自然语言，简单易懂，常见的should断言如下：\n```\n// 全等，相当于===\n.exactly\n(5).should.be.exactly(5)\n \n// 对象存在\n.ok\ntrue.should.be.ok;\n'yay'.should.be.ok;\n(1).should.be.ok;\n({}).should.be.ok;\nfalse.should.not.be.ok;\n\n// 真\n.true\n(5===5).should.be.true\n(err === null).should.be.true;\n\n// 相等,相当于 ==\n.eql\n({ foo: 'bar' }).should.eql({ foo: 'bar' });\n[1,2,3].should.eql([1,2,3]);\n// see next example it is correct, even if it is different types, but actual content the same\n[1, 2, 3].should.eql({ '0': 1, '1': 2, '2': 3 });\n\n// 非数字\n.NaN\n(undefined + 0).should.be.NaN;\n\n// 判断类型\n.typeof\nuser.should.be.type('object');\n'test'.should.be.type('string');\n\n// 构造函数的一个实例\n.instanceof\nuser.should.be.an.instanceof(User);\n[].should.be.an.instanceOf(Array);\n\n// 存在\n.exist()\nshould.not.exist(err)\n\n//深度包含\n.containDeep()\n[[1],[2],[3]].should.containDeep([[3]]);\n[[1],[2],[3, 4]].should.containDeep([[3]]);\n[{a: 'a'}, {b: 'b', c: 'c'}].should.containDeep([{a: 'a'}]);\n[{a: 'a'}, {b: 'b', c: 'c'}].should.containDeep([{b: 'b'}]);\n\n// 抛出异常\n.throw()和throwError()\n(function(){\n  throw new Error('fail');\n}).should.throw();\n(function(){\n  throw new Error('fail');\n}).should.throw('fail');\n\n// http响应的头部包含\n.header\nres.should.have.header('content-length');\nres.should.have.header('Content-Length', '123');\n\n// 包含或等价于\n.containEql\n({ b: 10 }).should.containEql({ b: 10 });\n([1, 2, { a: 10 }]).should.containEql({ a: 10 });\n```\n\n## 三、SuperTest\n单单使用Mocha和should就几乎可以满足所有JavaScript函数的单元测试。但是对于Node应用而言，不仅仅是函数的集合，比如一个web应用的测试。这时候就需要配合一个http代理，完成Http请求和路由的测试。\nSupertest是一个HTTP代理服务引擎，可以模拟一切HTTP请求行为。Supertest可以搭配任意的应用框架，从而进行应用的单元测试。\n\n### 1、用法\n#### API\n首先，传入应用来实例化supertest,比如说实例化一个express：\n```\nvar supertest = require('supertest'), \n    express = require('express');\nvar app = express();\nvar request = supertest(app);\n```\n接下来就可以在Mocha测试用例中直接使用request发出一个基于该web应用的http请求了。\n\n1、.set()\n如果需要设置数据，supertest的API提供了 .set 来设置，比如：\n```\ndescribe('GET /users', function(){\n  it('respond with json', function(done){\n    request(app)\n      .get('/user')\n      .set('Accept', 'application/json')\n      .expect(200)\n      .end(function(err, res){\n        should.not.exist(err);\n        res.text.should.containEql('success');\n        done();\n      });\n  });\n});\n```\n\n2、.expect()\n.expect 是一个断言，上述测试代码在执行之后期望的状态码是200(OK)。如果接收到的数据为html页面，.expect('Content-Type', 'text/html;charset=utf-8')\n\n3、.end()\n.end 是执行一个request请求，在回调函数里面根据业务逻辑的返回数据做断言分析。\n\n4、.send()\n很多情况下，项目需要测试一个表单业务。supertest提供了.send()方法来发送表单域数据。比如一个登录模块，需要发送用户名密码：\n```\ndescribe('test login', function(){\n    it('login sucessfully', function (done) {\n        request.post('/user')\n        .send({\n            username: 'username',\n            password: '123456'\n        })\n        .end(function (err, res) {\n            should.not.exists(err);\n            done();\n        });\n    });\n})\n```\n\n5、.attach()\n.attach方法主要用来测试文件上传，由于.send()只能上传文本域，所以关于multipart -file的上传需要通过附件来绑定。\n```\nrequest(app)\n.post('/')\n.field('name', 'my awesome avatar')\n.attach('avatar', 'test/fixtures/homeboy.jpg')\n...\n```\n\n#### 持久化Cookie\n在很多业务测试中，需要用户先登录才有权限执行操作。这个时候作为HTTP请求模拟，必须要可以保存一些Cookie数据，也就是Cookie的持久化。这一般有两种解决思路。\n1、在 supertest 中，可以通过 var request = supertest.agent(app) 获取一个 agent 对象，这个对象的 API 跟直接在 superagent 上调用各种方法是一样的。这个request在被多次调用 get 和 post 之后，可以一路把 cookie 都保存下来。\n```\nvar supertest = require('supertest');\n  var app = express();\n  var request = supertest.agent(app);\n\n  request.post('login').end(...);\n  // then ..\n  request.post('create_topic').end(...); // 此时的request中有用户登陆后的 cookie\n```\n2、通过.set()，在发起请求时，调用 .set('Cookie', 'a cookie string') 这样的方式。\n```\nvar request = require('supertest');\nvar userCookie;\nrequest.post('login')\n.end(function (err, res) {\n    userCookie = res.headers['Cookie']\n});\n// then ..\n\nrequest.post('create_topic')\n    .set('Cookie', userCookie)\n    .end(...)\n```\n\n### 2、实战demo\n为了更好地帮助理解SuperTest的强大功能，这里放上我的一个项目模块的测试demo。\n#### 项目源文件\n首先，这是一个express应用的登录注册和用户信息修改模块，要测试的就是这个user模块。为了节省篇幅，这里只放上UserController和Router两个项目文件。\n```\nUserController.js\n// 用户首页\nexports.getUser = function (req, res) {\n    if (!req.user) {\n        res.send({status: false, info: '未登录'});\n    } else {\n        res.render('user', {status: true, userdata: req.user});\n    }\n};\n\nexports.login =  function (req, res, next) {\n    req.session.save(function (err) {\n        if (err) {\n            log.error(err);\n            return next(err);\n        }\n        res.redirect('/user/' + req.user.username);\n    });\n};\n\nexports.logout = function (req, res, next) {\n    req.logout();\n    req.session.save(function (err) {\n        if (err) {\n            log.error(err);\n            return next (err);\n        }\n        res.redirect('/user');\n        res.end();\n    });\n};\n\n// 用户注册\nexports.addUser = function (req, res, next) {\n    if (!req.body.username || !req.body.password) {\n        return res.send({status: false, info: '用户名或密码不能为空'});\n    } else if (req.body.password.length < 6) {\n        return res.send({status: false, info: '密码长度太短'});\n    } \n\n    User.register(new User({username: req.body.username}), req.body.password, function (err, user) {\n        if (err) {\n            log.error(err);\n            return res.render('register', {info: '用户名已被使用'});\n        } \n        passport.authenticate('local')(req, res, function () {\n            req.session.save(function (err) {\n                if (err) {\n                    log.error(err);\n                    return next(err);\n                }\n                res.redirect('/user/' + req.body.username);\n            });\n        });\n\n    });\n};\n\n// 更新用户信息文字资料\nexports.updateInfo = function (req, res, next) {\n    User.findOne({username: req.user.username}, function (err, doc) {\n        if (doc) {\n            doc.update(req.body, function (err, data) {\n                if (err) {\n                    log.error(err);\n                    return next(err);\n                }\n                res.send({status: true});\n            });\n        } else {\n            next();\n        }\n    });\n};\n\n// 更换头像\nexports.updateAvator = function (req, res,next) {\n    upload(req, res, function (err) {\n        if (err) {\n            log.error(err);\n            return next(err);\n        }\n        User.findOne({username: req.user.username}, function (err, doc) {\n            if (err) {\n                log.error(err);\n                return next(err);\n            } else if (doc) {\n                doc.update({avator: req.file.filename}, function (err, data) {\n                    if (err) {\n                        log.error(err);\n                        return next(err);\n                    }\n                    res.type('html');\n                    res.send({status: true, avator: req.file.filename});\n                });\n            } else {\n                return next();\n            }\n        });\n    });\n};\n```\nRouter文件\n```\nrouter.get('/:uid', isAuthenticated, user.getUser);\nrouter.get('/', function (req, res) {\n    res.render('login', {info: ''});\n});\nrouter.post('/',passport.authenticate('local'), /*{failureRedirect: '/user'}),*/ user.login);\n\nrouter.post('/authenticate/logout', user.logout);\n\nrouter.get('/authenticate/register', function (req, res) {\n    res.render('register', {info: ''});\n});\n\nrouter.post('/authenticate/register', user.addUser);\n\n// 用户相关的资料\nrouter.post('/update/info', user.updateInfo);\nrouter.post('/update/avator', user.updateAvator);\n\nmodule.exports = router;\n```\n\n#### 测试脚本\n首先，测试注册功能。为了防止用户名冲突，在测试用例之前设置钩子before块，清除User集合。\n```\n // user.test.js\n describe('test user.addUser()', function () {\n        before(function (done) {\n            User.remove({}, function (err) {\n                done();\n            });\n        });\n\n        it('register sucessfully', function (done) {\n            request.post('/user/authenticate/register')\n            .send({\n                username: 'username',\n                password: '123456'\n            })\n            //注册成功之后重定向\n            .expect(302, function (err, res) {\n                should.not.exists(err);\n                done();\n            });\n        });\n        //测试用户名存在的用例\n        it('username already exist', function (done) {\n            request.post('/user/authenticate/register')\n            .send({\n                username: 'username',\n                password: '123456'\n            })\n            .end(function (err, res) {\n                should.not.exists(err);\n                res.text.should.containEql('用户名已被使用');\n                done();\n            });\n        });\n    });\n    // 测试头像上传\n    describe('test user.updateAvator()', function () {\n        //bofore HOOKS，测试业务逻辑之前先登录，并持久化cookie\n        before(function (done) {\n            request.post('/user')\n            .send({\n                username: 'username',\n                password: '123456'\n            })\n            .end(function (err, res) {\n                done();\n            });\n        });\n\n        it('update avator upload sucessfully', function (done) {\n            request.post('/user/update/avator')\n            .attach('avator','test/image/test.jpg')\n            .end(function (err, res) {\n                should.not.exists(err);\n                res.text.should.containEql('\"status\":true');\n                done();\n            });\n        }); \n    });\n```\n\n","slug":"单元测试工具Mocha和SuperTest组合","published":1,"updated":"2016-08-13T03:08:44.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtrr00257kauygejl77d","content":"<p>毕业季，一堆乱七八糟的事情搞得已经整整两个月没有时间写写笔记了。最近进行着一个Node小项目，其中关于单元测试部分花了不少时间去踩坑。所以在这里简单总结一下关于Node开发测试框架Mocha(摩卡)的一些基础用法。由于本人是入门级别的Node开发者，所以这篇文章也是仅适用于和我一样的初级Node开发者，如有不正确的地方欢迎大神们指正！<br><a id=\"more\"></a></p>\n<h2 id=\"一、Mocha\"><a href=\"#一、Mocha\" class=\"headerlink\" title=\"一、Mocha\"></a>一、Mocha</h2><p>Mocha是非常流行JavaScript测试框架之一，在浏览器和Node环境都可以使用。这里主要是针对Node环境。</p>\n<h3 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h3><p>关于Mocha的安装当然是万能的npm了，直接npm install就OK，这里不再罗嗦了。</p>\n<h3 id=\"2、使用\"><a href=\"#2、使用\" class=\"headerlink\" title=\"2、使用\"></a>2、使用</h3><p>然后就是Mocha的语法了。首先来看一下最简单例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这是一个简单的加法函数</span></div><div class=\"line\"><span class=\"comment\">//add.js</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a+b;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = add;</div></pre></td></tr></table></figure></p>\n<p>现在用Mocha写一个测试脚本去测试这个函数。一般来说，测试脚本的命名要和测试的模块一致，后缀为.test.js。这里测试脚本的名称为add.test.js，表示对add模块进行测试。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//add.test.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"keyword\">require</span>(<span class=\"string\">'./add'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> should = <span class=\"keyword\">require</span>(<span class=\"string\">'should'</span>);</div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'test add'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    it(<span class=\"string\">'1 + 1 should be equal to 2'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(done)</span></span>&#123;</div><div class=\"line\">        (add(<span class=\"number\">1</span>,<span class=\"number\">1</span>) === <span class=\"number\">2</span>).should.be.<span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>然后保存代码之后进入终端，执行mocha add.test 即可。其中describe()函数是测试描述，表示一组相关测试用例是对哪个模块的测试。it()是一个测试用例，在一个describe块的内部可以执行对个测试用例(it块)。</p>\n<p>这是同步函数的测试。在Node环境中，绝大部分的业务逻辑都是异步的，所以测试结果的回调是JavaScript测试框架需要解决的首要问题。Mocha提供了一个回调函数done，在业务代码执行完毕之后调用done()结束测试用例，不然的话测试用例就会出现timeout的情况导致测试用例失败。Mocha默认的超时时间是2000毫秒，如果由于测试用例的执行时间比较长需要延长超时时间，可以在命令行添加 -t 参数，比如mocha -t 3000 add.test.js。当然还有其他命令行参数，比如 mocha -w 用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。查看更多的命令行参数可以通过 mocha -h 查找。</p>\n<p>那么接下来看一个异步测试例子：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe('test async function', function()&#123;</div><div class=\"line\">    it('supertest example', function(<span class=\"name\">done</span>)&#123;</div><div class=\"line\">        request.post('/')</div><div class=\"line\">        .expect(<span class=\"number\">200</span>)</div><div class=\"line\">        .end(<span class=\"name\">function</span>(<span class=\"name\">err</span>, res) &#123;</div><div class=\"line\">            should.not.exist(<span class=\"name\">err</span>)<span class=\"comment\">;</span></div><div class=\"line\">            done()<span class=\"comment\">;</span></div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>在request请求执行完毕end()之后，一定要调用done()，否则测试用例超时，那么这个用例就失败了。当然这里用到了断言库should，稍后再介绍它的语法。</p>\n<h3 id=\"3、钩子-hooks\"><a href=\"#3、钩子-hooks\" class=\"headerlink\" title=\"3、钩子(hooks)\"></a>3、钩子(hooks)</h3><p>Mocha的Hooks主要是用来设置前置条件和后置处理。比如说一个业务请求之前必须先登录，那个登录操作就在before()里面完成。Mocha提供了before,after,beforeEach,afterEach四个钩子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe(<span class=\"string\">'hooks'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  before(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs before all tests in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  after(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs after all tests in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  beforeEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs before each test in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  afterEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs after each test in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  it(<span class=\"string\">'test'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//test here</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>如果说某个测试需要跳过，使用it.skip()，Mocha跳过这个用例而不影响其他it块；只测试某个测试用例，使用it.only()，Mocha只执行.only用例，无视其他it块。</p>\n<h2 id=\"二、断言库should\"><a href=\"#二、断言库should\" class=\"headerlink\" title=\"二、断言库should\"></a>二、断言库should</h2><p>Mocha本身是不包含断言库的，所以我们需要自己选择断言库。should是一个很简单的、贴近自然语言的断言库。当然，Mocha是适配所有的断言库的，如果你喜欢其他的断言库比如expect之类的，你也可以把它包含进来使用。</p>\n<p>should的语法非常贴近自然语言，简单易懂，常见的should断言如下：<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 全等，相当于===</span></div><div class=\"line\">.exactly</div><div class=\"line\">(<span class=\"number\">5</span>).should.be.exactly(<span class=\"number\">5</span>)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 对象存在</span></div><div class=\"line\">.ok</div><div class=\"line\"><span class=\"literal\">true</span>.should.be.ok;</div><div class=\"line\"><span class=\"string\">'yay'</span>.should.be.ok;</div><div class=\"line\">(<span class=\"number\">1</span>).should.be.ok;</div><div class=\"line\">(&#123;&#125;).should.be.ok;</div><div class=\"line\"><span class=\"literal\">false</span>.should.not.be.ok;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 真</span></div><div class=\"line\">.<span class=\"literal\">true</span></div><div class=\"line\">(<span class=\"number\">5</span>===<span class=\"number\">5</span>).should.be.<span class=\"literal\">true</span></div><div class=\"line\">(err === <span class=\"literal\">null</span>).should.be.<span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 相等,相当于 ==</span></div><div class=\"line\">.eql</div><div class=\"line\">(&#123; <span class=\"string\">foo:</span> <span class=\"string\">'bar'</span> &#125;).should.eql(&#123; <span class=\"string\">foo:</span> <span class=\"string\">'bar'</span> &#125;);</div><div class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].should.eql([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]);</div><div class=\"line\"><span class=\"comment\">// see next example it is correct, even if it is different types, but actual content the same</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].should.eql(&#123; <span class=\"string\">'0'</span>: <span class=\"number\">1</span>, <span class=\"string\">'1'</span>: <span class=\"number\">2</span>, <span class=\"string\">'2'</span>: <span class=\"number\">3</span> &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 非数字</span></div><div class=\"line\">.NaN</div><div class=\"line\">(undefined + <span class=\"number\">0</span>).should.be.NaN;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 判断类型</span></div><div class=\"line\">.typeof</div><div class=\"line\">user.should.be.type(<span class=\"string\">'object'</span>);</div><div class=\"line\"><span class=\"string\">'test'</span>.should.be.type(<span class=\"string\">'string'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 构造函数的一个实例</span></div><div class=\"line\">.<span class=\"keyword\">instanceof</span></div><div class=\"line\">user.should.be.an.<span class=\"keyword\">instanceof</span>(User);</div><div class=\"line\">[].should.be.an.instanceOf(Array);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 存在</span></div><div class=\"line\">.exist()</div><div class=\"line\">should.not.exist(err)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//深度包含</span></div><div class=\"line\">.containDeep()</div><div class=\"line\">[[<span class=\"number\">1</span>],[<span class=\"number\">2</span>],[<span class=\"number\">3</span>]].should.containDeep([[<span class=\"number\">3</span>]]);</div><div class=\"line\">[[<span class=\"number\">1</span>],[<span class=\"number\">2</span>],[<span class=\"number\">3</span>, <span class=\"number\">4</span>]].should.containDeep([[<span class=\"number\">3</span>]]);</div><div class=\"line\">[&#123;<span class=\"string\">a:</span> <span class=\"string\">'a'</span>&#125;, &#123;<span class=\"string\">b:</span> <span class=\"string\">'b'</span>, <span class=\"string\">c:</span> <span class=\"string\">'c'</span>&#125;].should.containDeep([&#123;<span class=\"string\">a:</span> <span class=\"string\">'a'</span>&#125;]);</div><div class=\"line\">[&#123;<span class=\"string\">a:</span> <span class=\"string\">'a'</span>&#125;, &#123;<span class=\"string\">b:</span> <span class=\"string\">'b'</span>, <span class=\"string\">c:</span> <span class=\"string\">'c'</span>&#125;].should.containDeep([&#123;<span class=\"string\">b:</span> <span class=\"string\">'b'</span>&#125;]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 抛出异常</span></div><div class=\"line\">.<span class=\"keyword\">throw</span>()和throwError()</div><div class=\"line\">(function()&#123;</div><div class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">'fail'</span>);</div><div class=\"line\">&#125;).should.<span class=\"keyword\">throw</span>();</div><div class=\"line\">(function()&#123;</div><div class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">'fail'</span>);</div><div class=\"line\">&#125;).should.<span class=\"keyword\">throw</span>(<span class=\"string\">'fail'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// http响应的头部包含</span></div><div class=\"line\">.header</div><div class=\"line\">res.should.have.header(<span class=\"string\">'content-length'</span>);</div><div class=\"line\">res.should.have.header(<span class=\"string\">'Content-Length'</span>, <span class=\"string\">'123'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 包含或等价于</span></div><div class=\"line\">.containEql</div><div class=\"line\">(&#123; <span class=\"string\">b:</span> <span class=\"number\">10</span> &#125;).should.containEql(&#123; <span class=\"string\">b:</span> <span class=\"number\">10</span> &#125;);</div><div class=\"line\">([<span class=\"number\">1</span>, <span class=\"number\">2</span>, &#123; <span class=\"string\">a:</span> <span class=\"number\">10</span> &#125;]).should.containEql(&#123; <span class=\"string\">a:</span> <span class=\"number\">10</span> &#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"三、SuperTest\"><a href=\"#三、SuperTest\" class=\"headerlink\" title=\"三、SuperTest\"></a>三、SuperTest</h2><p>单单使用Mocha和should就几乎可以满足所有JavaScript函数的单元测试。但是对于Node应用而言，不仅仅是函数的集合，比如一个web应用的测试。这时候就需要配合一个http代理，完成Http请求和路由的测试。<br>Supertest是一个HTTP代理服务引擎，可以模拟一切HTTP请求行为。Supertest可以搭配任意的应用框架，从而进行应用的单元测试。</p>\n<h3 id=\"1、用法\"><a href=\"#1、用法\" class=\"headerlink\" title=\"1、用法\"></a>1、用法</h3><h4 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h4><p>首先，传入应用来实例化supertest,比如说实例化一个express：<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">var supertest</span> = require(<span class=\"string\">'supertest'</span>), </div><div class=\"line\">    express = require(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"attribute\">var app</span> = express();</div><div class=\"line\"><span class=\"attribute\">var request</span> = supertest(app);</div></pre></td></tr></table></figure></p>\n<p>接下来就可以在Mocha测试用例中直接使用request发出一个基于该web应用的http请求了。</p>\n<p>1、.set()<br>如果需要设置数据，supertest的API提供了 .set 来设置，比如：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe('GET /users', function()&#123;</div><div class=\"line\">  it('respond with json', function(<span class=\"name\">done</span>)&#123;</div><div class=\"line\">    request(<span class=\"name\">app</span>)</div><div class=\"line\">      .get('/user')</div><div class=\"line\">      .set('Accept', 'application/json')</div><div class=\"line\">      .expect(<span class=\"number\">200</span>)</div><div class=\"line\">      .end(<span class=\"name\">function</span>(<span class=\"name\">err</span>, res)&#123;</div><div class=\"line\">        should.not.exist(<span class=\"name\">err</span>)<span class=\"comment\">;</span></div><div class=\"line\">        res.text.should.containEql('success')<span class=\"comment\">;</span></div><div class=\"line\">        done()<span class=\"comment\">;</span></div><div class=\"line\">      &#125;)<span class=\"comment\">;</span></div><div class=\"line\">  &#125;)<span class=\"comment\">;</span></div><div class=\"line\">&#125;)<span class=\"comment\">;</span></div></pre></td></tr></table></figure></p>\n<p>2、.expect()<br>.expect 是一个断言，上述测试代码在执行之后期望的状态码是200(OK)。如果接收到的数据为html页面，.expect(‘Content-Type’, ‘text/html;charset=utf-8’)</p>\n<p>3、.end()<br>.end 是执行一个request请求，在回调函数里面根据业务逻辑的返回数据做断言分析。</p>\n<p>4、.send()<br>很多情况下，项目需要测试一个表单业务。supertest提供了.send()方法来发送表单域数据。比如一个登录模块，需要发送用户名密码：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe('test login', function()&#123;</div><div class=\"line\">    it('login sucessfully', function (<span class=\"name\">done</span>) &#123;</div><div class=\"line\">        request.post('/user')</div><div class=\"line\">        .send(&#123;</div><div class=\"line\">            username: 'username',</div><div class=\"line\">            password: '<span class=\"number\">123456</span>'</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .end(<span class=\"name\">function</span> (<span class=\"name\">err</span>, res) &#123;</div><div class=\"line\">            should.not.exists(<span class=\"name\">err</span>)<span class=\"comment\">;</span></div><div class=\"line\">            done()<span class=\"comment\">;</span></div><div class=\"line\">        &#125;)<span class=\"comment\">;</span></div><div class=\"line\">    &#125;)<span class=\"comment\">;</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>5、.attach()<br>.attach方法主要用来测试文件上传，由于.send()只能上传文本域，所以关于multipart -file的上传需要通过附件来绑定。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"title\">request</span><span class=\"params\">(app)</span></span></div><div class=\"line\">.post(<span class=\"string\">'/'</span>)</div><div class=\"line\">.field(<span class=\"string\">'name'</span>, <span class=\"string\">'my awesome avatar'</span>)</div><div class=\"line\">.attach(<span class=\"string\">'avatar'</span>, <span class=\"string\">'test/fixtures/homeboy.jpg'</span>)</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h4 id=\"持久化Cookie\"><a href=\"#持久化Cookie\" class=\"headerlink\" title=\"持久化Cookie\"></a>持久化Cookie</h4><p>在很多业务测试中，需要用户先登录才有权限执行操作。这个时候作为HTTP请求模拟，必须要可以保存一些Cookie数据，也就是Cookie的持久化。这一般有两种解决思路。<br>1、在 supertest 中，可以通过 var request = supertest.agent(app) 获取一个 agent 对象，这个对象的 API 跟直接在 superagent 上调用各种方法是一样的。这个request在被多次调用 get 和 post 之后，可以一路把 cookie 都保存下来。<br><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">var</span> supertest = <span class=\"keyword\">require</span>(<span class=\"string\">'supertest'</span>);</div><div class=\"line\">  <span class=\"built_in\">var</span> app = express();</div><div class=\"line\">  <span class=\"built_in\">var</span> request = supertest.agent(app);</div><div class=\"line\"></div><div class=\"line\">  request.post(<span class=\"string\">'login'</span>).end(<span class=\"params\">...</span>);</div><div class=\"line\">  <span class=\"comment\">// then ..</span></div><div class=\"line\">  request.post(<span class=\"string\">'create_topic'</span>).end(<span class=\"params\">...</span>); <span class=\"comment\">// 此时的request中有用户登陆后的 cookie</span></div></pre></td></tr></table></figure></p>\n<p>2、通过.set()，在发起请求时，调用 .set(‘Cookie’, ‘a cookie string’) 这样的方式。<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = require(<span class=\"string\">'supertest'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> userCookie;</div><div class=\"line\">request.post(<span class=\"string\">'login'</span>)</div><div class=\"line\">.<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> <span class=\"comment\">&#123;</span></span></div><div class=\"line\">    userCookie = res.headers['Cookie']</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">// then ..</span></div><div class=\"line\"></div><div class=\"line\">request.post(<span class=\"string\">'create_topic'</span>)</div><div class=\"line\">    .<span class=\"keyword\">set</span>(<span class=\"string\">'Cookie'</span>, userCookie)</div><div class=\"line\">    .<span class=\"keyword\">end</span>(...)</div></pre></td></tr></table></figure></p>\n<h3 id=\"2、实战demo\"><a href=\"#2、实战demo\" class=\"headerlink\" title=\"2、实战demo\"></a>2、实战demo</h3><p>为了更好地帮助理解SuperTest的强大功能，这里放上我的一个项目模块的测试demo。</p>\n<h4 id=\"项目源文件\"><a href=\"#项目源文件\" class=\"headerlink\" title=\"项目源文件\"></a>项目源文件</h4><p>首先，这是一个express应用的登录注册和用户信息修改模块，要测试的就是这个user模块。为了节省篇幅，这里只放上UserController和Router两个项目文件。<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div></pre></td><td class=\"code\"><pre><div class=\"line\">UserController.js</div><div class=\"line\">// 用户首页</div><div class=\"line\">exports.getUser = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!req.user) &#123;</div><div class=\"line\">        res.send(&#123;status: <span class=\"keyword\">false</span>, info: <span class=\"string\">'未登录'</span>&#125;);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        res.render(<span class=\"string\">'user'</span>, &#123;status: <span class=\"keyword\">true</span>, userdata: req.user&#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">exports.login =  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    req.session.save(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        res.redirect(<span class=\"string\">'/user/'</span> + req.user.username);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">exports.logout = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    req.logout();</div><div class=\"line\">    req.session.save(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span> (err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        res.redirect(<span class=\"string\">'/user'</span>);</div><div class=\"line\">        res.<span class=\"keyword\">end</span>();</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 用户注册</div><div class=\"line\">exports.addUser = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!req.body.username || !req.body.password) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> res.send(&#123;status: <span class=\"keyword\">false</span>, info: <span class=\"string\">'用户名或密码不能为空'</span>&#125;);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (req.body.password.length &lt; <span class=\"number\">6</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> res.send(&#123;status: <span class=\"keyword\">false</span>, info: <span class=\"string\">'密码长度太短'</span>&#125;);</div><div class=\"line\">    &#125; </div><div class=\"line\"></div><div class=\"line\">    User.register(new User(&#123;username: req.body.username&#125;), req.body.password, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, user)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> res.render(<span class=\"string\">'register'</span>, &#123;info: <span class=\"string\">'用户名已被使用'</span>&#125;);</div><div class=\"line\">        &#125; </div><div class=\"line\">        passport.authenticate(<span class=\"string\">'local'</span>)(req, res, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span> &#123;</div><div class=\"line\">            req.session.save(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                    log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">                &#125;</div><div class=\"line\">                res.redirect(<span class=\"string\">'/user/'</span> + req.body.username);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 更新用户信息文字资料</div><div class=\"line\">exports.updateInfo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    User.findOne(&#123;username: req.user.username&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, doc)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (doc) &#123;</div><div class=\"line\">            doc.update(req.body, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, data)</span></span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                    log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">                &#125;</div><div class=\"line\">                res.send(&#123;status: <span class=\"keyword\">true</span>&#125;);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">next</span>();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 更换头像</div><div class=\"line\">exports.updateAvator = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res,next)</span></span> &#123;</div><div class=\"line\">    upload(req, res, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        User.findOne(&#123;username: req.user.username&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, doc)</span></span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (doc) &#123;</div><div class=\"line\">                doc.update(&#123;avator: req.file.filename&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, data)</span></span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                        log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    res.<span class=\"built_in\">type</span>(<span class=\"string\">'html'</span>);</div><div class=\"line\">                    res.send(&#123;status: <span class=\"keyword\">true</span>, avator: req.file.filename&#125;);</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>Router文件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">router.get(<span class=\"string\">'/:uid'</span>, isAuthenticated, user.getUser);</div><div class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">    res.render(<span class=\"string\">'login'</span>, &#123;info: <span class=\"string\">''</span>&#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\">router.post(<span class=\"string\">'/'</span>,passport.authenticate(<span class=\"string\">'local'</span>), <span class=\"comment\">/*&#123;failureRedirect: '/user'&#125;),*/</span> user.login);</div><div class=\"line\"></div><div class=\"line\">router.post(<span class=\"string\">'/authenticate/logout'</span>, user.logout);</div><div class=\"line\"></div><div class=\"line\">router.get(<span class=\"string\">'/authenticate/register'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">    res.render(<span class=\"string\">'register'</span>, &#123;info: <span class=\"string\">''</span>&#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">router.post(<span class=\"string\">'/authenticate/register'</span>, user.addUser);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 用户相关的资料</span></div><div class=\"line\">router.post(<span class=\"string\">'/update/info'</span>, user.updateInfo);</div><div class=\"line\">router.post(<span class=\"string\">'/update/avator'</span>, user.updateAvator);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = router;</div></pre></td></tr></table></figure></p>\n<h4 id=\"测试脚本\"><a href=\"#测试脚本\" class=\"headerlink\" title=\"测试脚本\"></a>测试脚本</h4><p>首先，测试注册功能。为了防止用户名冲突，在测试用例之前设置钩子before块，清除User集合。<br><figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// user.test.js</span></div><div class=\"line\">describe(<span class=\"string\">'test user.addUser()'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> &#123;</span></div><div class=\"line\">       before(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           User.remove(&#123;&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span> &#123;</span></div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\"></div><div class=\"line\">       it(<span class=\"string\">'register sucessfully'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user/authenticate/register'</span>)</div><div class=\"line\">           .send(&#123;</div><div class=\"line\">               username: <span class=\"string\">'username'</span>,</div><div class=\"line\">               password: <span class=\"string\">'123456'</span></div><div class=\"line\">           &#125;)</div><div class=\"line\">           <span class=\"comment\">//注册成功之后重定向</span></div><div class=\"line\">           .expect(<span class=\"number\">302</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               should.not.<span class=\"built_in\">exists</span>(err);</div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\">       <span class=\"comment\">//测试用户名存在的用例</span></div><div class=\"line\">       it(<span class=\"string\">'username already exist'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user/authenticate/register'</span>)</div><div class=\"line\">           .send(&#123;</div><div class=\"line\">               username: <span class=\"string\">'username'</span>,</div><div class=\"line\">               password: <span class=\"string\">'123456'</span></div><div class=\"line\">           &#125;)</div><div class=\"line\">           .<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               should.not.<span class=\"built_in\">exists</span>(err);</div><div class=\"line\">               res.text.should.containEql(<span class=\"string\">'用户名已被使用'</span>);</div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\">   &#125;);</div><div class=\"line\">   <span class=\"comment\">// 测试头像上传</span></div><div class=\"line\">   describe(<span class=\"string\">'test user.updateAvator()'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> &#123;</span></div><div class=\"line\">       <span class=\"comment\">//bofore HOOKS，测试业务逻辑之前先登录，并持久化cookie</span></div><div class=\"line\">       before(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user'</span>)</div><div class=\"line\">           .send(&#123;</div><div class=\"line\">               username: <span class=\"string\">'username'</span>,</div><div class=\"line\">               password: <span class=\"string\">'123456'</span></div><div class=\"line\">           &#125;)</div><div class=\"line\">           .<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\"></div><div class=\"line\">       it(<span class=\"string\">'update avator upload sucessfully'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user/update/avator'</span>)</div><div class=\"line\">           .attach(<span class=\"string\">'avator'</span>,<span class=\"string\">'test/image/test.jpg'</span>)</div><div class=\"line\">           .<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               should.not.<span class=\"built_in\">exists</span>(err);</div><div class=\"line\">               res.text.should.containEql(<span class=\"string\">'\"</span>status<span class=\"string\">\":true'</span>);</div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;); </div><div class=\"line\">   &#125;);</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>毕业季，一堆乱七八糟的事情搞得已经整整两个月没有时间写写笔记了。最近进行着一个Node小项目，其中关于单元测试部分花了不少时间去踩坑。所以在这里简单总结一下关于Node开发测试框架Mocha(摩卡)的一些基础用法。由于本人是入门级别的Node开发者，所以这篇文章也是仅适用于和我一样的初级Node开发者，如有不正确的地方欢迎大神们指正！<br>","more":"</p>\n<h2 id=\"一、Mocha\"><a href=\"#一、Mocha\" class=\"headerlink\" title=\"一、Mocha\"></a>一、Mocha</h2><p>Mocha是非常流行JavaScript测试框架之一，在浏览器和Node环境都可以使用。这里主要是针对Node环境。</p>\n<h3 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h3><p>关于Mocha的安装当然是万能的npm了，直接npm install就OK，这里不再罗嗦了。</p>\n<h3 id=\"2、使用\"><a href=\"#2、使用\" class=\"headerlink\" title=\"2、使用\"></a>2、使用</h3><p>然后就是Mocha的语法了。首先来看一下最简单例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这是一个简单的加法函数</span></div><div class=\"line\"><span class=\"comment\">//add.js</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a+b;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = add;</div></pre></td></tr></table></figure></p>\n<p>现在用Mocha写一个测试脚本去测试这个函数。一般来说，测试脚本的命名要和测试的模块一致，后缀为.test.js。这里测试脚本的名称为add.test.js，表示对add模块进行测试。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//add.test.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"keyword\">require</span>(<span class=\"string\">'./add'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> should = <span class=\"keyword\">require</span>(<span class=\"string\">'should'</span>);</div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'test add'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    it(<span class=\"string\">'1 + 1 should be equal to 2'</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(done)</span></span>&#123;</div><div class=\"line\">        (add(<span class=\"number\">1</span>,<span class=\"number\">1</span>) === <span class=\"number\">2</span>).should.be.<span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>然后保存代码之后进入终端，执行mocha add.test 即可。其中describe()函数是测试描述，表示一组相关测试用例是对哪个模块的测试。it()是一个测试用例，在一个describe块的内部可以执行对个测试用例(it块)。</p>\n<p>这是同步函数的测试。在Node环境中，绝大部分的业务逻辑都是异步的，所以测试结果的回调是JavaScript测试框架需要解决的首要问题。Mocha提供了一个回调函数done，在业务代码执行完毕之后调用done()结束测试用例，不然的话测试用例就会出现timeout的情况导致测试用例失败。Mocha默认的超时时间是2000毫秒，如果由于测试用例的执行时间比较长需要延长超时时间，可以在命令行添加 -t 参数，比如mocha -t 3000 add.test.js。当然还有其他命令行参数，比如 mocha -w 用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。查看更多的命令行参数可以通过 mocha -h 查找。</p>\n<p>那么接下来看一个异步测试例子：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe('test async function', function()&#123;</div><div class=\"line\">    it('supertest example', function(<span class=\"name\">done</span>)&#123;</div><div class=\"line\">        request.post('/')</div><div class=\"line\">        .expect(<span class=\"number\">200</span>)</div><div class=\"line\">        .end(<span class=\"name\">function</span>(<span class=\"name\">err</span>, res) &#123;</div><div class=\"line\">            should.not.exist(<span class=\"name\">err</span>)<span class=\"comment\">;</span></div><div class=\"line\">            done()<span class=\"comment\">;</span></div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>在request请求执行完毕end()之后，一定要调用done()，否则测试用例超时，那么这个用例就失败了。当然这里用到了断言库should，稍后再介绍它的语法。</p>\n<h3 id=\"3、钩子-hooks\"><a href=\"#3、钩子-hooks\" class=\"headerlink\" title=\"3、钩子(hooks)\"></a>3、钩子(hooks)</h3><p>Mocha的Hooks主要是用来设置前置条件和后置处理。比如说一个业务请求之前必须先登录，那个登录操作就在before()里面完成。Mocha提供了before,after,beforeEach,afterEach四个钩子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe(<span class=\"string\">'hooks'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  before(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs before all tests in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  after(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs after all tests in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  beforeEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs before each test in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  afterEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// runs after each test in this block</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  it(<span class=\"string\">'test'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//test here</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>如果说某个测试需要跳过，使用it.skip()，Mocha跳过这个用例而不影响其他it块；只测试某个测试用例，使用it.only()，Mocha只执行.only用例，无视其他it块。</p>\n<h2 id=\"二、断言库should\"><a href=\"#二、断言库should\" class=\"headerlink\" title=\"二、断言库should\"></a>二、断言库should</h2><p>Mocha本身是不包含断言库的，所以我们需要自己选择断言库。should是一个很简单的、贴近自然语言的断言库。当然，Mocha是适配所有的断言库的，如果你喜欢其他的断言库比如expect之类的，你也可以把它包含进来使用。</p>\n<p>should的语法非常贴近自然语言，简单易懂，常见的should断言如下：<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 全等，相当于===</span></div><div class=\"line\">.exactly</div><div class=\"line\">(<span class=\"number\">5</span>).should.be.exactly(<span class=\"number\">5</span>)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 对象存在</span></div><div class=\"line\">.ok</div><div class=\"line\"><span class=\"literal\">true</span>.should.be.ok;</div><div class=\"line\"><span class=\"string\">'yay'</span>.should.be.ok;</div><div class=\"line\">(<span class=\"number\">1</span>).should.be.ok;</div><div class=\"line\">(&#123;&#125;).should.be.ok;</div><div class=\"line\"><span class=\"literal\">false</span>.should.not.be.ok;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 真</span></div><div class=\"line\">.<span class=\"literal\">true</span></div><div class=\"line\">(<span class=\"number\">5</span>===<span class=\"number\">5</span>).should.be.<span class=\"literal\">true</span></div><div class=\"line\">(err === <span class=\"literal\">null</span>).should.be.<span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 相等,相当于 ==</span></div><div class=\"line\">.eql</div><div class=\"line\">(&#123; <span class=\"string\">foo:</span> <span class=\"string\">'bar'</span> &#125;).should.eql(&#123; <span class=\"string\">foo:</span> <span class=\"string\">'bar'</span> &#125;);</div><div class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].should.eql([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]);</div><div class=\"line\"><span class=\"comment\">// see next example it is correct, even if it is different types, but actual content the same</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].should.eql(&#123; <span class=\"string\">'0'</span>: <span class=\"number\">1</span>, <span class=\"string\">'1'</span>: <span class=\"number\">2</span>, <span class=\"string\">'2'</span>: <span class=\"number\">3</span> &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 非数字</span></div><div class=\"line\">.NaN</div><div class=\"line\">(undefined + <span class=\"number\">0</span>).should.be.NaN;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 判断类型</span></div><div class=\"line\">.typeof</div><div class=\"line\">user.should.be.type(<span class=\"string\">'object'</span>);</div><div class=\"line\"><span class=\"string\">'test'</span>.should.be.type(<span class=\"string\">'string'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 构造函数的一个实例</span></div><div class=\"line\">.<span class=\"keyword\">instanceof</span></div><div class=\"line\">user.should.be.an.<span class=\"keyword\">instanceof</span>(User);</div><div class=\"line\">[].should.be.an.instanceOf(Array);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 存在</span></div><div class=\"line\">.exist()</div><div class=\"line\">should.not.exist(err)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//深度包含</span></div><div class=\"line\">.containDeep()</div><div class=\"line\">[[<span class=\"number\">1</span>],[<span class=\"number\">2</span>],[<span class=\"number\">3</span>]].should.containDeep([[<span class=\"number\">3</span>]]);</div><div class=\"line\">[[<span class=\"number\">1</span>],[<span class=\"number\">2</span>],[<span class=\"number\">3</span>, <span class=\"number\">4</span>]].should.containDeep([[<span class=\"number\">3</span>]]);</div><div class=\"line\">[&#123;<span class=\"string\">a:</span> <span class=\"string\">'a'</span>&#125;, &#123;<span class=\"string\">b:</span> <span class=\"string\">'b'</span>, <span class=\"string\">c:</span> <span class=\"string\">'c'</span>&#125;].should.containDeep([&#123;<span class=\"string\">a:</span> <span class=\"string\">'a'</span>&#125;]);</div><div class=\"line\">[&#123;<span class=\"string\">a:</span> <span class=\"string\">'a'</span>&#125;, &#123;<span class=\"string\">b:</span> <span class=\"string\">'b'</span>, <span class=\"string\">c:</span> <span class=\"string\">'c'</span>&#125;].should.containDeep([&#123;<span class=\"string\">b:</span> <span class=\"string\">'b'</span>&#125;]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 抛出异常</span></div><div class=\"line\">.<span class=\"keyword\">throw</span>()和throwError()</div><div class=\"line\">(function()&#123;</div><div class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">'fail'</span>);</div><div class=\"line\">&#125;).should.<span class=\"keyword\">throw</span>();</div><div class=\"line\">(function()&#123;</div><div class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">'fail'</span>);</div><div class=\"line\">&#125;).should.<span class=\"keyword\">throw</span>(<span class=\"string\">'fail'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// http响应的头部包含</span></div><div class=\"line\">.header</div><div class=\"line\">res.should.have.header(<span class=\"string\">'content-length'</span>);</div><div class=\"line\">res.should.have.header(<span class=\"string\">'Content-Length'</span>, <span class=\"string\">'123'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 包含或等价于</span></div><div class=\"line\">.containEql</div><div class=\"line\">(&#123; <span class=\"string\">b:</span> <span class=\"number\">10</span> &#125;).should.containEql(&#123; <span class=\"string\">b:</span> <span class=\"number\">10</span> &#125;);</div><div class=\"line\">([<span class=\"number\">1</span>, <span class=\"number\">2</span>, &#123; <span class=\"string\">a:</span> <span class=\"number\">10</span> &#125;]).should.containEql(&#123; <span class=\"string\">a:</span> <span class=\"number\">10</span> &#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"三、SuperTest\"><a href=\"#三、SuperTest\" class=\"headerlink\" title=\"三、SuperTest\"></a>三、SuperTest</h2><p>单单使用Mocha和should就几乎可以满足所有JavaScript函数的单元测试。但是对于Node应用而言，不仅仅是函数的集合，比如一个web应用的测试。这时候就需要配合一个http代理，完成Http请求和路由的测试。<br>Supertest是一个HTTP代理服务引擎，可以模拟一切HTTP请求行为。Supertest可以搭配任意的应用框架，从而进行应用的单元测试。</p>\n<h3 id=\"1、用法\"><a href=\"#1、用法\" class=\"headerlink\" title=\"1、用法\"></a>1、用法</h3><h4 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h4><p>首先，传入应用来实例化supertest,比如说实例化一个express：<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">var supertest</span> = require(<span class=\"string\">'supertest'</span>), </div><div class=\"line\">    express = require(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"attribute\">var app</span> = express();</div><div class=\"line\"><span class=\"attribute\">var request</span> = supertest(app);</div></pre></td></tr></table></figure></p>\n<p>接下来就可以在Mocha测试用例中直接使用request发出一个基于该web应用的http请求了。</p>\n<p>1、.set()<br>如果需要设置数据，supertest的API提供了 .set 来设置，比如：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe('GET /users', function()&#123;</div><div class=\"line\">  it('respond with json', function(<span class=\"name\">done</span>)&#123;</div><div class=\"line\">    request(<span class=\"name\">app</span>)</div><div class=\"line\">      .get('/user')</div><div class=\"line\">      .set('Accept', 'application/json')</div><div class=\"line\">      .expect(<span class=\"number\">200</span>)</div><div class=\"line\">      .end(<span class=\"name\">function</span>(<span class=\"name\">err</span>, res)&#123;</div><div class=\"line\">        should.not.exist(<span class=\"name\">err</span>)<span class=\"comment\">;</span></div><div class=\"line\">        res.text.should.containEql('success')<span class=\"comment\">;</span></div><div class=\"line\">        done()<span class=\"comment\">;</span></div><div class=\"line\">      &#125;)<span class=\"comment\">;</span></div><div class=\"line\">  &#125;)<span class=\"comment\">;</span></div><div class=\"line\">&#125;)<span class=\"comment\">;</span></div></pre></td></tr></table></figure></p>\n<p>2、.expect()<br>.expect 是一个断言，上述测试代码在执行之后期望的状态码是200(OK)。如果接收到的数据为html页面，.expect(‘Content-Type’, ‘text/html;charset=utf-8’)</p>\n<p>3、.end()<br>.end 是执行一个request请求，在回调函数里面根据业务逻辑的返回数据做断言分析。</p>\n<p>4、.send()<br>很多情况下，项目需要测试一个表单业务。supertest提供了.send()方法来发送表单域数据。比如一个登录模块，需要发送用户名密码：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe('test login', function()&#123;</div><div class=\"line\">    it('login sucessfully', function (<span class=\"name\">done</span>) &#123;</div><div class=\"line\">        request.post('/user')</div><div class=\"line\">        .send(&#123;</div><div class=\"line\">            username: 'username',</div><div class=\"line\">            password: '<span class=\"number\">123456</span>'</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .end(<span class=\"name\">function</span> (<span class=\"name\">err</span>, res) &#123;</div><div class=\"line\">            should.not.exists(<span class=\"name\">err</span>)<span class=\"comment\">;</span></div><div class=\"line\">            done()<span class=\"comment\">;</span></div><div class=\"line\">        &#125;)<span class=\"comment\">;</span></div><div class=\"line\">    &#125;)<span class=\"comment\">;</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>5、.attach()<br>.attach方法主要用来测试文件上传，由于.send()只能上传文本域，所以关于multipart -file的上传需要通过附件来绑定。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"title\">request</span><span class=\"params\">(app)</span></span></div><div class=\"line\">.post(<span class=\"string\">'/'</span>)</div><div class=\"line\">.field(<span class=\"string\">'name'</span>, <span class=\"string\">'my awesome avatar'</span>)</div><div class=\"line\">.attach(<span class=\"string\">'avatar'</span>, <span class=\"string\">'test/fixtures/homeboy.jpg'</span>)</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h4 id=\"持久化Cookie\"><a href=\"#持久化Cookie\" class=\"headerlink\" title=\"持久化Cookie\"></a>持久化Cookie</h4><p>在很多业务测试中，需要用户先登录才有权限执行操作。这个时候作为HTTP请求模拟，必须要可以保存一些Cookie数据，也就是Cookie的持久化。这一般有两种解决思路。<br>1、在 supertest 中，可以通过 var request = supertest.agent(app) 获取一个 agent 对象，这个对象的 API 跟直接在 superagent 上调用各种方法是一样的。这个request在被多次调用 get 和 post 之后，可以一路把 cookie 都保存下来。<br><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">var</span> supertest = <span class=\"keyword\">require</span>(<span class=\"string\">'supertest'</span>);</div><div class=\"line\">  <span class=\"built_in\">var</span> app = express();</div><div class=\"line\">  <span class=\"built_in\">var</span> request = supertest.agent(app);</div><div class=\"line\"></div><div class=\"line\">  request.post(<span class=\"string\">'login'</span>).end(<span class=\"params\">...</span>);</div><div class=\"line\">  <span class=\"comment\">// then ..</span></div><div class=\"line\">  request.post(<span class=\"string\">'create_topic'</span>).end(<span class=\"params\">...</span>); <span class=\"comment\">// 此时的request中有用户登陆后的 cookie</span></div></pre></td></tr></table></figure></p>\n<p>2、通过.set()，在发起请求时，调用 .set(‘Cookie’, ‘a cookie string’) 这样的方式。<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = require(<span class=\"string\">'supertest'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> userCookie;</div><div class=\"line\">request.post(<span class=\"string\">'login'</span>)</div><div class=\"line\">.<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> <span class=\"comment\">&#123;</div><div class=\"line\">    userCookie = res.headers['Cookie']</div><div class=\"line\">&#125;</span>);</span></div><div class=\"line\"><span class=\"comment\">// then ..</span></div><div class=\"line\"></div><div class=\"line\">request.post(<span class=\"string\">'create_topic'</span>)</div><div class=\"line\">    .<span class=\"keyword\">set</span>(<span class=\"string\">'Cookie'</span>, userCookie)</div><div class=\"line\">    .<span class=\"keyword\">end</span>(...)</div></pre></td></tr></table></figure></p>\n<h3 id=\"2、实战demo\"><a href=\"#2、实战demo\" class=\"headerlink\" title=\"2、实战demo\"></a>2、实战demo</h3><p>为了更好地帮助理解SuperTest的强大功能，这里放上我的一个项目模块的测试demo。</p>\n<h4 id=\"项目源文件\"><a href=\"#项目源文件\" class=\"headerlink\" title=\"项目源文件\"></a>项目源文件</h4><p>首先，这是一个express应用的登录注册和用户信息修改模块，要测试的就是这个user模块。为了节省篇幅，这里只放上UserController和Router两个项目文件。<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div></pre></td><td class=\"code\"><pre><div class=\"line\">UserController.js</div><div class=\"line\">// 用户首页</div><div class=\"line\">exports.getUser = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!req.user) &#123;</div><div class=\"line\">        res.send(&#123;status: <span class=\"keyword\">false</span>, info: <span class=\"string\">'未登录'</span>&#125;);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        res.render(<span class=\"string\">'user'</span>, &#123;status: <span class=\"keyword\">true</span>, userdata: req.user&#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">exports.login =  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    req.session.save(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        res.redirect(<span class=\"string\">'/user/'</span> + req.user.username);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">exports.logout = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    req.logout();</div><div class=\"line\">    req.session.save(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span> (err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        res.redirect(<span class=\"string\">'/user'</span>);</div><div class=\"line\">        res.<span class=\"keyword\">end</span>();</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 用户注册</div><div class=\"line\">exports.addUser = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!req.body.username || !req.body.password) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> res.send(&#123;status: <span class=\"keyword\">false</span>, info: <span class=\"string\">'用户名或密码不能为空'</span>&#125;);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (req.body.password.length &lt; <span class=\"number\">6</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> res.send(&#123;status: <span class=\"keyword\">false</span>, info: <span class=\"string\">'密码长度太短'</span>&#125;);</div><div class=\"line\">    &#125; </div><div class=\"line\"></div><div class=\"line\">    User.register(new User(&#123;username: req.body.username&#125;), req.body.password, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, user)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> res.render(<span class=\"string\">'register'</span>, &#123;info: <span class=\"string\">'用户名已被使用'</span>&#125;);</div><div class=\"line\">        &#125; </div><div class=\"line\">        passport.authenticate(<span class=\"string\">'local'</span>)(req, res, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span> &#123;</div><div class=\"line\">            req.session.save(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                    log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">                &#125;</div><div class=\"line\">                res.redirect(<span class=\"string\">'/user/'</span> + req.body.username);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 更新用户信息文字资料</div><div class=\"line\">exports.updateInfo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res, next)</span></span> &#123;</div><div class=\"line\">    User.findOne(&#123;username: req.user.username&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, doc)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (doc) &#123;</div><div class=\"line\">            doc.update(req.body, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, data)</span></span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                    log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">                &#125;</div><div class=\"line\">                res.send(&#123;status: <span class=\"keyword\">true</span>&#125;);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">next</span>();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 更换头像</div><div class=\"line\">exports.updateAvator = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(req, res,next)</span></span> &#123;</div><div class=\"line\">    upload(req, res, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        User.findOne(&#123;username: req.user.username&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, doc)</span></span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (doc) &#123;</div><div class=\"line\">                doc.update(&#123;avator: req.file.filename&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, data)</span></span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                        log.<span class=\"built_in\">error</span>(err);</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(err);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    res.<span class=\"built_in\">type</span>(<span class=\"string\">'html'</span>);</div><div class=\"line\">                    res.send(&#123;status: <span class=\"keyword\">true</span>, avator: req.file.filename&#125;);</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>Router文件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">router.get(<span class=\"string\">'/:uid'</span>, isAuthenticated, user.getUser);</div><div class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">    res.render(<span class=\"string\">'login'</span>, &#123;info: <span class=\"string\">''</span>&#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\">router.post(<span class=\"string\">'/'</span>,passport.authenticate(<span class=\"string\">'local'</span>), <span class=\"comment\">/*&#123;failureRedirect: '/user'&#125;),*/</span> user.login);</div><div class=\"line\"></div><div class=\"line\">router.post(<span class=\"string\">'/authenticate/logout'</span>, user.logout);</div><div class=\"line\"></div><div class=\"line\">router.get(<span class=\"string\">'/authenticate/register'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">    res.render(<span class=\"string\">'register'</span>, &#123;info: <span class=\"string\">''</span>&#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">router.post(<span class=\"string\">'/authenticate/register'</span>, user.addUser);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 用户相关的资料</span></div><div class=\"line\">router.post(<span class=\"string\">'/update/info'</span>, user.updateInfo);</div><div class=\"line\">router.post(<span class=\"string\">'/update/avator'</span>, user.updateAvator);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = router;</div></pre></td></tr></table></figure></p>\n<h4 id=\"测试脚本\"><a href=\"#测试脚本\" class=\"headerlink\" title=\"测试脚本\"></a>测试脚本</h4><p>首先，测试注册功能。为了防止用户名冲突，在测试用例之前设置钩子before块，清除User集合。<br><figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// user.test.js</span></div><div class=\"line\">describe(<span class=\"string\">'test user.addUser()'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> &#123;</span></div><div class=\"line\">       before(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           User.remove(&#123;&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span> &#123;</span></div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\"></div><div class=\"line\">       it(<span class=\"string\">'register sucessfully'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user/authenticate/register'</span>)</div><div class=\"line\">           .send(&#123;</div><div class=\"line\">               username: <span class=\"string\">'username'</span>,</div><div class=\"line\">               password: <span class=\"string\">'123456'</span></div><div class=\"line\">           &#125;)</div><div class=\"line\">           <span class=\"comment\">//注册成功之后重定向</span></div><div class=\"line\">           .expect(<span class=\"number\">302</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               should.not.<span class=\"built_in\">exists</span>(err);</div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\">       <span class=\"comment\">//测试用户名存在的用例</span></div><div class=\"line\">       it(<span class=\"string\">'username already exist'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user/authenticate/register'</span>)</div><div class=\"line\">           .send(&#123;</div><div class=\"line\">               username: <span class=\"string\">'username'</span>,</div><div class=\"line\">               password: <span class=\"string\">'123456'</span></div><div class=\"line\">           &#125;)</div><div class=\"line\">           .<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               should.not.<span class=\"built_in\">exists</span>(err);</div><div class=\"line\">               res.text.should.containEql(<span class=\"string\">'用户名已被使用'</span>);</div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\">   &#125;);</div><div class=\"line\">   <span class=\"comment\">// 测试头像上传</span></div><div class=\"line\">   describe(<span class=\"string\">'test user.updateAvator()'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> &#123;</span></div><div class=\"line\">       <span class=\"comment\">//bofore HOOKS，测试业务逻辑之前先登录，并持久化cookie</span></div><div class=\"line\">       before(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user'</span>)</div><div class=\"line\">           .send(&#123;</div><div class=\"line\">               username: <span class=\"string\">'username'</span>,</div><div class=\"line\">               password: <span class=\"string\">'123456'</span></div><div class=\"line\">           &#125;)</div><div class=\"line\">           .<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;);</div><div class=\"line\"></div><div class=\"line\">       it(<span class=\"string\">'update avator upload sucessfully'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(done)</span> &#123;</span></div><div class=\"line\">           request.post(<span class=\"string\">'/user/update/avator'</span>)</div><div class=\"line\">           .attach(<span class=\"string\">'avator'</span>,<span class=\"string\">'test/image/test.jpg'</span>)</div><div class=\"line\">           .<span class=\"keyword\">end</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err, res)</span> &#123;</span></div><div class=\"line\">               should.not.<span class=\"built_in\">exists</span>(err);</div><div class=\"line\">               res.text.should.containEql(<span class=\"string\">'\"</span>status<span class=\"string\">\":true'</span>);</div><div class=\"line\">               done();</div><div class=\"line\">           &#125;);</div><div class=\"line\">       &#125;); </div><div class=\"line\">   &#125;);</div></pre></td></tr></table></figure></p>"},{"title":"socket.io搭建多聊天室","date":"2016-01-05T14:41:23.000Z","_content":"\nhtml5新兴的API给前端开发者带来了难以抑制的兴奋，除了前端的API，html5还提供了一些有里程碑意义的前后端通信API，WebSocket就是这其中之一。WebSocket的目标是在一个单独的持久连接上提供全双工、双向通信。\n<!--more-->\n## WebSocket前世今生\nWebSocket是html5的一种新协议，在它出现之前，浏览器与服务器之间通过http只能实现单向的通信。在此之前，要实现浏览器之间的即时通信，一般采用Comet来模拟。Comet是一种服务器向页面推送消息的技术，这种技术可以让信息实时推送到页面，也算是可以比较完整地实现实时通信，但是效率低下。\n实现Comet的方式主要有两种，一种是轮询(polling)，一种是流。轮询，原理简单易懂，就是客户端通过一定的时间间隔以频繁请求的方式向服务器发送请求，来保持客户端和服务器端的数据同步。问题很明显，当客户端以固定频率向服务器端发送请求时，服务器端的数据可能并没有更新，带来很多无谓请求，浪费带宽，效率低下。第二种实现Comet的是HTTP流。流不同于轮询，它在页面的整个生命周期内只使用一个HTTP连接，通过服务器端语言的缓冲区刷新机制来将消息推送出去。\n除了Comet，通过Flash的API也是可以实现Socket的。AdobeFlash 通过自己的 Socket 实现完成数据交换，再利用 Flash 暴露出相应的接口为 JavaScript 调用，从而达到实时传输目的。此方式比轮询要高效，但是随着今年Flash正式宣告退出历史舞台，这种方式现在的存在意义不大。\n从上文可以看出，传统 Web 模式在处理高并发及实时性需求的时候，会遇到难以逾越的瓶颈，我们需要一种高效节能的双向通信机制来保证数据的实时传输。在此背景下，基于 HTML5 规范的、有 Web TCP 之称的 WebSocket 应运而生。\n![暴走](http://wanzao2.b0.upaiyun.com/system/pictures/11/original/28.png)\n## WebSocket的原理\nWebSocket 是一种双向通信协议，在建立连接后，WebSocket服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket一样。它类似TCP长连接，但是WebSocket使用的是ws和wss两种通信协议，所以这是完全不同于HTTP的一种网络协议，尽管它也是默认使用80和443端口。\nWebSocket的连接包括第一步握手和第二步数据交换。在通过WebSocket开始双向通信时，首先需要与服务器建立连接。而用于建立连接的请求是由客户端发起，服务器端将会确认连接对象的源以及协议，并发送连接许可的响应。在发送了响应之后，浏览器会将该连接升级为WebSocket。握手成功之后就建立起长连接，直到服务器或者浏览器某一方主动断开连接。客户端发起连接非常简单，只需要一句Javascript即可实现：\n```\nvar ws = new WebSocket('ws://www.example.com/bar')\n```\n然后就是第二步，浏览器和服务器之间双向数据发送了。Nodejs是即时通信应用很完美的开发语言（此处不是为了引起撕逼），很自然地，Nodejs本身也比较完善地实现了WebSocket相关API。客户端（浏览器）发送消息到服务器最简单的方法就是通过调用socket对象的send()方法，然后Node服务器通过注册message事件进行监听，当然服务器send过来的消息也是通过对客户端message事件进行捕捉，从而实现双向的数据交互。这两者之间交换的数据可以是字符串、ArrayBuffer（二进制数据）或者Blob，所以WebSocket也是可以传输文件的。也可以通过广播事件将消息发送到所有连接到服务器的客户端，也就是这篇文章要介绍的聊天室搭建的技术基础啦(尼玛终于到题目了)。\n![鸡冻](http://wanzao2.b0.upaiyun.com/system/pictures/19/original/45.png)\n\n## Socket.io开发聊天室\nSocket.io是基于Nodejs生态的，但是做Nodejs所不能实现的WebSocket的库。就像Express之于Nodejs、jQuery之于Javascript，Socket.io是对Node语言关于WebSocket所有API的封装和拓展，是一个应用框架。考虑到不同浏览器对WebSocket的支持程度不同，Socket.io通过支持多种协议（比如前面说的轮询）来实现良好的兼容，它会自动根据浏览器选择适合的通讯方式，从而让开发者可以聚焦到功能的实现而不是平台的兼容性。Socket.io[官方网站](http://socket.io/)里面也介绍了Socket.io的主要用途——包括实时数据分析应用、在线聊天、文档合作等等。这里主要是简单介绍一下如何使用Socket.io+Express去构建一个简单的在线聊天室。\n两个重要需求点：\n* 1、多个聊天室，根据url路径划分当前聊天室\n* 2、文本聊天\n\n### 第一步：搭建Express服务器\n首先生成Express应用，进入根目录下的server.js文件编辑服务器端。由于Express和socket.io都是安装了最新版本（分别是4.x和1.3.7），所以一些配置上面和Express 3.X还是不一样的，主要是注意一下配置server监听的时候要先创建一个由express对象（app）实例化的httpServer（server）对象，然后引入socket.io对这个对象进行监听，如下：\n```\nvar PORT = 80;\n...\nvar app = express();\nvar server = http.Server(app);\nvar io = require('socket.io').listen(server);\n...\n```\n最后server.js的端口监听要绑定在这个httpServer上面：\n```\n...\nif (!module.parent) {\n    // This server is socket server\n    server.listen(PORT);\n    log.info('Weiku started up');\n}\n···\n```\n\n### 第二步：实现服务器端的逻辑\n搭建完Express之后，就需要实现服务器的事件监听和响应了。继续对上面的server.js进行编辑。后台的所有事件注册应该建立在io对象的connection事件之上，也就是说需要在浏览器端已经开启，请求向服务器连接的基础上进行。最基本的事件包括消息事件message、断开事件disconnect，连接事件connection。由于这里需要根据路径划分聊天房间，需要进行命名空间划分。Socket.io提供.join(roomid)方法加入聊天室，.leave(roomid)方法离开聊天室，.to(roomid).emit(event)方法向roomid的所有连接用户的群发消息。首先需要划分路由，从而区分聊天室号：\n```\nio.on('connection', function (socket) {\n    // 获取用户当前的url，从而截取出房间id\n    var url = socket.request.headers.referer;\n    var split_arr = url.split('/');\n    var roomid = split_arr[split_arr.length-1] || 'index';\n    ...\n});\n```\n然后是对join、message和disconnect三个事件的监听：\n```\n...\n    var user = '';\n    socket.on('join', function (username) {\n         user = username;\n        // 将用户归类到房间\n        if (!roomUser[roomid]) {\n            roomUser[roomid] = [];\n        }\n        roomUser[roomid].push(user);\n        socket.join(roomid);\n        socket.to(roomid).emit('sys', user + '加入了房间');\n        socket.emit('sys',user + '加入了房间');\n    });\n\n    // 监听来自客户端的消息\n    socket.on('message', function (msg) {\n        // 验证如果用户不在房间内则不给发送\n        if (roomUser[roomid].indexOf(user)< 0) {  \n          return false;\n        }\n        socket.to(roomid).emit('new message', msg,user);\n        socket.emit('new message', msg,user);\n    });\n\n    // 关闭\n    socket.on('disconnect', function () {\n        // 从房间名单中移除\n        socket.leave(roomid, function (err) {\n            if (err) {\n                log.error(err);\n            } else {\n                var index = roomUser[roomid].indexOf(user);\n                if (index !== -1) {\n                    roomUser[roomid].splice(index, 1);\n                    socket.to(roomid).emit('sys',user+'退出了房间');\n                } \n            }\n        });\n    });\n```\n### 第三步：实现客户端交互\n客户端的消息收发主要是监听来自服务器emit的事件及其消息内容。由于socket.io通信事件是可以自定义的，所以前后端的事件监听必须对应好。为了方便，这里浏览器端的界面比较简单：一个消息展示窗口和一个文本输入框。当用户在输入框输入文本并敲回车键的时候，客户端调用socket.send()方法向服务器发送消息。浏览器接收到来自服务器的sys事件和new message事件之后，将消息内容显示在消息展示窗口。\nindex.ejs:\n```\n    <div>我的名字:<span class=\"name\"></span></div>\n    <div id=\"chat-area\" style=\"width:300px;height:400px;background-color:#eef;overflow-y:scroll\">\n        <div class=\"messages\">\n        </div>\n    </div>\n    <input type=\"text\" class=\"inputMessage\" placeholder=\"按回车键发送\" />\n   <script src=\"/socket.io/socket.io.js\"></script>\n   <script src=\"/js/jquery.min.js\"></script>\n   <script src=\"/js/chat.js\"></script>\n```\nindex界面主要引入三个js文件，其中socket.io.js的路径大家可能觉得不可思议，明明项目中并没有“/socket.io”这个路径。这是由于socket.io安装完毕之后自动完成了这个路径的映射，所以我们是不用管这个的，照写就可以了。chat.js主要负责客户端和服务器的事件通信,它通过 var socket = io() 创建浏览器端的socket.io对象。\nchat.js:\n```\n$(function () {\n    var username =  prompt('请输入昵称');\n    $('.name').html(username)\n    var input = $('.inputMessage');\n    // 默认链接到渲染页面的服务器\n    var socket = io();\n    function scrollToBottom () {\n        $('#chat-area').scrollTop($('#chat-area')[0].scrollHeight);\n    };\n\n    socket.on('connect', function () {\n        var name = $('.name').text() ||'匿名';\n        socket.emit('join',name);\n    })\n    socket.on('sys', function (msg) {\n        $('.messages').append('<p>'+msg+'</p>');\n        // 滚动条滚动到底部\n        scrollToBottom();\n    });\n    socket.on('new message', function (msg,user) {\n        $('.messages').append('<p>'+user+'说：'+msg+'</p>');\n        // 滚动条滚动到底部\n        scrollToBottom();\n    });\n    input.on('keydown',function (e) {\n        if (e.which === 13) {\n            //判断回车键\n            var message = $(this).val();\n            if (!message) {\n                return ;\n            }\n            socket.send(message);\n            $(this).val('');\n        }\n    });\n});\n```\n到这里，一个简单的多聊天室应用就完成了，由于在Express的Router设置了访问路径:\n```\nrouter.get('/room/:id', function(req, res, next) {\n  res.render('index');\n});\n```\n安装完毕应用，执行server.js开启服务器之后，打开浏览器访问 localhost:8080/room/1 就可以访问房间号为1的聊天室了。然后呢，鉴于...\n![demo](http://i4.tietuku.com/d121eb715f0f6654s.png)\n业界良心，还是要附上全部的[demo](https://github.com/hugzh/chatroom-demo)代码的。\n\n当然，你还可以根据自己的情况把demo拓展得更完善一些，比如加点好看的css，实现用户登录等等。如果需要实现登录功能，服务器socket应该添加对session读写的支持。由于socket.io本身是不支持session的，需要引入第三方模块比如 socket.io-express-session ，来实现用户状态认证：\n```\nif (socket.handshake.session.passport) {    \n    user.username = socket.handshake.session.passport.user;\n}\n```\n\n## 结尾\n到此，一个简单的socket.io应用就完成了，这篇文章主要是解决Express4.x和socket.io1.3.x配置的时候需要调整的一些写法，不注意的话很容易各种瞎折腾。另外，本文demo部分参考了吴彦欣老师的一个[demo](https://github.com/wuyanxin/chatapp-demo)，感谢分享。\n\n\n","source":"_posts/socket.io搭建多聊天室.md","raw":"title: socket.io搭建多聊天室\ndate: 2016-01-05 22:41:23\ntags:\n    - node\n    - 网络\ncategories:\n    - Nodejs\n---\n\nhtml5新兴的API给前端开发者带来了难以抑制的兴奋，除了前端的API，html5还提供了一些有里程碑意义的前后端通信API，WebSocket就是这其中之一。WebSocket的目标是在一个单独的持久连接上提供全双工、双向通信。\n<!--more-->\n## WebSocket前世今生\nWebSocket是html5的一种新协议，在它出现之前，浏览器与服务器之间通过http只能实现单向的通信。在此之前，要实现浏览器之间的即时通信，一般采用Comet来模拟。Comet是一种服务器向页面推送消息的技术，这种技术可以让信息实时推送到页面，也算是可以比较完整地实现实时通信，但是效率低下。\n实现Comet的方式主要有两种，一种是轮询(polling)，一种是流。轮询，原理简单易懂，就是客户端通过一定的时间间隔以频繁请求的方式向服务器发送请求，来保持客户端和服务器端的数据同步。问题很明显，当客户端以固定频率向服务器端发送请求时，服务器端的数据可能并没有更新，带来很多无谓请求，浪费带宽，效率低下。第二种实现Comet的是HTTP流。流不同于轮询，它在页面的整个生命周期内只使用一个HTTP连接，通过服务器端语言的缓冲区刷新机制来将消息推送出去。\n除了Comet，通过Flash的API也是可以实现Socket的。AdobeFlash 通过自己的 Socket 实现完成数据交换，再利用 Flash 暴露出相应的接口为 JavaScript 调用，从而达到实时传输目的。此方式比轮询要高效，但是随着今年Flash正式宣告退出历史舞台，这种方式现在的存在意义不大。\n从上文可以看出，传统 Web 模式在处理高并发及实时性需求的时候，会遇到难以逾越的瓶颈，我们需要一种高效节能的双向通信机制来保证数据的实时传输。在此背景下，基于 HTML5 规范的、有 Web TCP 之称的 WebSocket 应运而生。\n![暴走](http://wanzao2.b0.upaiyun.com/system/pictures/11/original/28.png)\n## WebSocket的原理\nWebSocket 是一种双向通信协议，在建立连接后，WebSocket服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket一样。它类似TCP长连接，但是WebSocket使用的是ws和wss两种通信协议，所以这是完全不同于HTTP的一种网络协议，尽管它也是默认使用80和443端口。\nWebSocket的连接包括第一步握手和第二步数据交换。在通过WebSocket开始双向通信时，首先需要与服务器建立连接。而用于建立连接的请求是由客户端发起，服务器端将会确认连接对象的源以及协议，并发送连接许可的响应。在发送了响应之后，浏览器会将该连接升级为WebSocket。握手成功之后就建立起长连接，直到服务器或者浏览器某一方主动断开连接。客户端发起连接非常简单，只需要一句Javascript即可实现：\n```\nvar ws = new WebSocket('ws://www.example.com/bar')\n```\n然后就是第二步，浏览器和服务器之间双向数据发送了。Nodejs是即时通信应用很完美的开发语言（此处不是为了引起撕逼），很自然地，Nodejs本身也比较完善地实现了WebSocket相关API。客户端（浏览器）发送消息到服务器最简单的方法就是通过调用socket对象的send()方法，然后Node服务器通过注册message事件进行监听，当然服务器send过来的消息也是通过对客户端message事件进行捕捉，从而实现双向的数据交互。这两者之间交换的数据可以是字符串、ArrayBuffer（二进制数据）或者Blob，所以WebSocket也是可以传输文件的。也可以通过广播事件将消息发送到所有连接到服务器的客户端，也就是这篇文章要介绍的聊天室搭建的技术基础啦(尼玛终于到题目了)。\n![鸡冻](http://wanzao2.b0.upaiyun.com/system/pictures/19/original/45.png)\n\n## Socket.io开发聊天室\nSocket.io是基于Nodejs生态的，但是做Nodejs所不能实现的WebSocket的库。就像Express之于Nodejs、jQuery之于Javascript，Socket.io是对Node语言关于WebSocket所有API的封装和拓展，是一个应用框架。考虑到不同浏览器对WebSocket的支持程度不同，Socket.io通过支持多种协议（比如前面说的轮询）来实现良好的兼容，它会自动根据浏览器选择适合的通讯方式，从而让开发者可以聚焦到功能的实现而不是平台的兼容性。Socket.io[官方网站](http://socket.io/)里面也介绍了Socket.io的主要用途——包括实时数据分析应用、在线聊天、文档合作等等。这里主要是简单介绍一下如何使用Socket.io+Express去构建一个简单的在线聊天室。\n两个重要需求点：\n* 1、多个聊天室，根据url路径划分当前聊天室\n* 2、文本聊天\n\n### 第一步：搭建Express服务器\n首先生成Express应用，进入根目录下的server.js文件编辑服务器端。由于Express和socket.io都是安装了最新版本（分别是4.x和1.3.7），所以一些配置上面和Express 3.X还是不一样的，主要是注意一下配置server监听的时候要先创建一个由express对象（app）实例化的httpServer（server）对象，然后引入socket.io对这个对象进行监听，如下：\n```\nvar PORT = 80;\n...\nvar app = express();\nvar server = http.Server(app);\nvar io = require('socket.io').listen(server);\n...\n```\n最后server.js的端口监听要绑定在这个httpServer上面：\n```\n...\nif (!module.parent) {\n    // This server is socket server\n    server.listen(PORT);\n    log.info('Weiku started up');\n}\n···\n```\n\n### 第二步：实现服务器端的逻辑\n搭建完Express之后，就需要实现服务器的事件监听和响应了。继续对上面的server.js进行编辑。后台的所有事件注册应该建立在io对象的connection事件之上，也就是说需要在浏览器端已经开启，请求向服务器连接的基础上进行。最基本的事件包括消息事件message、断开事件disconnect，连接事件connection。由于这里需要根据路径划分聊天房间，需要进行命名空间划分。Socket.io提供.join(roomid)方法加入聊天室，.leave(roomid)方法离开聊天室，.to(roomid).emit(event)方法向roomid的所有连接用户的群发消息。首先需要划分路由，从而区分聊天室号：\n```\nio.on('connection', function (socket) {\n    // 获取用户当前的url，从而截取出房间id\n    var url = socket.request.headers.referer;\n    var split_arr = url.split('/');\n    var roomid = split_arr[split_arr.length-1] || 'index';\n    ...\n});\n```\n然后是对join、message和disconnect三个事件的监听：\n```\n...\n    var user = '';\n    socket.on('join', function (username) {\n         user = username;\n        // 将用户归类到房间\n        if (!roomUser[roomid]) {\n            roomUser[roomid] = [];\n        }\n        roomUser[roomid].push(user);\n        socket.join(roomid);\n        socket.to(roomid).emit('sys', user + '加入了房间');\n        socket.emit('sys',user + '加入了房间');\n    });\n\n    // 监听来自客户端的消息\n    socket.on('message', function (msg) {\n        // 验证如果用户不在房间内则不给发送\n        if (roomUser[roomid].indexOf(user)< 0) {  \n          return false;\n        }\n        socket.to(roomid).emit('new message', msg,user);\n        socket.emit('new message', msg,user);\n    });\n\n    // 关闭\n    socket.on('disconnect', function () {\n        // 从房间名单中移除\n        socket.leave(roomid, function (err) {\n            if (err) {\n                log.error(err);\n            } else {\n                var index = roomUser[roomid].indexOf(user);\n                if (index !== -1) {\n                    roomUser[roomid].splice(index, 1);\n                    socket.to(roomid).emit('sys',user+'退出了房间');\n                } \n            }\n        });\n    });\n```\n### 第三步：实现客户端交互\n客户端的消息收发主要是监听来自服务器emit的事件及其消息内容。由于socket.io通信事件是可以自定义的，所以前后端的事件监听必须对应好。为了方便，这里浏览器端的界面比较简单：一个消息展示窗口和一个文本输入框。当用户在输入框输入文本并敲回车键的时候，客户端调用socket.send()方法向服务器发送消息。浏览器接收到来自服务器的sys事件和new message事件之后，将消息内容显示在消息展示窗口。\nindex.ejs:\n```\n    <div>我的名字:<span class=\"name\"></span></div>\n    <div id=\"chat-area\" style=\"width:300px;height:400px;background-color:#eef;overflow-y:scroll\">\n        <div class=\"messages\">\n        </div>\n    </div>\n    <input type=\"text\" class=\"inputMessage\" placeholder=\"按回车键发送\" />\n   <script src=\"/socket.io/socket.io.js\"></script>\n   <script src=\"/js/jquery.min.js\"></script>\n   <script src=\"/js/chat.js\"></script>\n```\nindex界面主要引入三个js文件，其中socket.io.js的路径大家可能觉得不可思议，明明项目中并没有“/socket.io”这个路径。这是由于socket.io安装完毕之后自动完成了这个路径的映射，所以我们是不用管这个的，照写就可以了。chat.js主要负责客户端和服务器的事件通信,它通过 var socket = io() 创建浏览器端的socket.io对象。\nchat.js:\n```\n$(function () {\n    var username =  prompt('请输入昵称');\n    $('.name').html(username)\n    var input = $('.inputMessage');\n    // 默认链接到渲染页面的服务器\n    var socket = io();\n    function scrollToBottom () {\n        $('#chat-area').scrollTop($('#chat-area')[0].scrollHeight);\n    };\n\n    socket.on('connect', function () {\n        var name = $('.name').text() ||'匿名';\n        socket.emit('join',name);\n    })\n    socket.on('sys', function (msg) {\n        $('.messages').append('<p>'+msg+'</p>');\n        // 滚动条滚动到底部\n        scrollToBottom();\n    });\n    socket.on('new message', function (msg,user) {\n        $('.messages').append('<p>'+user+'说：'+msg+'</p>');\n        // 滚动条滚动到底部\n        scrollToBottom();\n    });\n    input.on('keydown',function (e) {\n        if (e.which === 13) {\n            //判断回车键\n            var message = $(this).val();\n            if (!message) {\n                return ;\n            }\n            socket.send(message);\n            $(this).val('');\n        }\n    });\n});\n```\n到这里，一个简单的多聊天室应用就完成了，由于在Express的Router设置了访问路径:\n```\nrouter.get('/room/:id', function(req, res, next) {\n  res.render('index');\n});\n```\n安装完毕应用，执行server.js开启服务器之后，打开浏览器访问 localhost:8080/room/1 就可以访问房间号为1的聊天室了。然后呢，鉴于...\n![demo](http://i4.tietuku.com/d121eb715f0f6654s.png)\n业界良心，还是要附上全部的[demo](https://github.com/hugzh/chatroom-demo)代码的。\n\n当然，你还可以根据自己的情况把demo拓展得更完善一些，比如加点好看的css，实现用户登录等等。如果需要实现登录功能，服务器socket应该添加对session读写的支持。由于socket.io本身是不支持session的，需要引入第三方模块比如 socket.io-express-session ，来实现用户状态认证：\n```\nif (socket.handshake.session.passport) {    \n    user.username = socket.handshake.session.passport.user;\n}\n```\n\n## 结尾\n到此，一个简单的socket.io应用就完成了，这篇文章主要是解决Express4.x和socket.io1.3.x配置的时候需要调整的一些写法，不注意的话很容易各种瞎折腾。另外，本文demo部分参考了吴彦欣老师的一个[demo](https://github.com/wuyanxin/chatapp-demo)，感谢分享。\n\n\n","slug":"socket.io搭建多聊天室","published":1,"updated":"2016-08-13T03:08:44.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtru00297kauceumrmoj","content":"<p>html5新兴的API给前端开发者带来了难以抑制的兴奋，除了前端的API，html5还提供了一些有里程碑意义的前后端通信API，WebSocket就是这其中之一。WebSocket的目标是在一个单独的持久连接上提供全双工、双向通信。<br><a id=\"more\"></a></p>\n<h2 id=\"WebSocket前世今生\"><a href=\"#WebSocket前世今生\" class=\"headerlink\" title=\"WebSocket前世今生\"></a>WebSocket前世今生</h2><p>WebSocket是html5的一种新协议，在它出现之前，浏览器与服务器之间通过http只能实现单向的通信。在此之前，要实现浏览器之间的即时通信，一般采用Comet来模拟。Comet是一种服务器向页面推送消息的技术，这种技术可以让信息实时推送到页面，也算是可以比较完整地实现实时通信，但是效率低下。<br>实现Comet的方式主要有两种，一种是轮询(polling)，一种是流。轮询，原理简单易懂，就是客户端通过一定的时间间隔以频繁请求的方式向服务器发送请求，来保持客户端和服务器端的数据同步。问题很明显，当客户端以固定频率向服务器端发送请求时，服务器端的数据可能并没有更新，带来很多无谓请求，浪费带宽，效率低下。第二种实现Comet的是HTTP流。流不同于轮询，它在页面的整个生命周期内只使用一个HTTP连接，通过服务器端语言的缓冲区刷新机制来将消息推送出去。<br>除了Comet，通过Flash的API也是可以实现Socket的。AdobeFlash 通过自己的 Socket 实现完成数据交换，再利用 Flash 暴露出相应的接口为 JavaScript 调用，从而达到实时传输目的。此方式比轮询要高效，但是随着今年Flash正式宣告退出历史舞台，这种方式现在的存在意义不大。<br>从上文可以看出，传统 Web 模式在处理高并发及实时性需求的时候，会遇到难以逾越的瓶颈，我们需要一种高效节能的双向通信机制来保证数据的实时传输。在此背景下，基于 HTML5 规范的、有 Web TCP 之称的 WebSocket 应运而生。<br><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/11/original/28.png\" alt=\"暴走\"></p>\n<h2 id=\"WebSocket的原理\"><a href=\"#WebSocket的原理\" class=\"headerlink\" title=\"WebSocket的原理\"></a>WebSocket的原理</h2><p>WebSocket 是一种双向通信协议，在建立连接后，WebSocket服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket一样。它类似TCP长连接，但是WebSocket使用的是ws和wss两种通信协议，所以这是完全不同于HTTP的一种网络协议，尽管它也是默认使用80和443端口。<br>WebSocket的连接包括第一步握手和第二步数据交换。在通过WebSocket开始双向通信时，首先需要与服务器建立连接。而用于建立连接的请求是由客户端发起，服务器端将会确认连接对象的源以及协议，并发送连接许可的响应。在发送了响应之后，浏览器会将该连接升级为WebSocket。握手成功之后就建立起长连接，直到服务器或者浏览器某一方主动断开连接。客户端发起连接非常简单，只需要一句Javascript即可实现：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"type\">WebSocket</span>(<span class=\"symbol\">'ws</span>:<span class=\"comment\">//www.example.com/bar')</span></div></pre></td></tr></table></figure></p>\n<p>然后就是第二步，浏览器和服务器之间双向数据发送了。Nodejs是即时通信应用很完美的开发语言（此处不是为了引起撕逼），很自然地，Nodejs本身也比较完善地实现了WebSocket相关API。客户端（浏览器）发送消息到服务器最简单的方法就是通过调用socket对象的send()方法，然后Node服务器通过注册message事件进行监听，当然服务器send过来的消息也是通过对客户端message事件进行捕捉，从而实现双向的数据交互。这两者之间交换的数据可以是字符串、ArrayBuffer（二进制数据）或者Blob，所以WebSocket也是可以传输文件的。也可以通过广播事件将消息发送到所有连接到服务器的客户端，也就是这篇文章要介绍的聊天室搭建的技术基础啦(尼玛终于到题目了)。<br><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/19/original/45.png\" alt=\"鸡冻\"></p>\n<h2 id=\"Socket-io开发聊天室\"><a href=\"#Socket-io开发聊天室\" class=\"headerlink\" title=\"Socket.io开发聊天室\"></a>Socket.io开发聊天室</h2><p>Socket.io是基于Nodejs生态的，但是做Nodejs所不能实现的WebSocket的库。就像Express之于Nodejs、jQuery之于Javascript，Socket.io是对Node语言关于WebSocket所有API的封装和拓展，是一个应用框架。考虑到不同浏览器对WebSocket的支持程度不同，Socket.io通过支持多种协议（比如前面说的轮询）来实现良好的兼容，它会自动根据浏览器选择适合的通讯方式，从而让开发者可以聚焦到功能的实现而不是平台的兼容性。Socket.io<a href=\"http://socket.io/\" target=\"_blank\" rel=\"external\">官方网站</a>里面也介绍了Socket.io的主要用途——包括实时数据分析应用、在线聊天、文档合作等等。这里主要是简单介绍一下如何使用Socket.io+Express去构建一个简单的在线聊天室。<br>两个重要需求点：</p>\n<ul>\n<li>1、多个聊天室，根据url路径划分当前聊天室</li>\n<li>2、文本聊天</li>\n</ul>\n<h3 id=\"第一步：搭建Express服务器\"><a href=\"#第一步：搭建Express服务器\" class=\"headerlink\" title=\"第一步：搭建Express服务器\"></a>第一步：搭建Express服务器</h3><p>首先生成Express应用，进入根目录下的server.js文件编辑服务器端。由于Express和socket.io都是安装了最新版本（分别是4.x和1.3.7），所以一些配置上面和Express 3.X还是不一样的，主要是注意一下配置server监听的时候要先创建一个由express对象（app）实例化的httpServer（server）对象，然后引入socket.io对这个对象进行监听，如下：<br><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">var</span> PORT = <span class=\"number\">80</span>;</div><div class=\"line\"><span class=\"params\">...</span></div><div class=\"line\"><span class=\"built_in\">var</span> app = express();</div><div class=\"line\"><span class=\"built_in\">var</span> server = http.Server(app);</div><div class=\"line\"><span class=\"built_in\">var</span> io = <span class=\"keyword\">require</span>(<span class=\"string\">'socket.io'</span>).listen(server);</div><div class=\"line\"><span class=\"params\">...</span></div></pre></td></tr></table></figure></p>\n<p>最后server.js的端口监听要绑定在这个httpServer上面：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"><span class=\"selector-tag\">if</span> (!module.parent) &#123;</div><div class=\"line\">    <span class=\"comment\">// This server is socket server</span></div><div class=\"line\">    server<span class=\"selector-class\">.listen</span>(PORT);</div><div class=\"line\">    log<span class=\"selector-class\">.info</span>(<span class=\"string\">'Weiku started up'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">···</div></pre></td></tr></table></figure></p>\n<h3 id=\"第二步：实现服务器端的逻辑\"><a href=\"#第二步：实现服务器端的逻辑\" class=\"headerlink\" title=\"第二步：实现服务器端的逻辑\"></a>第二步：实现服务器端的逻辑</h3><p>搭建完Express之后，就需要实现服务器的事件监听和响应了。继续对上面的server.js进行编辑。后台的所有事件注册应该建立在io对象的connection事件之上，也就是说需要在浏览器端已经开启，请求向服务器连接的基础上进行。最基本的事件包括消息事件message、断开事件disconnect，连接事件connection。由于这里需要根据路径划分聊天房间，需要进行命名空间划分。Socket.io提供.join(roomid)方法加入聊天室，.leave(roomid)方法离开聊天室，.to(roomid).emit(event)方法向roomid的所有连接用户的群发消息。首先需要划分路由，从而区分聊天室号：<br><figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 获取用户当前的url，从而截取出房间id</span></div><div class=\"line\">    <span class=\"built_in\">var</span> <span class=\"built_in\">url</span> = socket.request.headers.referer;</div><div class=\"line\">    <span class=\"built_in\">var</span> split_arr = <span class=\"built_in\">url</span>.split(<span class=\"string\">'/'</span>);</div><div class=\"line\">    <span class=\"built_in\">var</span> roomid = split_arr[split_arr.length<span class=\"number\">-1</span>] || <span class=\"string\">'index'</span>;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>然后是对join、message和disconnect三个事件的监听：<br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">    <span class=\"keyword\">var</span> user = <span class=\"string\">''</span>;</div><div class=\"line\">    socket.on(<span class=\"string\">'join'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(username)</span> </span>&#123;</div><div class=\"line\">         user = username;</div><div class=\"line\">        <span class=\"comment\">// 将用户归类到房间</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (!roomUser[roomid]) &#123;</div><div class=\"line\">            roomUser[roomid] = [];</div><div class=\"line\">        &#125;</div><div class=\"line\">        roomUser[roomid].push(user);</div><div class=\"line\">        socket.join(roomid);</div><div class=\"line\">        socket.to(roomid).emit(<span class=\"string\">'sys'</span>, user + <span class=\"string\">'加入了房间'</span>);</div><div class=\"line\">        socket.emit(<span class=\"string\">'sys'</span>,user + <span class=\"string\">'加入了房间'</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 监听来自客户端的消息</span></div><div class=\"line\">    socket.on(<span class=\"string\">'message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(msg)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 验证如果用户不在房间内则不给发送</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (roomUser[roomid].indexOf(user)&lt; <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        socket.to(roomid).emit(<span class=\"string\">'new message'</span>, msg,user);</div><div class=\"line\">        socket.emit(<span class=\"string\">'new message'</span>, msg,user);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 关闭</span></div><div class=\"line\">    socket.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 从房间名单中移除</span></div><div class=\"line\">        socket.leave(roomid, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                log.error(err);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">var</span> index = roomUser[roomid].indexOf(user);</div><div class=\"line\">                <span class=\"keyword\">if</span> (index !== <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">                    roomUser[roomid].splice(index, <span class=\"number\">1</span>);</div><div class=\"line\">                    socket.to(roomid).emit(<span class=\"string\">'sys'</span>,user+<span class=\"string\">'退出了房间'</span>);</div><div class=\"line\">                &#125; </div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"第三步：实现客户端交互\"><a href=\"#第三步：实现客户端交互\" class=\"headerlink\" title=\"第三步：实现客户端交互\"></a>第三步：实现客户端交互</h3><p>客户端的消息收发主要是监听来自服务器emit的事件及其消息内容。由于socket.io通信事件是可以自定义的，所以前后端的事件监听必须对应好。为了方便，这里浏览器端的界面比较简单：一个消息展示窗口和一个文本输入框。当用户在输入框输入文本并敲回车键的时候，客户端调用socket.send()方法向服务器发送消息。浏览器接收到来自服务器的sys事件和new message事件之后，将消息内容显示在消息展示窗口。<br>index.ejs:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>我的名字:<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"chat-area\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width:300px;height:400px;background-color:#eef;overflow-y:scroll\"</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"messages\"</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inputMessage\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"按回车键发送\"</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/socket.io/socket.io.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/js/jquery.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/js/chat.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>index界面主要引入三个js文件，其中socket.io.js的路径大家可能觉得不可思议，明明项目中并没有“/socket.io”这个路径。这是由于socket.io安装完毕之后自动完成了这个路径的映射，所以我们是不用管这个的，照写就可以了。chat.js主要负责客户端和服务器的事件通信,它通过 var socket = io() 创建浏览器端的socket.io对象。<br>chat.js:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> username =  prompt(<span class=\"string\">'请输入昵称'</span>);</div><div class=\"line\">    $(<span class=\"string\">'.name'</span>).html(username)</div><div class=\"line\">    <span class=\"keyword\">var</span> input = $(<span class=\"string\">'.inputMessage'</span>);</div><div class=\"line\">    <span class=\"comment\">// 默认链接到渲染页面的服务器</span></div><div class=\"line\">    <span class=\"keyword\">var</span> socket = io();</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scrollToBottom</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        $(<span class=\"string\">'#chat-area'</span>).scrollTop($(<span class=\"string\">'#chat-area'</span>)[<span class=\"number\">0</span>].scrollHeight);</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    socket.on(<span class=\"string\">'connect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> name = $(<span class=\"string\">'.name'</span>).text() ||<span class=\"string\">'匿名'</span>;</div><div class=\"line\">        socket.emit(<span class=\"string\">'join'</span>,name);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    socket.on(<span class=\"string\">'sys'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</div><div class=\"line\">        $(<span class=\"string\">'.messages'</span>).append(<span class=\"string\">'&lt;p&gt;'</span>+msg+<span class=\"string\">'&lt;/p&gt;'</span>);</div><div class=\"line\">        <span class=\"comment\">// 滚动条滚动到底部</span></div><div class=\"line\">        scrollToBottom();</div><div class=\"line\">    &#125;);</div><div class=\"line\">    socket.on(<span class=\"string\">'new message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg,user</span>) </span>&#123;</div><div class=\"line\">        $(<span class=\"string\">'.messages'</span>).append(<span class=\"string\">'&lt;p&gt;'</span>+user+<span class=\"string\">'说：'</span>+msg+<span class=\"string\">'&lt;/p&gt;'</span>);</div><div class=\"line\">        <span class=\"comment\">// 滚动条滚动到底部</span></div><div class=\"line\">        scrollToBottom();</div><div class=\"line\">    &#125;);</div><div class=\"line\">    input.on(<span class=\"string\">'keydown'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (e.which === <span class=\"number\">13</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//判断回车键</span></div><div class=\"line\">            <span class=\"keyword\">var</span> message = $(<span class=\"keyword\">this</span>).val();</div><div class=\"line\">            <span class=\"keyword\">if</span> (!message) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> ;</div><div class=\"line\">            &#125;</div><div class=\"line\">            socket.send(message);</div><div class=\"line\">            $(<span class=\"keyword\">this</span>).val(<span class=\"string\">''</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>到这里，一个简单的多聊天室应用就完成了，由于在Express的Router设置了访问路径:<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">router</span><span class=\"selector-class\">.get</span>(<span class=\"string\">'/room/:id'</span>, function(req, res, next) &#123;</div><div class=\"line\">  res<span class=\"selector-class\">.render</span>(<span class=\"string\">'index'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>安装完毕应用，执行server.js开启服务器之后，打开浏览器访问 localhost:8080/room/1 就可以访问房间号为1的聊天室了。然后呢，鉴于…<br><img src=\"http://i4.tietuku.com/d121eb715f0f6654s.png\" alt=\"demo\"><br>业界良心，还是要附上全部的<a href=\"https://github.com/hugzh/chatroom-demo\" target=\"_blank\" rel=\"external\">demo</a>代码的。</p>\n<p>当然，你还可以根据自己的情况把demo拓展得更完善一些，比如加点好看的css，实现用户登录等等。如果需要实现登录功能，服务器socket应该添加对session读写的支持。由于socket.io本身是不支持session的，需要引入第三方模块比如 socket.io-express-session ，来实现用户状态认证：<br><figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">socket</span>.handshake.session.passport) &#123;    </div><div class=\"line\">    user.username = <span class=\"keyword\">socket</span>.handshake.session.passport.user;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>到此，一个简单的socket.io应用就完成了，这篇文章主要是解决Express4.x和socket.io1.3.x配置的时候需要调整的一些写法，不注意的话很容易各种瞎折腾。另外，本文demo部分参考了吴彦欣老师的一个<a href=\"https://github.com/wuyanxin/chatapp-demo\" target=\"_blank\" rel=\"external\">demo</a>，感谢分享。</p>\n","excerpt":"<p>html5新兴的API给前端开发者带来了难以抑制的兴奋，除了前端的API，html5还提供了一些有里程碑意义的前后端通信API，WebSocket就是这其中之一。WebSocket的目标是在一个单独的持久连接上提供全双工、双向通信。<br>","more":"</p>\n<h2 id=\"WebSocket前世今生\"><a href=\"#WebSocket前世今生\" class=\"headerlink\" title=\"WebSocket前世今生\"></a>WebSocket前世今生</h2><p>WebSocket是html5的一种新协议，在它出现之前，浏览器与服务器之间通过http只能实现单向的通信。在此之前，要实现浏览器之间的即时通信，一般采用Comet来模拟。Comet是一种服务器向页面推送消息的技术，这种技术可以让信息实时推送到页面，也算是可以比较完整地实现实时通信，但是效率低下。<br>实现Comet的方式主要有两种，一种是轮询(polling)，一种是流。轮询，原理简单易懂，就是客户端通过一定的时间间隔以频繁请求的方式向服务器发送请求，来保持客户端和服务器端的数据同步。问题很明显，当客户端以固定频率向服务器端发送请求时，服务器端的数据可能并没有更新，带来很多无谓请求，浪费带宽，效率低下。第二种实现Comet的是HTTP流。流不同于轮询，它在页面的整个生命周期内只使用一个HTTP连接，通过服务器端语言的缓冲区刷新机制来将消息推送出去。<br>除了Comet，通过Flash的API也是可以实现Socket的。AdobeFlash 通过自己的 Socket 实现完成数据交换，再利用 Flash 暴露出相应的接口为 JavaScript 调用，从而达到实时传输目的。此方式比轮询要高效，但是随着今年Flash正式宣告退出历史舞台，这种方式现在的存在意义不大。<br>从上文可以看出，传统 Web 模式在处理高并发及实时性需求的时候，会遇到难以逾越的瓶颈，我们需要一种高效节能的双向通信机制来保证数据的实时传输。在此背景下，基于 HTML5 规范的、有 Web TCP 之称的 WebSocket 应运而生。<br><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/11/original/28.png\" alt=\"暴走\"></p>\n<h2 id=\"WebSocket的原理\"><a href=\"#WebSocket的原理\" class=\"headerlink\" title=\"WebSocket的原理\"></a>WebSocket的原理</h2><p>WebSocket 是一种双向通信协议，在建立连接后，WebSocket服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket一样。它类似TCP长连接，但是WebSocket使用的是ws和wss两种通信协议，所以这是完全不同于HTTP的一种网络协议，尽管它也是默认使用80和443端口。<br>WebSocket的连接包括第一步握手和第二步数据交换。在通过WebSocket开始双向通信时，首先需要与服务器建立连接。而用于建立连接的请求是由客户端发起，服务器端将会确认连接对象的源以及协议，并发送连接许可的响应。在发送了响应之后，浏览器会将该连接升级为WebSocket。握手成功之后就建立起长连接，直到服务器或者浏览器某一方主动断开连接。客户端发起连接非常简单，只需要一句Javascript即可实现：<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"type\">WebSocket</span>(<span class=\"symbol\">'ws</span>:<span class=\"comment\">//www.example.com/bar')</span></div></pre></td></tr></table></figure></p>\n<p>然后就是第二步，浏览器和服务器之间双向数据发送了。Nodejs是即时通信应用很完美的开发语言（此处不是为了引起撕逼），很自然地，Nodejs本身也比较完善地实现了WebSocket相关API。客户端（浏览器）发送消息到服务器最简单的方法就是通过调用socket对象的send()方法，然后Node服务器通过注册message事件进行监听，当然服务器send过来的消息也是通过对客户端message事件进行捕捉，从而实现双向的数据交互。这两者之间交换的数据可以是字符串、ArrayBuffer（二进制数据）或者Blob，所以WebSocket也是可以传输文件的。也可以通过广播事件将消息发送到所有连接到服务器的客户端，也就是这篇文章要介绍的聊天室搭建的技术基础啦(尼玛终于到题目了)。<br><img src=\"http://wanzao2.b0.upaiyun.com/system/pictures/19/original/45.png\" alt=\"鸡冻\"></p>\n<h2 id=\"Socket-io开发聊天室\"><a href=\"#Socket-io开发聊天室\" class=\"headerlink\" title=\"Socket.io开发聊天室\"></a>Socket.io开发聊天室</h2><p>Socket.io是基于Nodejs生态的，但是做Nodejs所不能实现的WebSocket的库。就像Express之于Nodejs、jQuery之于Javascript，Socket.io是对Node语言关于WebSocket所有API的封装和拓展，是一个应用框架。考虑到不同浏览器对WebSocket的支持程度不同，Socket.io通过支持多种协议（比如前面说的轮询）来实现良好的兼容，它会自动根据浏览器选择适合的通讯方式，从而让开发者可以聚焦到功能的实现而不是平台的兼容性。Socket.io<a href=\"http://socket.io/\">官方网站</a>里面也介绍了Socket.io的主要用途——包括实时数据分析应用、在线聊天、文档合作等等。这里主要是简单介绍一下如何使用Socket.io+Express去构建一个简单的在线聊天室。<br>两个重要需求点：</p>\n<ul>\n<li>1、多个聊天室，根据url路径划分当前聊天室</li>\n<li>2、文本聊天</li>\n</ul>\n<h3 id=\"第一步：搭建Express服务器\"><a href=\"#第一步：搭建Express服务器\" class=\"headerlink\" title=\"第一步：搭建Express服务器\"></a>第一步：搭建Express服务器</h3><p>首先生成Express应用，进入根目录下的server.js文件编辑服务器端。由于Express和socket.io都是安装了最新版本（分别是4.x和1.3.7），所以一些配置上面和Express 3.X还是不一样的，主要是注意一下配置server监听的时候要先创建一个由express对象（app）实例化的httpServer（server）对象，然后引入socket.io对这个对象进行监听，如下：<br><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">var</span> PORT = <span class=\"number\">80</span>;</div><div class=\"line\"><span class=\"params\">...</span></div><div class=\"line\"><span class=\"built_in\">var</span> app = express();</div><div class=\"line\"><span class=\"built_in\">var</span> server = http.Server(app);</div><div class=\"line\"><span class=\"built_in\">var</span> io = <span class=\"keyword\">require</span>(<span class=\"string\">'socket.io'</span>).listen(server);</div><div class=\"line\"><span class=\"params\">...</span></div></pre></td></tr></table></figure></p>\n<p>最后server.js的端口监听要绑定在这个httpServer上面：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"><span class=\"selector-tag\">if</span> (!module.parent) &#123;</div><div class=\"line\">    <span class=\"comment\">// This server is socket server</span></div><div class=\"line\">    server<span class=\"selector-class\">.listen</span>(PORT);</div><div class=\"line\">    log<span class=\"selector-class\">.info</span>(<span class=\"string\">'Weiku started up'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">···</div></pre></td></tr></table></figure></p>\n<h3 id=\"第二步：实现服务器端的逻辑\"><a href=\"#第二步：实现服务器端的逻辑\" class=\"headerlink\" title=\"第二步：实现服务器端的逻辑\"></a>第二步：实现服务器端的逻辑</h3><p>搭建完Express之后，就需要实现服务器的事件监听和响应了。继续对上面的server.js进行编辑。后台的所有事件注册应该建立在io对象的connection事件之上，也就是说需要在浏览器端已经开启，请求向服务器连接的基础上进行。最基本的事件包括消息事件message、断开事件disconnect，连接事件connection。由于这里需要根据路径划分聊天房间，需要进行命名空间划分。Socket.io提供.join(roomid)方法加入聊天室，.leave(roomid)方法离开聊天室，.to(roomid).emit(event)方法向roomid的所有连接用户的群发消息。首先需要划分路由，从而区分聊天室号：<br><figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 获取用户当前的url，从而截取出房间id</span></div><div class=\"line\">    <span class=\"built_in\">var</span> <span class=\"built_in\">url</span> = socket.request.headers.referer;</div><div class=\"line\">    <span class=\"built_in\">var</span> split_arr = <span class=\"built_in\">url</span>.split(<span class=\"string\">'/'</span>);</div><div class=\"line\">    <span class=\"built_in\">var</span> roomid = split_arr[split_arr.length<span class=\"number\">-1</span>] || <span class=\"string\">'index'</span>;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>然后是对join、message和disconnect三个事件的监听：<br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">    <span class=\"keyword\">var</span> user = <span class=\"string\">''</span>;</div><div class=\"line\">    socket.on(<span class=\"string\">'join'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(username)</span> </span>&#123;</div><div class=\"line\">         user = username;</div><div class=\"line\">        <span class=\"comment\">// 将用户归类到房间</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (!roomUser[roomid]) &#123;</div><div class=\"line\">            roomUser[roomid] = [];</div><div class=\"line\">        &#125;</div><div class=\"line\">        roomUser[roomid].push(user);</div><div class=\"line\">        socket.join(roomid);</div><div class=\"line\">        socket.to(roomid).emit(<span class=\"string\">'sys'</span>, user + <span class=\"string\">'加入了房间'</span>);</div><div class=\"line\">        socket.emit(<span class=\"string\">'sys'</span>,user + <span class=\"string\">'加入了房间'</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 监听来自客户端的消息</span></div><div class=\"line\">    socket.on(<span class=\"string\">'message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(msg)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 验证如果用户不在房间内则不给发送</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (roomUser[roomid].indexOf(user)&lt; <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        socket.to(roomid).emit(<span class=\"string\">'new message'</span>, msg,user);</div><div class=\"line\">        socket.emit(<span class=\"string\">'new message'</span>, msg,user);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 关闭</span></div><div class=\"line\">    socket.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 从房间名单中移除</span></div><div class=\"line\">        socket.leave(roomid, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">                log.error(err);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">var</span> index = roomUser[roomid].indexOf(user);</div><div class=\"line\">                <span class=\"keyword\">if</span> (index !== <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">                    roomUser[roomid].splice(index, <span class=\"number\">1</span>);</div><div class=\"line\">                    socket.to(roomid).emit(<span class=\"string\">'sys'</span>,user+<span class=\"string\">'退出了房间'</span>);</div><div class=\"line\">                &#125; </div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"第三步：实现客户端交互\"><a href=\"#第三步：实现客户端交互\" class=\"headerlink\" title=\"第三步：实现客户端交互\"></a>第三步：实现客户端交互</h3><p>客户端的消息收发主要是监听来自服务器emit的事件及其消息内容。由于socket.io通信事件是可以自定义的，所以前后端的事件监听必须对应好。为了方便，这里浏览器端的界面比较简单：一个消息展示窗口和一个文本输入框。当用户在输入框输入文本并敲回车键的时候，客户端调用socket.send()方法向服务器发送消息。浏览器接收到来自服务器的sys事件和new message事件之后，将消息内容显示在消息展示窗口。<br>index.ejs:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>我的名字:<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"chat-area\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width:300px;height:400px;background-color:#eef;overflow-y:scroll\"</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"messages\"</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inputMessage\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"按回车键发送\"</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/socket.io/socket.io.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/js/jquery.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/js/chat.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>index界面主要引入三个js文件，其中socket.io.js的路径大家可能觉得不可思议，明明项目中并没有“/socket.io”这个路径。这是由于socket.io安装完毕之后自动完成了这个路径的映射，所以我们是不用管这个的，照写就可以了。chat.js主要负责客户端和服务器的事件通信,它通过 var socket = io() 创建浏览器端的socket.io对象。<br>chat.js:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> username =  prompt(<span class=\"string\">'请输入昵称'</span>);</div><div class=\"line\">    $(<span class=\"string\">'.name'</span>).html(username)</div><div class=\"line\">    <span class=\"keyword\">var</span> input = $(<span class=\"string\">'.inputMessage'</span>);</div><div class=\"line\">    <span class=\"comment\">// 默认链接到渲染页面的服务器</span></div><div class=\"line\">    <span class=\"keyword\">var</span> socket = io();</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scrollToBottom</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        $(<span class=\"string\">'#chat-area'</span>).scrollTop($(<span class=\"string\">'#chat-area'</span>)[<span class=\"number\">0</span>].scrollHeight);</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    socket.on(<span class=\"string\">'connect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> name = $(<span class=\"string\">'.name'</span>).text() ||<span class=\"string\">'匿名'</span>;</div><div class=\"line\">        socket.emit(<span class=\"string\">'join'</span>,name);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    socket.on(<span class=\"string\">'sys'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</div><div class=\"line\">        $(<span class=\"string\">'.messages'</span>).append(<span class=\"string\">'&lt;p&gt;'</span>+msg+<span class=\"string\">'&lt;/p&gt;'</span>);</div><div class=\"line\">        <span class=\"comment\">// 滚动条滚动到底部</span></div><div class=\"line\">        scrollToBottom();</div><div class=\"line\">    &#125;);</div><div class=\"line\">    socket.on(<span class=\"string\">'new message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg,user</span>) </span>&#123;</div><div class=\"line\">        $(<span class=\"string\">'.messages'</span>).append(<span class=\"string\">'&lt;p&gt;'</span>+user+<span class=\"string\">'说：'</span>+msg+<span class=\"string\">'&lt;/p&gt;'</span>);</div><div class=\"line\">        <span class=\"comment\">// 滚动条滚动到底部</span></div><div class=\"line\">        scrollToBottom();</div><div class=\"line\">    &#125;);</div><div class=\"line\">    input.on(<span class=\"string\">'keydown'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (e.which === <span class=\"number\">13</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//判断回车键</span></div><div class=\"line\">            <span class=\"keyword\">var</span> message = $(<span class=\"keyword\">this</span>).val();</div><div class=\"line\">            <span class=\"keyword\">if</span> (!message) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> ;</div><div class=\"line\">            &#125;</div><div class=\"line\">            socket.send(message);</div><div class=\"line\">            $(<span class=\"keyword\">this</span>).val(<span class=\"string\">''</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>到这里，一个简单的多聊天室应用就完成了，由于在Express的Router设置了访问路径:<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">router</span><span class=\"selector-class\">.get</span>(<span class=\"string\">'/room/:id'</span>, function(req, res, next) &#123;</div><div class=\"line\">  res<span class=\"selector-class\">.render</span>(<span class=\"string\">'index'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>安装完毕应用，执行server.js开启服务器之后，打开浏览器访问 localhost:8080/room/1 就可以访问房间号为1的聊天室了。然后呢，鉴于…<br><img src=\"http://i4.tietuku.com/d121eb715f0f6654s.png\" alt=\"demo\"><br>业界良心，还是要附上全部的<a href=\"https://github.com/hugzh/chatroom-demo\">demo</a>代码的。</p>\n<p>当然，你还可以根据自己的情况把demo拓展得更完善一些，比如加点好看的css，实现用户登录等等。如果需要实现登录功能，服务器socket应该添加对session读写的支持。由于socket.io本身是不支持session的，需要引入第三方模块比如 socket.io-express-session ，来实现用户状态认证：<br><figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">socket</span>.handshake.session.passport) &#123;    </div><div class=\"line\">    user.username = <span class=\"keyword\">socket</span>.handshake.session.passport.user;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>到此，一个简单的socket.io应用就完成了，这篇文章主要是解决Express4.x和socket.io1.3.x配置的时候需要调整的一些写法，不注意的话很容易各种瞎折腾。另外，本文demo部分参考了吴彦欣老师的一个<a href=\"https://github.com/wuyanxin/chatapp-demo\">demo</a>，感谢分享。</p>"},{"title":"Webpack学习实践系列(一)","date":"2016-05-02T11:59:34.000Z","_content":"Webpack是伴随着React出现的一个名词，近两年Webpack越来越受到前端开发者们的热捧。如果你已经使用过诸如Grunt、Gulp这样的工具，那么你对“构建”这个词肯定不会陌生。没错，Webpack就是当今最火的前端构建工具之一，配合Gulp使用可以搭建出非常强大的构建工具。<!--more-->趁着五一小假期，打算把最近自己折腾过的知识做个总结。这是上篇，主要是单纯的webpack使用，[下篇]()主要内容是结合Gulp尝试搭建更加强大的前端构建工具。\n\n# 什么是Webpack？\n按照[官方文档](http://webpack.github.io/docs/what-is-webpack.html)的解释，Webpack就是个模块打包工具，将模块及其依赖打包生成静态资源。在Webpack的机制里，所有的资源都是模块(js,css,图片等)，而且可以通过代码分隔([Code Splitting](http://webpack.github.io/docs/code-splitting.html))的方法异步加载，实现性能上的优化。\n\n## Chunk的概念\nchunk是使用Webpack过程中最重要的几个概念之一。在Webpack打包机制中，编译的文件包括entry（入口，可以是一个或者多个资源合并而成，由html通过script标签引入）和chunk（被entry所依赖的额外的代码块，同样可以包含一个或者多个文件）。从页面加速的角度来讲，我们应该尽可能将所有的js打包到一个bundle.js之中，但是总会有一些功能是使用过程中才会用到的。出于性能优化的需要，对于这部分资源我们可以做成按需加载，通过require.ensure方法实现:\n```\nrequire.ensure([], function(require) {\n        var dialog = require('./components/dialog');\n        // todo ...\n    });\n```\n而固定的公用代码则独立打包到trunk之中。在Webpack的配置中，我们可以通过CommonsChunkPlugin插件对指定的chunks进行公共模块的提取。我们指定好生成文件的名字，以及想抽取哪些入口js文件的公共代码，webpack就会自动帮我们合并好。:\n```\nvar chunks = Object.keys(entries);\nplugins: [\n    new  webpack.optimize.CommonsChunkPlugin({\n        name: 'vendors', // 将公共模块提取，生成名为`vendors`的chunk\n        chunks: chunks,\n        minChunks: chunks.length // 提取所有entry共同依赖的模块\n    })\n],\n```\n## Loader\nLoader就是资源转换器。由于在webpack里，所有的资源都是模块，不同资源都最终转化成js去处理。针对不同形式的资源采用不同的Loader去编译，这就是Loader的意义。Loader在使用之前必须先通过npm安装，然后在config里面通过module配置才能使用。举个例子:\n```\nmodule: {\n    loaders: [{\n        test: /\\.(png|jpg|jpeg|gif)$/,\n        loader: 'url?limit=10000&name=images/[name].[ext]'\n    }]\n}\n```\n上述配置中，test的作用是正则匹配，匹配到png或jpg或gif结尾的文件就采用url-loader来做对应的编译。由于loader都是默认以-loader后缀结尾的，所以可以省略后缀\"-loader\"，直接写成url。问号后面是参数，表示10000B以下的图片直接压缩成base64编码，超过10000B的图片输出到\"images/文件名.拓展名\"。上面的配置也可以这样写：\n```\nloaders: [{\n    test: /\\.(png|jpg|jpeg|gif)$/,\n    loader: 'url-loader',\n    query:{\n        limit:'10000',\n        name:'images/[name].[ext]'\n    }\n}]\n```\n配置中常用的loader：\n* 处理样式，转成css，如：less-loader, sass-loader\n* 图片处理，如: url-loader, file-loader。两个都必须用上。否则超过大小限制的图片无法生成到目标文件夹中\n* 处理js，将es6或更高级的代码转成es5的代码。如： babel-loader，babel-preset-es2015，babel-preset-react\n* 将js模块暴露到全局，使用expose-loader\n\n## Plugin \n插件的引入和loader差不多，只是插件是以对象的形式引入。像静态资源路径的替换这种功能就能通过插件来处理。比如公用模块打包到chunk的插件：\n```\nvar chunks = Object.keys(entries);\nplugins: [\n    new  webpack.optimize.CommonsChunkPlugin({\n        name: 'vendors', // 将公共模块提取，生成名为`vendors`的chunk\n        chunks: chunks,\n        minChunks: chunks.length // 提取所有entry共同依赖的模块\n    })\n],\n```\n配置中常用的plugin：\n* 代码热替换, HotModuleReplacementPlugin\n* 生成html文件，HtmlWebpackPlugin\n* 将css成生文件，而非内联，ExtractTextPlugin\n* 报错但不退出webpack进程，NoErrorsPlugin\n* 代码丑化，UglifyJsPlugin，开发过程中不建议打开\n* 多个 html共用一个js文件(chunk)，可用CommonsChunkPlugin\n* 清理文件夹，Clean\n* 调用模块的别名ProvidePlugin，例如想在js中用\"$\"，如果通过webpack加载，需要将$与jQuery对应起来\n\n# 搭建自己的构建集成环境\n介绍完上面几个概念，我们就可以进入动手搭建脚手架的阶段了。\n网上关于webpack的介绍文章不少，但是这些文章大多数是简略性的介绍或者是仅仅面向有一定webpack基础的开发者，对于完全从零开始的开发者来说理解起来有点吃力。这篇文章是完全面向webpack零基础的同学，根据我自己的填坑经历一步一步描述如何搭建一个简单的构建工具。由于是新手，中间难免会存在一些错误，欢迎留言指正。\n## 项目目录\n假设我们要搭建的demo项目的目录结构是这样的：\n```\n- webapp/               # webapp根目录\n  + node_modules        # node_modules\n  - src/                # 开发目录\n    - index             # index模块\n      + images/         # webapp图片资源目录\n        index.html      # 模板   \n        index.js        # 模块entry\n        style.less      # 样式表\n  webpack.config.js     # webpack配置文件\n  package.json          # 项目依赖文件\n  config.js             # 项目配置文件\n  README.md             # 项目说明\n```\n\n## 配置过程\n项目目录确定之后，下面开始来着手配置webpack。\n### 安装webpack\n首先，全局安装webpack，至于怎么装...额，就不侮辱大家智商了。\n### 安装依赖\n这一步也非常简单，根据项目需要用到的依赖 npm i xxx--save-dev，也可以在配置webpack.config.js的过程中根据需要安装。\n### 配置webpack\n这一步基本是webpack配置的全部内容。由于webpack默认读取根目录下的webpack.config.js文件，所以我们需要在根目录手动创建。\n看看我们的webpack.config.js配置文件：\n#### 1、首先，引入我们需要用到的npm模块\n```\nvar path = require('path'); //node 原生path模块\nvar webpack = require('webpack'); // webpack\nvar glob = require('glob'); // glob模块，用于读取webpack入口目录文件\nvar ExtractTextPlugin = require('extract-text-webpack-plugin'); //webpack插件\nvar HtmlWebpackPlugin = require('html-webpack-plugin'); //webpack插件\nvar OpenBrowserPlugin = require('open-browser-webpack-plugin');//webpack插件\nvar CleanPlugin = require('clean-webpack-plugin')//webpack插件，用于清除目录文件\nvar CommonsChunkPlugin = webpack.optimize.CommonsChunkPlugin;//处理trunk\n```\n#### 2、读取入口文件\n按照之前约定的项目目录，我们的webpack入口文件所在目录为src/index/index.js。所以，先要用glob读取模块入口。在这里，我们把读取目录定义为一个函数：\n```\nvar getEntry = function() {\n    var entry = {};\n    //读取开发目录,并进行路径裁剪\n    glob.sync('./src/**/*.js')\n        .forEach(function(name) {\n            var start = name.indexOf('src/') + 4,\n                end = name.length - 3;\n            var n = name.slice(start, end);\n            n = n.slice(0, n.lastIndexOf('/'));\n            //保存各个组件的入口\n            entry[n] = name;\n        });\n    return entry;\n};\n```\n然后将配置封装在module.exports，定义入口entry字段，entry可以为字符串、对象或者数组，对应单页面和多页面应用：\n```\n...\nmodule.exports = {\n    entry: getEntry(),\n    ...\n}\n```\n#### 3、定义资源输出\n资源打包输出的配置在output内，主要包括path、filename、chunkFilename以及publicPath。path是资源输出路径，filename是资源命名规则，chunkFilename是公共js打包后输出的命名，publicPath是静态资源的公共路径，比如线上CDN地址等，开发环境可以不设置，这样CSS中的相对路径就不会包括publicPath。在output输出的时候可以根据开发环境或者生产环境选择不同的文件命名方法，因为一般来说，线上的资源都是要经过压缩的。比如我们定义一个\"prod\"变量判断当前编译环境:\n```\n    ...\n    output: {\n        path: path.resolve(__dirname, prod ? \"./dist\" : \"./build\"),\n        filename: prod ? \"js/[name].min.js\" : \"js/[name].js\",\n        chunkFilename: 'js/[name].chunk.js',\n        publicPath: prod ? \"http:cdn.mydomain.com\" : \"\"\n    },\n    ...\n```\n[name]的值是根据入口entry显示的文件名。比如index.js这个入口文件，对应的output的[name]值就应该是“index”，当然，我们还可以根据需要使用[hash]、[id]这样的值。\n#### 4、定义resolve\n为了方便开发，我们可以定义自己的别名，以便很快捷地引用不同的模块，别名(alias)的定义是在resolve对象之中。比如，\n```\nresolve: {\n    alias:{\n        xyz: \"/absolute/path/to/file.js\" \n    }\n}\n\n```\n那么，当我们在代码中require('xyz')的时候，实际上我们是引入'/absolute/path/to/file.js'这个文件。还可以配置extensions对象，使得开发过程中文件资源的处理可以忽略后缀。在我们的demo中，是这样配置的:\n```\n    ...\n    resolve: {\n        //配置项,设置忽略js后缀\n        extensions: ['', '.js', '.less', '.css', '.png', '.jpg'],\n        root: './src',\n        // 模块别名\n        alias: {}\n    },\n    ...\n```\n#### 5、配置loaders\nloader的配置是在module中定义。根据文章开头部分的介绍，loaders就是定义一个个资源处理器，demo项目主要用到下面几个loader：\n```\n    ...\n    module: {\n        loaders: [{\n            test: /\\.(png|jpg|jpeg|gif)$/,\n            loader: 'url?limit=10000&name=images/[name].[ext]'\n        }, {\n            test: /\\.less$/,\n            loader: ExtractTextPlugin.extract('style', 'css!less')\n        }, {\n            test: /\\.js[x]?$/,\n            exclude: /node_modules/,\n            loader: 'babel?presets[]=es2015&presets[]=react'\n        }, {\n            test: /\\.html$/,\n            loader: 'html?attrs=img:src img:srcset'\n        }]\n    },\n    ...\n```\nExtractTextPlugin.extract是用来提取出单独的CSS文件的插件，如果不使用这个插件处理样式文件，CSS会内联在页面中，不利于做样式表维护;而babel则是用来做es6转换。\n#### 6、定义Plugins\n```\n    ...\n    plugins: [\n        new HtmlWebpackPlugin({\n            filename: 'index.html',\n            template: './src/index/index.html'\n        }),\n        new CleanPlugin(['dist', 'build']),\n        // 启动热替换\n        new webpack.HotModuleReplacementPlugin(),\n        new ExtractTextPlugin('[name].css', {\n            allChunks: true\n        }),\n        new webpack.NoErrorsPlugin(),\n        new OpenBrowserPlugin({\n            url: 'http://localhost:8080'\n        }),\n        /* 公共库 */\n        new CommonsChunkPlugin({\n            name: 'vendors',\n            minChunks: Infinity\n        }),\n    ]\n    ...\n```\nHtmlWebpackPlugin插件用来自动在页面中注入chunk；HotModuleReplacementPlugin插件是用来做热替换的，每次开发环境下的资源发生变更之后都会自动重新打包输出，不需要重新构建；配置OpenBrowserPlugin插件可以在构建完成之后自动打开浏览器的\"localhost:8080\"这个路径；CommonsChunkPlugin插件定义chunk名字，文章开始部分已做详细介绍。\n#### 7、定义webpack-dev-server\nwebpack-dev-server是webpack提供的静态资源服务器，它的存在使得开发可以脱离代理服务器工作。开发调试静态资源不再需要搭建本地服务器，这魔法简直是解救万民于水火呀！webpack-dev-server有多种配置形式，这里采用的是写死在config的方式，这种方式的特点是方便开发，缺点是不灵活。\n```\n    ...\n    devServer = {\n        port: 8080,\n        contentBase: './build', //定义静态服务器的基路径\n        hot: true,\n        historyApiFallback: true,\n        publicPath: \"\",\n        stats: {\n            colors: true\n        },\n        plugins: [\n        new webpack.HotModuleReplacementPlugin()\n        ]\n    }\n    ...\n```\n\n#### 8、编译环境判断\n在“步骤3”我们需要根据当前的编译环境来选择不同的资源输出方式。编译环境的判断可以通过定义node的script来设置环境变量。在我们项目根目录的package.json文件中，定义：\n```\n\"scripts\": {\n    \"dev\": \"webpack-dev-server\",\n    \"build\": \"webpack\",\n    \"deploy\": \"set NODE_ENV=production&&webpack -p --progress --colors\"\n  },\n```\n这样的话，终端执行\"npm run dev\" 就相当于执行 \"webpack-dev-server\"。如果执行\"npm run deploy\"，那就是编译生产环境，node就会设置环境变量\"NODE_ENV\"为\"production\"。然后在webpack的配置文件中，通过\"process.env.NODE_ENV\"就可以读取到\"production\"这个值。所以在配置的开头，我们这样定义一个局部变量:\n```\nvar prod = process.env.NODE_ENV === 'production' ? true : false;\n```\n之后在配置文件的最后，根据当前的编译环境，如果是生产环境就配置引用压缩丑化插件\"UglifyJsPlugin\"，如果是开发环境就配置webpack-dev-server：\n```\n// 判断开发环境还是生产环境,添加uglify等插件\nif (process.env.NODE_ENV === 'production') {\n    module.exports.plugins = (module.exports.plugins || [])\n        .concat([\n            new webpack.DefinePlugin({\n                __DEV__: JSON.stringify(JSON.parse(process.env.DEBUG || 'false'))\n            }),\n            new webpack.optimize.UglifyJsPlugin({\n                compress: {\n                    warnings: false\n                }\n            }),\n            new webpack.optimize.OccurenceOrderPlugin(),\n        ]);\n} else {\n    module.exports.devtool = 'source-map';\n    module.exports.devServer = {\n        port: 8080,\n        contentBase: './build',\n        hot: true,\n        historyApiFallback: true,\n        publicPath: \"\",\n        stats: {\n            colors: true\n        },\n        plugins: [\n        new webpack.HotModuleReplacementPlugin()\n        ]\n    };\n}\n```\n\n## 模块代码\n至此，我们已经完成了一个基本的webpack配置，接下来就是使用webpack构建代码了。我们定义的index模块的代码入口是index.js，在Index.js内通过require()方式引入不同的资源用于打包：\n```\nrequire('./style.less'); //引入.less预处理文件\nrequire('./index.html'); //引入同级目录的index.html文件\n```\n然后，执行\"npm run dev\"即可查看本地环境的静态资源效果。demo项目的完整代码可以[查看github](https://github.com/hugzh/webpack-simple-demo)\n\n# 总结\nwebpack的零碎知识点还有很多，这里只是根据自己的学习心得搭建出来的简单构建环境。目前的构建还是不够灵活强大的，后面的时间我会继续探索结合gulp定制的webpack构建工具，在当前构建的基础上搭建一套更加完善的构建工具。\n\n本文出自橙乡果汁的博客([blog.hugzh.com](http://blog.hugzh.com/2016/05/02/webpack%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97-%E4%B8%80/))，转载请注明出处!\n","source":"_posts/webpack学习实践系列-一.md","raw":"title: webpack学习实践系列(一)\ndate: 2016-05-02 19:59:34\ncategories:\n    - 前端开发 \ntags: \n    - 构建工具\n    - 前端工程\n---\nWebpack是伴随着React出现的一个名词，近两年Webpack越来越受到前端开发者们的热捧。如果你已经使用过诸如Grunt、Gulp这样的工具，那么你对“构建”这个词肯定不会陌生。没错，Webpack就是当今最火的前端构建工具之一，配合Gulp使用可以搭建出非常强大的构建工具。<!--more-->趁着五一小假期，打算把最近自己折腾过的知识做个总结。这是上篇，主要是单纯的webpack使用，[下篇]()主要内容是结合Gulp尝试搭建更加强大的前端构建工具。\n\n# 什么是Webpack？\n按照[官方文档](http://webpack.github.io/docs/what-is-webpack.html)的解释，Webpack就是个模块打包工具，将模块及其依赖打包生成静态资源。在Webpack的机制里，所有的资源都是模块(js,css,图片等)，而且可以通过代码分隔([Code Splitting](http://webpack.github.io/docs/code-splitting.html))的方法异步加载，实现性能上的优化。\n\n## Chunk的概念\nchunk是使用Webpack过程中最重要的几个概念之一。在Webpack打包机制中，编译的文件包括entry（入口，可以是一个或者多个资源合并而成，由html通过script标签引入）和chunk（被entry所依赖的额外的代码块，同样可以包含一个或者多个文件）。从页面加速的角度来讲，我们应该尽可能将所有的js打包到一个bundle.js之中，但是总会有一些功能是使用过程中才会用到的。出于性能优化的需要，对于这部分资源我们可以做成按需加载，通过require.ensure方法实现:\n```\nrequire.ensure([], function(require) {\n        var dialog = require('./components/dialog');\n        // todo ...\n    });\n```\n而固定的公用代码则独立打包到trunk之中。在Webpack的配置中，我们可以通过CommonsChunkPlugin插件对指定的chunks进行公共模块的提取。我们指定好生成文件的名字，以及想抽取哪些入口js文件的公共代码，webpack就会自动帮我们合并好。:\n```\nvar chunks = Object.keys(entries);\nplugins: [\n    new  webpack.optimize.CommonsChunkPlugin({\n        name: 'vendors', // 将公共模块提取，生成名为`vendors`的chunk\n        chunks: chunks,\n        minChunks: chunks.length // 提取所有entry共同依赖的模块\n    })\n],\n```\n## Loader\nLoader就是资源转换器。由于在webpack里，所有的资源都是模块，不同资源都最终转化成js去处理。针对不同形式的资源采用不同的Loader去编译，这就是Loader的意义。Loader在使用之前必须先通过npm安装，然后在config里面通过module配置才能使用。举个例子:\n```\nmodule: {\n    loaders: [{\n        test: /\\.(png|jpg|jpeg|gif)$/,\n        loader: 'url?limit=10000&name=images/[name].[ext]'\n    }]\n}\n```\n上述配置中，test的作用是正则匹配，匹配到png或jpg或gif结尾的文件就采用url-loader来做对应的编译。由于loader都是默认以-loader后缀结尾的，所以可以省略后缀\"-loader\"，直接写成url。问号后面是参数，表示10000B以下的图片直接压缩成base64编码，超过10000B的图片输出到\"images/文件名.拓展名\"。上面的配置也可以这样写：\n```\nloaders: [{\n    test: /\\.(png|jpg|jpeg|gif)$/,\n    loader: 'url-loader',\n    query:{\n        limit:'10000',\n        name:'images/[name].[ext]'\n    }\n}]\n```\n配置中常用的loader：\n* 处理样式，转成css，如：less-loader, sass-loader\n* 图片处理，如: url-loader, file-loader。两个都必须用上。否则超过大小限制的图片无法生成到目标文件夹中\n* 处理js，将es6或更高级的代码转成es5的代码。如： babel-loader，babel-preset-es2015，babel-preset-react\n* 将js模块暴露到全局，使用expose-loader\n\n## Plugin \n插件的引入和loader差不多，只是插件是以对象的形式引入。像静态资源路径的替换这种功能就能通过插件来处理。比如公用模块打包到chunk的插件：\n```\nvar chunks = Object.keys(entries);\nplugins: [\n    new  webpack.optimize.CommonsChunkPlugin({\n        name: 'vendors', // 将公共模块提取，生成名为`vendors`的chunk\n        chunks: chunks,\n        minChunks: chunks.length // 提取所有entry共同依赖的模块\n    })\n],\n```\n配置中常用的plugin：\n* 代码热替换, HotModuleReplacementPlugin\n* 生成html文件，HtmlWebpackPlugin\n* 将css成生文件，而非内联，ExtractTextPlugin\n* 报错但不退出webpack进程，NoErrorsPlugin\n* 代码丑化，UglifyJsPlugin，开发过程中不建议打开\n* 多个 html共用一个js文件(chunk)，可用CommonsChunkPlugin\n* 清理文件夹，Clean\n* 调用模块的别名ProvidePlugin，例如想在js中用\"$\"，如果通过webpack加载，需要将$与jQuery对应起来\n\n# 搭建自己的构建集成环境\n介绍完上面几个概念，我们就可以进入动手搭建脚手架的阶段了。\n网上关于webpack的介绍文章不少，但是这些文章大多数是简略性的介绍或者是仅仅面向有一定webpack基础的开发者，对于完全从零开始的开发者来说理解起来有点吃力。这篇文章是完全面向webpack零基础的同学，根据我自己的填坑经历一步一步描述如何搭建一个简单的构建工具。由于是新手，中间难免会存在一些错误，欢迎留言指正。\n## 项目目录\n假设我们要搭建的demo项目的目录结构是这样的：\n```\n- webapp/               # webapp根目录\n  + node_modules        # node_modules\n  - src/                # 开发目录\n    - index             # index模块\n      + images/         # webapp图片资源目录\n        index.html      # 模板   \n        index.js        # 模块entry\n        style.less      # 样式表\n  webpack.config.js     # webpack配置文件\n  package.json          # 项目依赖文件\n  config.js             # 项目配置文件\n  README.md             # 项目说明\n```\n\n## 配置过程\n项目目录确定之后，下面开始来着手配置webpack。\n### 安装webpack\n首先，全局安装webpack，至于怎么装...额，就不侮辱大家智商了。\n### 安装依赖\n这一步也非常简单，根据项目需要用到的依赖 npm i xxx--save-dev，也可以在配置webpack.config.js的过程中根据需要安装。\n### 配置webpack\n这一步基本是webpack配置的全部内容。由于webpack默认读取根目录下的webpack.config.js文件，所以我们需要在根目录手动创建。\n看看我们的webpack.config.js配置文件：\n#### 1、首先，引入我们需要用到的npm模块\n```\nvar path = require('path'); //node 原生path模块\nvar webpack = require('webpack'); // webpack\nvar glob = require('glob'); // glob模块，用于读取webpack入口目录文件\nvar ExtractTextPlugin = require('extract-text-webpack-plugin'); //webpack插件\nvar HtmlWebpackPlugin = require('html-webpack-plugin'); //webpack插件\nvar OpenBrowserPlugin = require('open-browser-webpack-plugin');//webpack插件\nvar CleanPlugin = require('clean-webpack-plugin')//webpack插件，用于清除目录文件\nvar CommonsChunkPlugin = webpack.optimize.CommonsChunkPlugin;//处理trunk\n```\n#### 2、读取入口文件\n按照之前约定的项目目录，我们的webpack入口文件所在目录为src/index/index.js。所以，先要用glob读取模块入口。在这里，我们把读取目录定义为一个函数：\n```\nvar getEntry = function() {\n    var entry = {};\n    //读取开发目录,并进行路径裁剪\n    glob.sync('./src/**/*.js')\n        .forEach(function(name) {\n            var start = name.indexOf('src/') + 4,\n                end = name.length - 3;\n            var n = name.slice(start, end);\n            n = n.slice(0, n.lastIndexOf('/'));\n            //保存各个组件的入口\n            entry[n] = name;\n        });\n    return entry;\n};\n```\n然后将配置封装在module.exports，定义入口entry字段，entry可以为字符串、对象或者数组，对应单页面和多页面应用：\n```\n...\nmodule.exports = {\n    entry: getEntry(),\n    ...\n}\n```\n#### 3、定义资源输出\n资源打包输出的配置在output内，主要包括path、filename、chunkFilename以及publicPath。path是资源输出路径，filename是资源命名规则，chunkFilename是公共js打包后输出的命名，publicPath是静态资源的公共路径，比如线上CDN地址等，开发环境可以不设置，这样CSS中的相对路径就不会包括publicPath。在output输出的时候可以根据开发环境或者生产环境选择不同的文件命名方法，因为一般来说，线上的资源都是要经过压缩的。比如我们定义一个\"prod\"变量判断当前编译环境:\n```\n    ...\n    output: {\n        path: path.resolve(__dirname, prod ? \"./dist\" : \"./build\"),\n        filename: prod ? \"js/[name].min.js\" : \"js/[name].js\",\n        chunkFilename: 'js/[name].chunk.js',\n        publicPath: prod ? \"http:cdn.mydomain.com\" : \"\"\n    },\n    ...\n```\n[name]的值是根据入口entry显示的文件名。比如index.js这个入口文件，对应的output的[name]值就应该是“index”，当然，我们还可以根据需要使用[hash]、[id]这样的值。\n#### 4、定义resolve\n为了方便开发，我们可以定义自己的别名，以便很快捷地引用不同的模块，别名(alias)的定义是在resolve对象之中。比如，\n```\nresolve: {\n    alias:{\n        xyz: \"/absolute/path/to/file.js\" \n    }\n}\n\n```\n那么，当我们在代码中require('xyz')的时候，实际上我们是引入'/absolute/path/to/file.js'这个文件。还可以配置extensions对象，使得开发过程中文件资源的处理可以忽略后缀。在我们的demo中，是这样配置的:\n```\n    ...\n    resolve: {\n        //配置项,设置忽略js后缀\n        extensions: ['', '.js', '.less', '.css', '.png', '.jpg'],\n        root: './src',\n        // 模块别名\n        alias: {}\n    },\n    ...\n```\n#### 5、配置loaders\nloader的配置是在module中定义。根据文章开头部分的介绍，loaders就是定义一个个资源处理器，demo项目主要用到下面几个loader：\n```\n    ...\n    module: {\n        loaders: [{\n            test: /\\.(png|jpg|jpeg|gif)$/,\n            loader: 'url?limit=10000&name=images/[name].[ext]'\n        }, {\n            test: /\\.less$/,\n            loader: ExtractTextPlugin.extract('style', 'css!less')\n        }, {\n            test: /\\.js[x]?$/,\n            exclude: /node_modules/,\n            loader: 'babel?presets[]=es2015&presets[]=react'\n        }, {\n            test: /\\.html$/,\n            loader: 'html?attrs=img:src img:srcset'\n        }]\n    },\n    ...\n```\nExtractTextPlugin.extract是用来提取出单独的CSS文件的插件，如果不使用这个插件处理样式文件，CSS会内联在页面中，不利于做样式表维护;而babel则是用来做es6转换。\n#### 6、定义Plugins\n```\n    ...\n    plugins: [\n        new HtmlWebpackPlugin({\n            filename: 'index.html',\n            template: './src/index/index.html'\n        }),\n        new CleanPlugin(['dist', 'build']),\n        // 启动热替换\n        new webpack.HotModuleReplacementPlugin(),\n        new ExtractTextPlugin('[name].css', {\n            allChunks: true\n        }),\n        new webpack.NoErrorsPlugin(),\n        new OpenBrowserPlugin({\n            url: 'http://localhost:8080'\n        }),\n        /* 公共库 */\n        new CommonsChunkPlugin({\n            name: 'vendors',\n            minChunks: Infinity\n        }),\n    ]\n    ...\n```\nHtmlWebpackPlugin插件用来自动在页面中注入chunk；HotModuleReplacementPlugin插件是用来做热替换的，每次开发环境下的资源发生变更之后都会自动重新打包输出，不需要重新构建；配置OpenBrowserPlugin插件可以在构建完成之后自动打开浏览器的\"localhost:8080\"这个路径；CommonsChunkPlugin插件定义chunk名字，文章开始部分已做详细介绍。\n#### 7、定义webpack-dev-server\nwebpack-dev-server是webpack提供的静态资源服务器，它的存在使得开发可以脱离代理服务器工作。开发调试静态资源不再需要搭建本地服务器，这魔法简直是解救万民于水火呀！webpack-dev-server有多种配置形式，这里采用的是写死在config的方式，这种方式的特点是方便开发，缺点是不灵活。\n```\n    ...\n    devServer = {\n        port: 8080,\n        contentBase: './build', //定义静态服务器的基路径\n        hot: true,\n        historyApiFallback: true,\n        publicPath: \"\",\n        stats: {\n            colors: true\n        },\n        plugins: [\n        new webpack.HotModuleReplacementPlugin()\n        ]\n    }\n    ...\n```\n\n#### 8、编译环境判断\n在“步骤3”我们需要根据当前的编译环境来选择不同的资源输出方式。编译环境的判断可以通过定义node的script来设置环境变量。在我们项目根目录的package.json文件中，定义：\n```\n\"scripts\": {\n    \"dev\": \"webpack-dev-server\",\n    \"build\": \"webpack\",\n    \"deploy\": \"set NODE_ENV=production&&webpack -p --progress --colors\"\n  },\n```\n这样的话，终端执行\"npm run dev\" 就相当于执行 \"webpack-dev-server\"。如果执行\"npm run deploy\"，那就是编译生产环境，node就会设置环境变量\"NODE_ENV\"为\"production\"。然后在webpack的配置文件中，通过\"process.env.NODE_ENV\"就可以读取到\"production\"这个值。所以在配置的开头，我们这样定义一个局部变量:\n```\nvar prod = process.env.NODE_ENV === 'production' ? true : false;\n```\n之后在配置文件的最后，根据当前的编译环境，如果是生产环境就配置引用压缩丑化插件\"UglifyJsPlugin\"，如果是开发环境就配置webpack-dev-server：\n```\n// 判断开发环境还是生产环境,添加uglify等插件\nif (process.env.NODE_ENV === 'production') {\n    module.exports.plugins = (module.exports.plugins || [])\n        .concat([\n            new webpack.DefinePlugin({\n                __DEV__: JSON.stringify(JSON.parse(process.env.DEBUG || 'false'))\n            }),\n            new webpack.optimize.UglifyJsPlugin({\n                compress: {\n                    warnings: false\n                }\n            }),\n            new webpack.optimize.OccurenceOrderPlugin(),\n        ]);\n} else {\n    module.exports.devtool = 'source-map';\n    module.exports.devServer = {\n        port: 8080,\n        contentBase: './build',\n        hot: true,\n        historyApiFallback: true,\n        publicPath: \"\",\n        stats: {\n            colors: true\n        },\n        plugins: [\n        new webpack.HotModuleReplacementPlugin()\n        ]\n    };\n}\n```\n\n## 模块代码\n至此，我们已经完成了一个基本的webpack配置，接下来就是使用webpack构建代码了。我们定义的index模块的代码入口是index.js，在Index.js内通过require()方式引入不同的资源用于打包：\n```\nrequire('./style.less'); //引入.less预处理文件\nrequire('./index.html'); //引入同级目录的index.html文件\n```\n然后，执行\"npm run dev\"即可查看本地环境的静态资源效果。demo项目的完整代码可以[查看github](https://github.com/hugzh/webpack-simple-demo)\n\n# 总结\nwebpack的零碎知识点还有很多，这里只是根据自己的学习心得搭建出来的简单构建环境。目前的构建还是不够灵活强大的，后面的时间我会继续探索结合gulp定制的webpack构建工具，在当前构建的基础上搭建一套更加完善的构建工具。\n\n本文出自橙乡果汁的博客([blog.hugzh.com](http://blog.hugzh.com/2016/05/02/webpack%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97-%E4%B8%80/))，转载请注明出处!\n","slug":"webpack学习实践系列-一","published":1,"updated":"2016-08-13T03:08:44.552Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtrv002c7kauomw2f8i1","content":"<p>Webpack是伴随着React出现的一个名词，近两年Webpack越来越受到前端开发者们的热捧。如果你已经使用过诸如Grunt、Gulp这样的工具，那么你对“构建”这个词肯定不会陌生。没错，Webpack就是当今最火的前端构建工具之一，配合Gulp使用可以搭建出非常强大的构建工具。<a id=\"more\"></a>趁着五一小假期，打算把最近自己折腾过的知识做个总结。这是上篇，主要是单纯的webpack使用，<a href=\"\">下篇</a>主要内容是结合Gulp尝试搭建更加强大的前端构建工具。</p>\n<h1 id=\"什么是Webpack？\"><a href=\"#什么是Webpack？\" class=\"headerlink\" title=\"什么是Webpack？\"></a>什么是Webpack？</h1><p>按照<a href=\"http://webpack.github.io/docs/what-is-webpack.html\" target=\"_blank\" rel=\"external\">官方文档</a>的解释，Webpack就是个模块打包工具，将模块及其依赖打包生成静态资源。在Webpack的机制里，所有的资源都是模块(js,css,图片等)，而且可以通过代码分隔(<a href=\"http://webpack.github.io/docs/code-splitting.html\" target=\"_blank\" rel=\"external\">Code Splitting</a>)的方法异步加载，实现性能上的优化。</p>\n<h2 id=\"Chunk的概念\"><a href=\"#Chunk的概念\" class=\"headerlink\" title=\"Chunk的概念\"></a>Chunk的概念</h2><p>chunk是使用Webpack过程中最重要的几个概念之一。在Webpack打包机制中，编译的文件包括entry（入口，可以是一个或者多个资源合并而成，由html通过script标签引入）和chunk（被entry所依赖的额外的代码块，同样可以包含一个或者多个文件）。从页面加速的角度来讲，我们应该尽可能将所有的js打包到一个bundle.js之中，但是总会有一些功能是使用过程中才会用到的。出于性能优化的需要，对于这部分资源我们可以做成按需加载，通过require.ensure方法实现:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>.ensure([], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> dialog = <span class=\"built_in\">require</span>(<span class=\"string\">'./components/dialog'</span>);</div><div class=\"line\">        <span class=\"comment\">// todo ...</span></div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<p>而固定的公用代码则独立打包到trunk之中。在Webpack的配置中，我们可以通过CommonsChunkPlugin插件对指定的chunks进行公共模块的提取。我们指定好生成文件的名字，以及想抽取哪些入口js文件的公共代码，webpack就会自动帮我们合并好。:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> chunks = <span class=\"built_in\">Object</span>.keys(entries);</div><div class=\"line\">plugins: [</div><div class=\"line\">    <span class=\"keyword\">new</span>  webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">        name: <span class=\"string\">'vendors'</span>, <span class=\"comment\">// 将公共模块提取，生成名为`vendors`的chunk</span></div><div class=\"line\">        chunks: chunks,</div><div class=\"line\">        minChunks: chunks.length <span class=\"comment\">// 提取所有entry共同依赖的模块</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">],</div></pre></td></tr></table></figure></p>\n<h2 id=\"Loader\"><a href=\"#Loader\" class=\"headerlink\" title=\"Loader\"></a>Loader</h2><p>Loader就是资源转换器。由于在webpack里，所有的资源都是模块，不同资源都最终转化成js去处理。针对不同形式的资源采用不同的Loader去编译，这就是Loader的意义。Loader在使用之前必须先通过npm安装，然后在config里面通过module配置才能使用。举个例子:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">module</span>: &#123;</div><div class=\"line\">    <span class=\"attribute\">loaders</span>: [&#123;</div><div class=\"line\">        test: /\\.(png|jpg|jpeg|gif)$/,</div><div class=\"line\">        loader: <span class=\"string\">'url?limit=10000&amp;name=images/[name].[ext]'</span></div><div class=\"line\">    &#125;]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上述配置中，test的作用是正则匹配，匹配到png或jpg或gif结尾的文件就采用url-loader来做对应的编译。由于loader都是默认以-loader后缀结尾的，所以可以省略后缀”-loader”，直接写成url。问号后面是参数，表示10000B以下的图片直接压缩成base64编码，超过10000B的图片输出到”images/文件名.拓展名”。上面的配置也可以这样写：<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">loaders:</span> [&#123;</div><div class=\"line\"><span class=\"attr\">    test:</span> /\\.(png|jpg|jpeg|gif)$/,</div><div class=\"line\"><span class=\"attr\">    loader:</span> <span class=\"string\">'url-loader'</span>,</div><div class=\"line\"><span class=\"attr\">    query:</span>&#123;</div><div class=\"line\"><span class=\"attr\">        limit:</span><span class=\"string\">'10000'</span>,</div><div class=\"line\"><span class=\"attr\">        name:</span><span class=\"string\">'images/[name].[ext]'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;]</div></pre></td></tr></table></figure></p>\n<p>配置中常用的loader：</p>\n<ul>\n<li>处理样式，转成css，如：less-loader, sass-loader</li>\n<li>图片处理，如: url-loader, file-loader。两个都必须用上。否则超过大小限制的图片无法生成到目标文件夹中</li>\n<li>处理js，将es6或更高级的代码转成es5的代码。如： babel-loader，babel-preset-es2015，babel-preset-react</li>\n<li>将js模块暴露到全局，使用expose-loader</li>\n</ul>\n<h2 id=\"Plugin\"><a href=\"#Plugin\" class=\"headerlink\" title=\"Plugin\"></a>Plugin</h2><p>插件的引入和loader差不多，只是插件是以对象的形式引入。像静态资源路径的替换这种功能就能通过插件来处理。比如公用模块打包到chunk的插件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> chunks = <span class=\"built_in\">Object</span>.keys(entries);</div><div class=\"line\">plugins: [</div><div class=\"line\">    <span class=\"keyword\">new</span>  webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">        name: <span class=\"string\">'vendors'</span>, <span class=\"comment\">// 将公共模块提取，生成名为`vendors`的chunk</span></div><div class=\"line\">        chunks: chunks,</div><div class=\"line\">        minChunks: chunks.length <span class=\"comment\">// 提取所有entry共同依赖的模块</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">],</div></pre></td></tr></table></figure></p>\n<p>配置中常用的plugin：</p>\n<ul>\n<li>代码热替换, HotModuleReplacementPlugin</li>\n<li>生成html文件，HtmlWebpackPlugin</li>\n<li>将css成生文件，而非内联，ExtractTextPlugin</li>\n<li>报错但不退出webpack进程，NoErrorsPlugin</li>\n<li>代码丑化，UglifyJsPlugin，开发过程中不建议打开</li>\n<li>多个 html共用一个js文件(chunk)，可用CommonsChunkPlugin</li>\n<li>清理文件夹，Clean</li>\n<li>调用模块的别名ProvidePlugin，例如想在js中用”$”，如果通过webpack加载，需要将$与jQuery对应起来</li>\n</ul>\n<h1 id=\"搭建自己的构建集成环境\"><a href=\"#搭建自己的构建集成环境\" class=\"headerlink\" title=\"搭建自己的构建集成环境\"></a>搭建自己的构建集成环境</h1><p>介绍完上面几个概念，我们就可以进入动手搭建脚手架的阶段了。<br>网上关于webpack的介绍文章不少，但是这些文章大多数是简略性的介绍或者是仅仅面向有一定webpack基础的开发者，对于完全从零开始的开发者来说理解起来有点吃力。这篇文章是完全面向webpack零基础的同学，根据我自己的填坑经历一步一步描述如何搭建一个简单的构建工具。由于是新手，中间难免会存在一些错误，欢迎留言指正。</p>\n<h2 id=\"项目目录\"><a href=\"#项目目录\" class=\"headerlink\" title=\"项目目录\"></a>项目目录</h2><p>假设我们要搭建的demo项目的目录结构是这样的：<br><figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- webapp/               <span class=\"meta\"># webapp根目录</span></div><div class=\"line\">  + node_modules        <span class=\"meta\"># node_modules</span></div><div class=\"line\">  - src/                <span class=\"meta\"># 开发目录</span></div><div class=\"line\">    - <span class=\"keyword\">index</span>             <span class=\"meta\"># index模块</span></div><div class=\"line\">      + images/         <span class=\"meta\"># webapp图片资源目录</span></div><div class=\"line\">        <span class=\"keyword\">index</span>.html      <span class=\"meta\"># 模板   </span></div><div class=\"line\">        <span class=\"keyword\">index</span>.js        <span class=\"meta\"># 模块entry</span></div><div class=\"line\">        style.less      <span class=\"meta\"># 样式表</span></div><div class=\"line\">  webpack.config.js     <span class=\"meta\"># webpack配置文件</span></div><div class=\"line\">  package.json          <span class=\"meta\"># 项目依赖文件</span></div><div class=\"line\">  config.js             <span class=\"meta\"># 项目配置文件</span></div><div class=\"line\">  README.md             <span class=\"meta\"># 项目说明</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"配置过程\"><a href=\"#配置过程\" class=\"headerlink\" title=\"配置过程\"></a>配置过程</h2><p>项目目录确定之后，下面开始来着手配置webpack。</p>\n<h3 id=\"安装webpack\"><a href=\"#安装webpack\" class=\"headerlink\" title=\"安装webpack\"></a>安装webpack</h3><p>首先，全局安装webpack，至于怎么装…额，就不侮辱大家智商了。</p>\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><p>这一步也非常简单，根据项目需要用到的依赖 npm i xxx–save-dev，也可以在配置webpack.config.js的过程中根据需要安装。</p>\n<h3 id=\"配置webpack\"><a href=\"#配置webpack\" class=\"headerlink\" title=\"配置webpack\"></a>配置webpack</h3><p>这一步基本是webpack配置的全部内容。由于webpack默认读取根目录下的webpack.config.js文件，所以我们需要在根目录手动创建。<br>看看我们的webpack.config.js配置文件：</p>\n<h4 id=\"1、首先，引入我们需要用到的npm模块\"><a href=\"#1、首先，引入我们需要用到的npm模块\" class=\"headerlink\" title=\"1、首先，引入我们需要用到的npm模块\"></a>1、首先，引入我们需要用到的npm模块</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>); <span class=\"comment\">//node 原生path模块</span></div><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>); <span class=\"comment\">// webpack</span></div><div class=\"line\"><span class=\"keyword\">var</span> glob = <span class=\"built_in\">require</span>(<span class=\"string\">'glob'</span>); <span class=\"comment\">// glob模块，用于读取webpack入口目录文件</span></div><div class=\"line\"><span class=\"keyword\">var</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>); <span class=\"comment\">//webpack插件</span></div><div class=\"line\"><span class=\"keyword\">var</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>); <span class=\"comment\">//webpack插件</span></div><div class=\"line\"><span class=\"keyword\">var</span> OpenBrowserPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'open-browser-webpack-plugin'</span>);<span class=\"comment\">//webpack插件</span></div><div class=\"line\"><span class=\"keyword\">var</span> CleanPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'clean-webpack-plugin'</span>)<span class=\"comment\">//webpack插件，用于清除目录文件</span></div><div class=\"line\"><span class=\"keyword\">var</span> CommonsChunkPlugin = webpack.optimize.CommonsChunkPlugin;<span class=\"comment\">//处理trunk</span></div></pre></td></tr></table></figure>\n<h4 id=\"2、读取入口文件\"><a href=\"#2、读取入口文件\" class=\"headerlink\" title=\"2、读取入口文件\"></a>2、读取入口文件</h4><p>按照之前约定的项目目录，我们的webpack入口文件所在目录为src/index/index.js。所以，先要用glob读取模块入口。在这里，我们把读取目录定义为一个函数：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getEntry = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> entry = &#123;&#125;;</div><div class=\"line\">    <span class=\"comment\">//读取开发目录,并进行路径裁剪</span></div><div class=\"line\">    glob.sync(<span class=\"string\">'./src/**/*.js'</span>)</div><div class=\"line\">        .<span class=\"keyword\">forEach</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(name)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> start = name.indexOf(<span class=\"string\">'src/'</span>) + <span class=\"number\">4</span>,</div><div class=\"line\">                end = name.length - <span class=\"number\">3</span>;</div><div class=\"line\">            <span class=\"keyword\">var</span> n = name.slice(start, end);</div><div class=\"line\">            n = n.slice(<span class=\"number\">0</span>, n.lastIndexOf(<span class=\"string\">'/'</span>));</div><div class=\"line\">            <span class=\"comment\">//保存各个组件的入口</span></div><div class=\"line\">            entry[n] = name;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> entry;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>然后将配置封装在module.exports，定义入口entry字段，entry可以为字符串、对象或者数组，对应单页面和多页面应用：<br><figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">module</span>.exports = &#123;</div><div class=\"line\">    <span class=\"built_in\">entry</span>: getEntry(),</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"3、定义资源输出\"><a href=\"#3、定义资源输出\" class=\"headerlink\" title=\"3、定义资源输出\"></a>3、定义资源输出</h4><p>资源打包输出的配置在output内，主要包括path、filename、chunkFilename以及publicPath。path是资源输出路径，filename是资源命名规则，chunkFilename是公共js打包后输出的命名，publicPath是静态资源的公共路径，比如线上CDN地址等，开发环境可以不设置，这样CSS中的相对路径就不会包括publicPath。在output输出的时候可以根据开发环境或者生产环境选择不同的文件命名方法，因为一般来说，线上的资源都是要经过压缩的。比如我们定义一个”prod”变量判断当前编译环境:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"><span class=\"selector-tag\">output</span>: &#123;</div><div class=\"line\">    <span class=\"attribute\">path</span>: path.<span class=\"built_in\">resolve</span>(__dirname, prod ? <span class=\"string\">\"./dist\"</span> : <span class=\"string\">\"./build\"</span>),</div><div class=\"line\">    filename: prod ? <span class=\"string\">\"js/[name].min.js\"</span> : <span class=\"string\">\"js/[name].js\"</span>,</div><div class=\"line\">    chunkFilename: <span class=\"string\">'js/[name].chunk.js'</span>,</div><div class=\"line\">    publicPath: prod ? <span class=\"string\">\"http:cdn.mydomain.com\"</span> : <span class=\"string\">\"\"</span></div><div class=\"line\">&#125;,</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<p>[name]的值是根据入口entry显示的文件名。比如index.js这个入口文件，对应的output的[name]值就应该是“index”，当然，我们还可以根据需要使用[hash]、[id]这样的值。</p>\n<h4 id=\"4、定义resolve\"><a href=\"#4、定义resolve\" class=\"headerlink\" title=\"4、定义resolve\"></a>4、定义resolve</h4><p>为了方便开发，我们可以定义自己的别名，以便很快捷地引用不同的模块，别名(alias)的定义是在resolve对象之中。比如，<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">resolve</span>: &#123;</div><div class=\"line\">    <span class=\"attribute\">alias</span>:&#123;</div><div class=\"line\">        xyz: <span class=\"string\">\"/absolute/path/to/file.js\"</span> </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>那么，当我们在代码中require(‘xyz’)的时候，实际上我们是引入’/absolute/path/to/file.js’这个文件。还可以配置extensions对象，使得开发过程中文件资源的处理可以忽略后缀。在我们的demo中，是这样配置的:<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"><span class=\"selector-tag\">resolve</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">//配置项,设置忽略js后缀</span></div><div class=\"line\">    <span class=\"attribute\">extensions</span>: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.less'</span>, <span class=\"string\">'.css'</span>, <span class=\"string\">'.png'</span>, <span class=\"string\">'.jpg'</span>],</div><div class=\"line\">    <span class=\"attribute\">root</span>: <span class=\"string\">'./src'</span>,</div><div class=\"line\">    <span class=\"comment\">// 模块别名</span></div><div class=\"line\">    <span class=\"attribute\">alias</span>: &#123;&#125;</div><div class=\"line\">&#125;,</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h4 id=\"5、配置loaders\"><a href=\"#5、配置loaders\" class=\"headerlink\" title=\"5、配置loaders\"></a>5、配置loaders</h4><p>loader的配置是在module中定义。根据文章开头部分的介绍，loaders就是定义一个个资源处理器，demo项目主要用到下面几个loader：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"><span class=\"selector-tag\">module</span>: &#123;</div><div class=\"line\">    <span class=\"attribute\">loaders</span>: [&#123;</div><div class=\"line\">        test: /\\.(png|jpg|jpeg|gif)$/,</div><div class=\"line\">        loader: <span class=\"string\">'url?limit=10000&amp;name=images/[name].[ext]'</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">        <span class=\"attribute\">test</span>: /\\.less$/,</div><div class=\"line\">        loader: ExtractTextPlugin.<span class=\"built_in\">extract</span>(<span class=\"string\">'style'</span>, <span class=\"string\">'css!less'</span>)</div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">        <span class=\"attribute\">test</span>: /\\.js[x]?$/,</div><div class=\"line\">        exclude: /node_modules/,</div><div class=\"line\">        loader: <span class=\"string\">'babel?presets[]=es2015&amp;presets[]=react'</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">        <span class=\"attribute\">test</span>: /\\.html$/,</div><div class=\"line\">        loader: <span class=\"string\">'html?attrs=img:src img:srcset'</span></div><div class=\"line\">    &#125;]</div><div class=\"line\">&#125;,</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<p>ExtractTextPlugin.extract是用来提取出单独的CSS文件的插件，如果不使用这个插件处理样式文件，CSS会内联在页面中，不利于做样式表维护;而babel则是用来做es6转换。</p>\n<h4 id=\"6、定义Plugins\"><a href=\"#6、定义Plugins\" class=\"headerlink\" title=\"6、定义Plugins\"></a>6、定义Plugins</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">plugins: [</div><div class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</div><div class=\"line\">        filename: <span class=\"string\">'index.html'</span>,</div><div class=\"line\">        template: <span class=\"string\">'./src/index/index.html'</span></div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"keyword\">new</span> CleanPlugin([<span class=\"string\">'dist'</span>, <span class=\"string\">'build'</span>]),</div><div class=\"line\">    <span class=\"comment\">// 启动热替换</span></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin(),</div><div class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'[name].css'</span>, &#123;</div><div class=\"line\">        allChunks: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.NoErrorsPlugin(),</div><div class=\"line\">    <span class=\"keyword\">new</span> OpenBrowserPlugin(&#123;</div><div class=\"line\">        url: <span class=\"string\">'http://localhost:8080'</span></div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"comment\">/* 公共库 */</span></div><div class=\"line\">    <span class=\"keyword\">new</span> CommonsChunkPlugin(&#123;</div><div class=\"line\">        name: <span class=\"string\">'vendors'</span>,</div><div class=\"line\">        minChunks: <span class=\"literal\">Infinity</span></div><div class=\"line\">    &#125;),</div><div class=\"line\">]</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>HtmlWebpackPlugin插件用来自动在页面中注入chunk；HotModuleReplacementPlugin插件是用来做热替换的，每次开发环境下的资源发生变更之后都会自动重新打包输出，不需要重新构建；配置OpenBrowserPlugin插件可以在构建完成之后自动打开浏览器的”localhost:8080”这个路径；CommonsChunkPlugin插件定义chunk名字，文章开始部分已做详细介绍。</p>\n<h4 id=\"7、定义webpack-dev-server\"><a href=\"#7、定义webpack-dev-server\" class=\"headerlink\" title=\"7、定义webpack-dev-server\"></a>7、定义webpack-dev-server</h4><p>webpack-dev-server是webpack提供的静态资源服务器，它的存在使得开发可以脱离代理服务器工作。开发调试静态资源不再需要搭建本地服务器，这魔法简直是解救万民于水火呀！webpack-dev-server有多种配置形式，这里采用的是写死在config的方式，这种方式的特点是方便开发，缺点是不灵活。<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">devServer = &#123;</div><div class=\"line\"><span class=\"attr\">    port:</span> <span class=\"number\">8080</span>,</div><div class=\"line\"><span class=\"attr\">    contentBase:</span> <span class=\"string\">'./build'</span>, //定义静态服务器的基路径</div><div class=\"line\"><span class=\"attr\">    hot:</span> <span class=\"literal\">true</span>,</div><div class=\"line\"><span class=\"attr\">    historyApiFallback:</span> <span class=\"literal\">true</span>,</div><div class=\"line\"><span class=\"attr\">    publicPath:</span> <span class=\"string\">\"\"</span>,</div><div class=\"line\"><span class=\"attr\">    stats:</span> &#123;</div><div class=\"line\"><span class=\"attr\">        colors:</span> <span class=\"literal\">true</span></div><div class=\"line\">    &#125;,</div><div class=\"line\"><span class=\"attr\">    plugins:</span> [</div><div class=\"line\">    new webpack.HotModuleReplacementPlugin()</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h4 id=\"8、编译环境判断\"><a href=\"#8、编译环境判断\" class=\"headerlink\" title=\"8、编译环境判断\"></a>8、编译环境判断</h4><p>在“步骤3”我们需要根据当前的编译环境来选择不同的资源输出方式。编译环境的判断可以通过定义node的script来设置环境变量。在我们项目根目录的package.json文件中，定义：<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"webpack-dev-server\"</span>,</div><div class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"webpack\"</span>,</div><div class=\"line\">    <span class=\"string\">\"deploy\"</span>: <span class=\"string\">\"set NODE_ENV=production&amp;&amp;webpack -p --progress --colors\"</span></div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>这样的话，终端执行”npm run dev” 就相当于执行 “webpack-dev-server”。如果执行”npm run deploy”，那就是编译生产环境，node就会设置环境变量”NODE_ENV”为”production”。然后在webpack的配置文件中，通过”process.env.NODE_ENV”就可以读取到”production”这个值。所以在配置的开头，我们这样定义一个局部变量:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> prod = process.env.NODE_ENV === <span class=\"string\">'production'</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</div></pre></td></tr></table></figure></p>\n<p>之后在配置文件的最后，根据当前的编译环境，如果是生产环境就配置引用压缩丑化插件”UglifyJsPlugin”，如果是开发环境就配置webpack-dev-server：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 判断开发环境还是生产环境,添加uglify等插件</span></div><div class=\"line\"><span class=\"keyword\">if</span> (process.env.NODE_ENV === <span class=\"string\">'production'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">module</span>.<span class=\"keyword\">exports</span>.plugins = (<span class=\"keyword\">module</span>.<span class=\"keyword\">exports</span>.plugins || [])</div><div class=\"line\">        .concat([</div><div class=\"line\">            <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</div><div class=\"line\">                __DEV__: JSON.stringify(JSON.parse(process.env.DEBUG || <span class=\"string\">'false'</span>))</div><div class=\"line\">            &#125;),</div><div class=\"line\">            <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class=\"line\">                compress: &#123;</div><div class=\"line\">                    warnings: <span class=\"keyword\">false</span></div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;),</div><div class=\"line\">            <span class=\"keyword\">new</span> webpack.optimize.OccurenceOrderPlugin(),</div><div class=\"line\">        ]);</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">module</span>.<span class=\"keyword\">exports</span>.devtool = <span class=\"string\">'source-map'</span>;</div><div class=\"line\">    <span class=\"keyword\">module</span>.<span class=\"keyword\">exports</span>.devServer = &#123;</div><div class=\"line\">        port: <span class=\"number\">8080</span>,</div><div class=\"line\">        contentBase: <span class=\"string\">'./build'</span>,</div><div class=\"line\">        hot: <span class=\"keyword\">true</span>,</div><div class=\"line\">        historyApiFallback: <span class=\"keyword\">true</span>,</div><div class=\"line\">        publicPath: <span class=\"string\">\"\"</span>,</div><div class=\"line\">        stats: &#123;</div><div class=\"line\">            colors: <span class=\"keyword\">true</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        plugins: [</div><div class=\"line\">        <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</div><div class=\"line\">        ]</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"模块代码\"><a href=\"#模块代码\" class=\"headerlink\" title=\"模块代码\"></a>模块代码</h2><p>至此，我们已经完成了一个基本的webpack配置，接下来就是使用webpack构建代码了。我们定义的index模块的代码入口是index.js，在Index.js内通过require()方式引入不同的资源用于打包：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./style.less'</span>); <span class=\"comment\">//引入.less预处理文件</span></div><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./index.html'</span>); <span class=\"comment\">//引入同级目录的index.html文件</span></div></pre></td></tr></table></figure></p>\n<p>然后，执行”npm run dev”即可查看本地环境的静态资源效果。demo项目的完整代码可以<a href=\"https://github.com/hugzh/webpack-simple-demo\" target=\"_blank\" rel=\"external\">查看github</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>webpack的零碎知识点还有很多，这里只是根据自己的学习心得搭建出来的简单构建环境。目前的构建还是不够灵活强大的，后面的时间我会继续探索结合gulp定制的webpack构建工具，在当前构建的基础上搭建一套更加完善的构建工具。</p>\n<p>本文出自橙乡果汁的博客(<a href=\"http://blog.hugzh.com/2016/05/02/webpack%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97-%E4%B8%80/\">blog.hugzh.com</a>)，转载请注明出处!</p>\n","excerpt":"<p>Webpack是伴随着React出现的一个名词，近两年Webpack越来越受到前端开发者们的热捧。如果你已经使用过诸如Grunt、Gulp这样的工具，那么你对“构建”这个词肯定不会陌生。没错，Webpack就是当今最火的前端构建工具之一，配合Gulp使用可以搭建出非常强大的构建工具。","more":"趁着五一小假期，打算把最近自己折腾过的知识做个总结。这是上篇，主要是单纯的webpack使用，<a href=\"\">下篇</a>主要内容是结合Gulp尝试搭建更加强大的前端构建工具。</p>\n<h1 id=\"什么是Webpack？\"><a href=\"#什么是Webpack？\" class=\"headerlink\" title=\"什么是Webpack？\"></a>什么是Webpack？</h1><p>按照<a href=\"http://webpack.github.io/docs/what-is-webpack.html\">官方文档</a>的解释，Webpack就是个模块打包工具，将模块及其依赖打包生成静态资源。在Webpack的机制里，所有的资源都是模块(js,css,图片等)，而且可以通过代码分隔(<a href=\"http://webpack.github.io/docs/code-splitting.html\">Code Splitting</a>)的方法异步加载，实现性能上的优化。</p>\n<h2 id=\"Chunk的概念\"><a href=\"#Chunk的概念\" class=\"headerlink\" title=\"Chunk的概念\"></a>Chunk的概念</h2><p>chunk是使用Webpack过程中最重要的几个概念之一。在Webpack打包机制中，编译的文件包括entry（入口，可以是一个或者多个资源合并而成，由html通过script标签引入）和chunk（被entry所依赖的额外的代码块，同样可以包含一个或者多个文件）。从页面加速的角度来讲，我们应该尽可能将所有的js打包到一个bundle.js之中，但是总会有一些功能是使用过程中才会用到的。出于性能优化的需要，对于这部分资源我们可以做成按需加载，通过require.ensure方法实现:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>.ensure([], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> dialog = <span class=\"built_in\">require</span>(<span class=\"string\">'./components/dialog'</span>);</div><div class=\"line\">        <span class=\"comment\">// todo ...</span></div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<p>而固定的公用代码则独立打包到trunk之中。在Webpack的配置中，我们可以通过CommonsChunkPlugin插件对指定的chunks进行公共模块的提取。我们指定好生成文件的名字，以及想抽取哪些入口js文件的公共代码，webpack就会自动帮我们合并好。:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> chunks = <span class=\"built_in\">Object</span>.keys(entries);</div><div class=\"line\">plugins: [</div><div class=\"line\">    <span class=\"keyword\">new</span>  webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">        name: <span class=\"string\">'vendors'</span>, <span class=\"comment\">// 将公共模块提取，生成名为`vendors`的chunk</span></div><div class=\"line\">        chunks: chunks,</div><div class=\"line\">        minChunks: chunks.length <span class=\"comment\">// 提取所有entry共同依赖的模块</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">],</div></pre></td></tr></table></figure></p>\n<h2 id=\"Loader\"><a href=\"#Loader\" class=\"headerlink\" title=\"Loader\"></a>Loader</h2><p>Loader就是资源转换器。由于在webpack里，所有的资源都是模块，不同资源都最终转化成js去处理。针对不同形式的资源采用不同的Loader去编译，这就是Loader的意义。Loader在使用之前必须先通过npm安装，然后在config里面通过module配置才能使用。举个例子:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">module</span>: &#123;</div><div class=\"line\">    <span class=\"attribute\">loaders</span>: [&#123;</div><div class=\"line\">        test: /\\.(png|jpg|jpeg|gif)$/,</div><div class=\"line\">        loader: <span class=\"string\">'url?limit=10000&amp;name=images/[name].[ext]'</span></div><div class=\"line\">    &#125;]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上述配置中，test的作用是正则匹配，匹配到png或jpg或gif结尾的文件就采用url-loader来做对应的编译。由于loader都是默认以-loader后缀结尾的，所以可以省略后缀”-loader”，直接写成url。问号后面是参数，表示10000B以下的图片直接压缩成base64编码，超过10000B的图片输出到”images/文件名.拓展名”。上面的配置也可以这样写：<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">loaders:</span> [&#123;</div><div class=\"line\"><span class=\"attr\">    test:</span> /\\.(png|jpg|jpeg|gif)$/,</div><div class=\"line\"><span class=\"attr\">    loader:</span> <span class=\"string\">'url-loader'</span>,</div><div class=\"line\"><span class=\"attr\">    query:</span>&#123;</div><div class=\"line\"><span class=\"attr\">        limit:</span><span class=\"string\">'10000'</span>,</div><div class=\"line\"><span class=\"attr\">        name:</span><span class=\"string\">'images/[name].[ext]'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;]</div></pre></td></tr></table></figure></p>\n<p>配置中常用的loader：</p>\n<ul>\n<li>处理样式，转成css，如：less-loader, sass-loader</li>\n<li>图片处理，如: url-loader, file-loader。两个都必须用上。否则超过大小限制的图片无法生成到目标文件夹中</li>\n<li>处理js，将es6或更高级的代码转成es5的代码。如： babel-loader，babel-preset-es2015，babel-preset-react</li>\n<li>将js模块暴露到全局，使用expose-loader</li>\n</ul>\n<h2 id=\"Plugin\"><a href=\"#Plugin\" class=\"headerlink\" title=\"Plugin\"></a>Plugin</h2><p>插件的引入和loader差不多，只是插件是以对象的形式引入。像静态资源路径的替换这种功能就能通过插件来处理。比如公用模块打包到chunk的插件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> chunks = <span class=\"built_in\">Object</span>.keys(entries);</div><div class=\"line\">plugins: [</div><div class=\"line\">    <span class=\"keyword\">new</span>  webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">        name: <span class=\"string\">'vendors'</span>, <span class=\"comment\">// 将公共模块提取，生成名为`vendors`的chunk</span></div><div class=\"line\">        chunks: chunks,</div><div class=\"line\">        minChunks: chunks.length <span class=\"comment\">// 提取所有entry共同依赖的模块</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">],</div></pre></td></tr></table></figure></p>\n<p>配置中常用的plugin：</p>\n<ul>\n<li>代码热替换, HotModuleReplacementPlugin</li>\n<li>生成html文件，HtmlWebpackPlugin</li>\n<li>将css成生文件，而非内联，ExtractTextPlugin</li>\n<li>报错但不退出webpack进程，NoErrorsPlugin</li>\n<li>代码丑化，UglifyJsPlugin，开发过程中不建议打开</li>\n<li>多个 html共用一个js文件(chunk)，可用CommonsChunkPlugin</li>\n<li>清理文件夹，Clean</li>\n<li>调用模块的别名ProvidePlugin，例如想在js中用”$”，如果通过webpack加载，需要将$与jQuery对应起来</li>\n</ul>\n<h1 id=\"搭建自己的构建集成环境\"><a href=\"#搭建自己的构建集成环境\" class=\"headerlink\" title=\"搭建自己的构建集成环境\"></a>搭建自己的构建集成环境</h1><p>介绍完上面几个概念，我们就可以进入动手搭建脚手架的阶段了。<br>网上关于webpack的介绍文章不少，但是这些文章大多数是简略性的介绍或者是仅仅面向有一定webpack基础的开发者，对于完全从零开始的开发者来说理解起来有点吃力。这篇文章是完全面向webpack零基础的同学，根据我自己的填坑经历一步一步描述如何搭建一个简单的构建工具。由于是新手，中间难免会存在一些错误，欢迎留言指正。</p>\n<h2 id=\"项目目录\"><a href=\"#项目目录\" class=\"headerlink\" title=\"项目目录\"></a>项目目录</h2><p>假设我们要搭建的demo项目的目录结构是这样的：<br><figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- webapp/               <span class=\"meta\"># webapp根目录</span></div><div class=\"line\">  + node_modules        <span class=\"meta\"># node_modules</span></div><div class=\"line\">  - src/                <span class=\"meta\"># 开发目录</span></div><div class=\"line\">    - <span class=\"keyword\">index</span>             <span class=\"meta\"># index模块</span></div><div class=\"line\">      + images/         <span class=\"meta\"># webapp图片资源目录</span></div><div class=\"line\">        <span class=\"keyword\">index</span>.html      <span class=\"meta\"># 模板   </span></div><div class=\"line\">        <span class=\"keyword\">index</span>.js        <span class=\"meta\"># 模块entry</span></div><div class=\"line\">        style.less      <span class=\"meta\"># 样式表</span></div><div class=\"line\">  webpack.config.js     <span class=\"meta\"># webpack配置文件</span></div><div class=\"line\">  package.json          <span class=\"meta\"># 项目依赖文件</span></div><div class=\"line\">  config.js             <span class=\"meta\"># 项目配置文件</span></div><div class=\"line\">  README.md             <span class=\"meta\"># 项目说明</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"配置过程\"><a href=\"#配置过程\" class=\"headerlink\" title=\"配置过程\"></a>配置过程</h2><p>项目目录确定之后，下面开始来着手配置webpack。</p>\n<h3 id=\"安装webpack\"><a href=\"#安装webpack\" class=\"headerlink\" title=\"安装webpack\"></a>安装webpack</h3><p>首先，全局安装webpack，至于怎么装…额，就不侮辱大家智商了。</p>\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><p>这一步也非常简单，根据项目需要用到的依赖 npm i xxx–save-dev，也可以在配置webpack.config.js的过程中根据需要安装。</p>\n<h3 id=\"配置webpack\"><a href=\"#配置webpack\" class=\"headerlink\" title=\"配置webpack\"></a>配置webpack</h3><p>这一步基本是webpack配置的全部内容。由于webpack默认读取根目录下的webpack.config.js文件，所以我们需要在根目录手动创建。<br>看看我们的webpack.config.js配置文件：</p>\n<h4 id=\"1、首先，引入我们需要用到的npm模块\"><a href=\"#1、首先，引入我们需要用到的npm模块\" class=\"headerlink\" title=\"1、首先，引入我们需要用到的npm模块\"></a>1、首先，引入我们需要用到的npm模块</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>); <span class=\"comment\">//node 原生path模块</span></div><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>); <span class=\"comment\">// webpack</span></div><div class=\"line\"><span class=\"keyword\">var</span> glob = <span class=\"built_in\">require</span>(<span class=\"string\">'glob'</span>); <span class=\"comment\">// glob模块，用于读取webpack入口目录文件</span></div><div class=\"line\"><span class=\"keyword\">var</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>); <span class=\"comment\">//webpack插件</span></div><div class=\"line\"><span class=\"keyword\">var</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>); <span class=\"comment\">//webpack插件</span></div><div class=\"line\"><span class=\"keyword\">var</span> OpenBrowserPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'open-browser-webpack-plugin'</span>);<span class=\"comment\">//webpack插件</span></div><div class=\"line\"><span class=\"keyword\">var</span> CleanPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'clean-webpack-plugin'</span>)<span class=\"comment\">//webpack插件，用于清除目录文件</span></div><div class=\"line\"><span class=\"keyword\">var</span> CommonsChunkPlugin = webpack.optimize.CommonsChunkPlugin;<span class=\"comment\">//处理trunk</span></div></pre></td></tr></table></figure>\n<h4 id=\"2、读取入口文件\"><a href=\"#2、读取入口文件\" class=\"headerlink\" title=\"2、读取入口文件\"></a>2、读取入口文件</h4><p>按照之前约定的项目目录，我们的webpack入口文件所在目录为src/index/index.js。所以，先要用glob读取模块入口。在这里，我们把读取目录定义为一个函数：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getEntry = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> entry = &#123;&#125;;</div><div class=\"line\">    <span class=\"comment\">//读取开发目录,并进行路径裁剪</span></div><div class=\"line\">    glob.sync(<span class=\"string\">'./src/**/*.js'</span>)</div><div class=\"line\">        .<span class=\"keyword\">forEach</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(name)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> start = name.indexOf(<span class=\"string\">'src/'</span>) + <span class=\"number\">4</span>,</div><div class=\"line\">                end = name.length - <span class=\"number\">3</span>;</div><div class=\"line\">            <span class=\"keyword\">var</span> n = name.slice(start, end);</div><div class=\"line\">            n = n.slice(<span class=\"number\">0</span>, n.lastIndexOf(<span class=\"string\">'/'</span>));</div><div class=\"line\">            <span class=\"comment\">//保存各个组件的入口</span></div><div class=\"line\">            entry[n] = name;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> entry;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>然后将配置封装在module.exports，定义入口entry字段，entry可以为字符串、对象或者数组，对应单页面和多页面应用：<br><figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">module</span>.exports = &#123;</div><div class=\"line\">    <span class=\"built_in\">entry</span>: getEntry(),</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"3、定义资源输出\"><a href=\"#3、定义资源输出\" class=\"headerlink\" title=\"3、定义资源输出\"></a>3、定义资源输出</h4><p>资源打包输出的配置在output内，主要包括path、filename、chunkFilename以及publicPath。path是资源输出路径，filename是资源命名规则，chunkFilename是公共js打包后输出的命名，publicPath是静态资源的公共路径，比如线上CDN地址等，开发环境可以不设置，这样CSS中的相对路径就不会包括publicPath。在output输出的时候可以根据开发环境或者生产环境选择不同的文件命名方法，因为一般来说，线上的资源都是要经过压缩的。比如我们定义一个”prod”变量判断当前编译环境:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"><span class=\"selector-tag\">output</span>: &#123;</div><div class=\"line\">    <span class=\"attribute\">path</span>: path.<span class=\"built_in\">resolve</span>(__dirname, prod ? <span class=\"string\">\"./dist\"</span> : <span class=\"string\">\"./build\"</span>),</div><div class=\"line\">    filename: prod ? <span class=\"string\">\"js/[name].min.js\"</span> : <span class=\"string\">\"js/[name].js\"</span>,</div><div class=\"line\">    chunkFilename: <span class=\"string\">'js/[name].chunk.js'</span>,</div><div class=\"line\">    publicPath: prod ? <span class=\"string\">\"http:cdn.mydomain.com\"</span> : <span class=\"string\">\"\"</span></div><div class=\"line\">&#125;,</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<p>[name]的值是根据入口entry显示的文件名。比如index.js这个入口文件，对应的output的[name]值就应该是“index”，当然，我们还可以根据需要使用[hash]、[id]这样的值。</p>\n<h4 id=\"4、定义resolve\"><a href=\"#4、定义resolve\" class=\"headerlink\" title=\"4、定义resolve\"></a>4、定义resolve</h4><p>为了方便开发，我们可以定义自己的别名，以便很快捷地引用不同的模块，别名(alias)的定义是在resolve对象之中。比如，<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">resolve</span>: &#123;</div><div class=\"line\">    <span class=\"attribute\">alias</span>:&#123;</div><div class=\"line\">        xyz: <span class=\"string\">\"/absolute/path/to/file.js\"</span> </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>那么，当我们在代码中require(‘xyz’)的时候，实际上我们是引入’/absolute/path/to/file.js’这个文件。还可以配置extensions对象，使得开发过程中文件资源的处理可以忽略后缀。在我们的demo中，是这样配置的:<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"><span class=\"selector-tag\">resolve</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">//配置项,设置忽略js后缀</span></div><div class=\"line\">    <span class=\"attribute\">extensions</span>: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.less'</span>, <span class=\"string\">'.css'</span>, <span class=\"string\">'.png'</span>, <span class=\"string\">'.jpg'</span>],</div><div class=\"line\">    <span class=\"attribute\">root</span>: <span class=\"string\">'./src'</span>,</div><div class=\"line\">    <span class=\"comment\">// 模块别名</span></div><div class=\"line\">    <span class=\"attribute\">alias</span>: &#123;&#125;</div><div class=\"line\">&#125;,</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h4 id=\"5、配置loaders\"><a href=\"#5、配置loaders\" class=\"headerlink\" title=\"5、配置loaders\"></a>5、配置loaders</h4><p>loader的配置是在module中定义。根据文章开头部分的介绍，loaders就是定义一个个资源处理器，demo项目主要用到下面几个loader：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"><span class=\"selector-tag\">module</span>: &#123;</div><div class=\"line\">    <span class=\"attribute\">loaders</span>: [&#123;</div><div class=\"line\">        test: /\\.(png|jpg|jpeg|gif)$/,</div><div class=\"line\">        loader: <span class=\"string\">'url?limit=10000&amp;name=images/[name].[ext]'</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">        <span class=\"attribute\">test</span>: /\\.less$/,</div><div class=\"line\">        loader: ExtractTextPlugin.<span class=\"built_in\">extract</span>(<span class=\"string\">'style'</span>, <span class=\"string\">'css!less'</span>)</div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">        <span class=\"attribute\">test</span>: /\\.js[x]?$/,</div><div class=\"line\">        exclude: /node_modules/,</div><div class=\"line\">        loader: <span class=\"string\">'babel?presets[]=es2015&amp;presets[]=react'</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">        <span class=\"attribute\">test</span>: /\\.html$/,</div><div class=\"line\">        loader: <span class=\"string\">'html?attrs=img:src img:srcset'</span></div><div class=\"line\">    &#125;]</div><div class=\"line\">&#125;,</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<p>ExtractTextPlugin.extract是用来提取出单独的CSS文件的插件，如果不使用这个插件处理样式文件，CSS会内联在页面中，不利于做样式表维护;而babel则是用来做es6转换。</p>\n<h4 id=\"6、定义Plugins\"><a href=\"#6、定义Plugins\" class=\"headerlink\" title=\"6、定义Plugins\"></a>6、定义Plugins</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">plugins: [</div><div class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</div><div class=\"line\">        filename: <span class=\"string\">'index.html'</span>,</div><div class=\"line\">        template: <span class=\"string\">'./src/index/index.html'</span></div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"keyword\">new</span> CleanPlugin([<span class=\"string\">'dist'</span>, <span class=\"string\">'build'</span>]),</div><div class=\"line\">    <span class=\"comment\">// 启动热替换</span></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin(),</div><div class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'[name].css'</span>, &#123;</div><div class=\"line\">        allChunks: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.NoErrorsPlugin(),</div><div class=\"line\">    <span class=\"keyword\">new</span> OpenBrowserPlugin(&#123;</div><div class=\"line\">        url: <span class=\"string\">'http://localhost:8080'</span></div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"comment\">/* 公共库 */</span></div><div class=\"line\">    <span class=\"keyword\">new</span> CommonsChunkPlugin(&#123;</div><div class=\"line\">        name: <span class=\"string\">'vendors'</span>,</div><div class=\"line\">        minChunks: <span class=\"literal\">Infinity</span></div><div class=\"line\">    &#125;),</div><div class=\"line\">]</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>HtmlWebpackPlugin插件用来自动在页面中注入chunk；HotModuleReplacementPlugin插件是用来做热替换的，每次开发环境下的资源发生变更之后都会自动重新打包输出，不需要重新构建；配置OpenBrowserPlugin插件可以在构建完成之后自动打开浏览器的”localhost:8080”这个路径；CommonsChunkPlugin插件定义chunk名字，文章开始部分已做详细介绍。</p>\n<h4 id=\"7、定义webpack-dev-server\"><a href=\"#7、定义webpack-dev-server\" class=\"headerlink\" title=\"7、定义webpack-dev-server\"></a>7、定义webpack-dev-server</h4><p>webpack-dev-server是webpack提供的静态资源服务器，它的存在使得开发可以脱离代理服务器工作。开发调试静态资源不再需要搭建本地服务器，这魔法简直是解救万民于水火呀！webpack-dev-server有多种配置形式，这里采用的是写死在config的方式，这种方式的特点是方便开发，缺点是不灵活。<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">devServer = &#123;</div><div class=\"line\"><span class=\"attr\">    port:</span> <span class=\"number\">8080</span>,</div><div class=\"line\"><span class=\"attr\">    contentBase:</span> <span class=\"string\">'./build'</span>, //定义静态服务器的基路径</div><div class=\"line\"><span class=\"attr\">    hot:</span> <span class=\"literal\">true</span>,</div><div class=\"line\"><span class=\"attr\">    historyApiFallback:</span> <span class=\"literal\">true</span>,</div><div class=\"line\"><span class=\"attr\">    publicPath:</span> <span class=\"string\">\"\"</span>,</div><div class=\"line\"><span class=\"attr\">    stats:</span> &#123;</div><div class=\"line\"><span class=\"attr\">        colors:</span> <span class=\"literal\">true</span></div><div class=\"line\">    &#125;,</div><div class=\"line\"><span class=\"attr\">    plugins:</span> [</div><div class=\"line\">    new webpack.HotModuleReplacementPlugin()</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h4 id=\"8、编译环境判断\"><a href=\"#8、编译环境判断\" class=\"headerlink\" title=\"8、编译环境判断\"></a>8、编译环境判断</h4><p>在“步骤3”我们需要根据当前的编译环境来选择不同的资源输出方式。编译环境的判断可以通过定义node的script来设置环境变量。在我们项目根目录的package.json文件中，定义：<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"webpack-dev-server\"</span>,</div><div class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"webpack\"</span>,</div><div class=\"line\">    <span class=\"string\">\"deploy\"</span>: <span class=\"string\">\"set NODE_ENV=production&amp;&amp;webpack -p --progress --colors\"</span></div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>这样的话，终端执行”npm run dev” 就相当于执行 “webpack-dev-server”。如果执行”npm run deploy”，那就是编译生产环境，node就会设置环境变量”NODE_ENV”为”production”。然后在webpack的配置文件中，通过”process.env.NODE_ENV”就可以读取到”production”这个值。所以在配置的开头，我们这样定义一个局部变量:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> prod = process.env.NODE_ENV === <span class=\"string\">'production'</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</div></pre></td></tr></table></figure></p>\n<p>之后在配置文件的最后，根据当前的编译环境，如果是生产环境就配置引用压缩丑化插件”UglifyJsPlugin”，如果是开发环境就配置webpack-dev-server：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 判断开发环境还是生产环境,添加uglify等插件</span></div><div class=\"line\"><span class=\"keyword\">if</span> (process.env.NODE_ENV === <span class=\"string\">'production'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">module</span>.<span class=\"keyword\">exports</span>.plugins = (<span class=\"keyword\">module</span>.<span class=\"keyword\">exports</span>.plugins || [])</div><div class=\"line\">        .concat([</div><div class=\"line\">            <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</div><div class=\"line\">                __DEV__: JSON.stringify(JSON.parse(process.env.DEBUG || <span class=\"string\">'false'</span>))</div><div class=\"line\">            &#125;),</div><div class=\"line\">            <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class=\"line\">                compress: &#123;</div><div class=\"line\">                    warnings: <span class=\"keyword\">false</span></div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;),</div><div class=\"line\">            <span class=\"keyword\">new</span> webpack.optimize.OccurenceOrderPlugin(),</div><div class=\"line\">        ]);</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">module</span>.<span class=\"keyword\">exports</span>.devtool = <span class=\"string\">'source-map'</span>;</div><div class=\"line\">    <span class=\"keyword\">module</span>.<span class=\"keyword\">exports</span>.devServer = &#123;</div><div class=\"line\">        port: <span class=\"number\">8080</span>,</div><div class=\"line\">        contentBase: <span class=\"string\">'./build'</span>,</div><div class=\"line\">        hot: <span class=\"keyword\">true</span>,</div><div class=\"line\">        historyApiFallback: <span class=\"keyword\">true</span>,</div><div class=\"line\">        publicPath: <span class=\"string\">\"\"</span>,</div><div class=\"line\">        stats: &#123;</div><div class=\"line\">            colors: <span class=\"keyword\">true</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        plugins: [</div><div class=\"line\">        <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</div><div class=\"line\">        ]</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"模块代码\"><a href=\"#模块代码\" class=\"headerlink\" title=\"模块代码\"></a>模块代码</h2><p>至此，我们已经完成了一个基本的webpack配置，接下来就是使用webpack构建代码了。我们定义的index模块的代码入口是index.js，在Index.js内通过require()方式引入不同的资源用于打包：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./style.less'</span>); <span class=\"comment\">//引入.less预处理文件</span></div><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./index.html'</span>); <span class=\"comment\">//引入同级目录的index.html文件</span></div></pre></td></tr></table></figure></p>\n<p>然后，执行”npm run dev”即可查看本地环境的静态资源效果。demo项目的完整代码可以<a href=\"https://github.com/hugzh/webpack-simple-demo\">查看github</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>webpack的零碎知识点还有很多，这里只是根据自己的学习心得搭建出来的简单构建环境。目前的构建还是不够灵活强大的，后面的时间我会继续探索结合gulp定制的webpack构建工具，在当前构建的基础上搭建一套更加完善的构建工具。</p>\n<p>本文出自橙乡果汁的博客(<a href=\"http://blog.hugzh.com/2016/05/02/webpack%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97-%E4%B8%80/\">blog.hugzh.com</a>)，转载请注明出处!</p>"},{"title":"关于软件工程的一点感想——以前端为例","date":"2016-03-14T13:17:52.000Z","_content":"最近在某知名创业公众号里面看到一篇抨击国内高校当前软件工程教育“名不副实”的文章([原文链接](http://36kr.com/p/5044247.html))。博主当时转发在朋友圈的时候是倾向于认同作者的观点，但是仔细想想，也不尽然。<!--more-->\n\n这篇文章的大体内容是这样的：作者提到当前高校的计算机教育与社会脱节，并且把“软件工程”当成是最脱节的课程。文章认为，教材上的“软件工程”是理论先行的，而现实中的“软件工程”是实践先行的；教材上的 “软件工程” 是单机环境的，现实的 “软件工程” 是网络环境的；教材上的 “软件工程” 侧重的是开发，实际的 “软件工程” 兼顾开发与维护。这几个观点虽然没有错，但是博主个人认为也不是全对，问题在哪里呢？\n\n首先，大学教材里面关于软件工程的概念一般是——“系统化、规范化的软件开发”，其主要目的是规范软件开发的流程。也就是说，“软件工程”这门课程本身就是一个方法论，它是一个指导规范而不是具体的编码技巧。由于自己目前是做前端的，那就拿“前端工程”这个名词来解释吧。2011年以前，“前端工程”是不存在的，当时的前端开发充其量仅仅是网页开发，一般由后台工程师或设计师负责完成。目前来说，按照概念，“前端工程”至少应该是要解决以下几个方面的问题：\n1、提供项目开发所需的一整套运行环境，这和IDE作用类似，由于前端开发的特殊性，这个“IDE”是一个集成了多种语言和工具的开发环境；\n2、资源管理，包括资源获取、依赖处理、实时更新、按需加载、公共模块管理等。这里也可以看成是组件化和模块化；\n3、打通研发链路的各个环节，debug、mock、proxy、test、build、deploy等，达到一次安装，自动打包的目的。\n4、解决前端性能问题，尤其是移动前端页面的性能优化，实现组件化开发。\n所以，一个典型的webapp项目目录是这样的( 注：此目录图来自[基于webpack搭建前端工程解决方案探索](https://github.com/chemdemo/chemdemo.github.io/issues/10))：\n```\n- webapp/               # webapp根目录\n  - src/                # 开发目录\n    + css/              # css资源目录\n    + img/              # webapp图片资源目录\n    - js/               # webapp js&jsx资源目录\n      - components/     # 标准组件存放目录\n          - foo/        # 组件foo\n            + css/      # 组件foo的样式\n            + js/       # 组件foo的逻辑\n            + tmpl/     # 组件foo的模板\n            index.js    # 组件foo的入口\n          + bar/        # 组件bar\n      + lib/            # 第三方纯js库\n      ...               # 根据项目需要任意添加的代码目录\n    + tmpl/             # webapp前端模板资源目录\n    a.html              # webapp入口文件a\n    b.html              # webapp入口文件b\n  - assets/             # 编译输出目录，即发布目录\n    + js/               # 编译输出的js目录\n    + img/              # 编译输出的图片目录\n    + css/              # 编译输出的css目录\n    a.html              # 编译输出的入口a\n    b.html              # 编译处理后的入口b\n  + mock/               # 假数据目录\n  app.js                # 本地server入口\n  routes.js             # 本地路由配置\n  webpack.config.js     # webpack配置文件\n  gulpfile.js           # gulp任务配置\n  package.json          # 项目配置\n  README.md             # 项目说明\n```\n这个目录是由开发环境(配置工具)自动生成的，这个项目目录基本上体现了资源管理、模块管理、调试、打包、发布这几个重要环节。\n\n那么回到本文主题，按照开头所提文章的观点，因为高校课程“软件工程”名不副实，所以按照“软件工程” 教的去做，多半开发不出来软件（或者说，开发不出好的软件）。但问题是，“软件工程”本身就是一个开发指导原则，一个软件是否能开发完成不是仅仅靠这个指导原则就可以实现的。需要工程师在“软件工程”的指引下，使用（搭建）一套完整的开发工具，通过编码来实现最终的项目成果。所以，从这个角度来讲，高校开设的“软件工程”课程并不算脱节，只是这个课程的教学成果并不能直接体现在学生的编码能力上面。\n\n至于说，教材上的“软件工程”是理论先行的，而现实中的“软件工程”是实践先行的；教材上的 “软件工程” 是单机环境的，现实的 “软件工程” 是网络环境的；教材上的 “软件工程” 侧重的是开发，实际的 “软件工程” 兼顾开发与维护。那是因为高校的课程由于本身环境的局限性，导致了软件工程的方法论仅仅存在于理论指导层面，而不像实际开发当中，程序员每天都在这套流程的限制下重复自己的工作。所以归根结底，问题的根源是高校的课程并不能很好地与项目实践相结合，而不能单单归咎于教学与社会脱节。\n\n当然，文章所提的教学与业界脱节的问题确实是当前高校软件工程相关专业存在的最大弊端。像数据结构与算法、C语言基础、计算机网络这样的基础课程并没有太明显的问题。但是为了更好地培养有价值的软件开发人才，高校应该想办法将更多的企业实践机会提供给学生，并且根据业界技术动向及时开设相关的技术课程。在这一方面，博主认为自己所在的华南地区某著名综合院校还是做得不错的，不少选修课程都是与最新的技术相关。另外，从学生的角度来讲，也要提高自己的自学能力和效率，关注最新的业界动态，及早完善自己的技术栈。但是能做到这样子的学生，基本也就是学校大神级的存在了。\n\n\n","source":"_posts/关于软件工程的一点感想——以前端为例.md","raw":"title: 关于软件工程的一点感想——以前端为例\ndate: 2016-03-14 21:17:52\ntags: \n    - 前端杂谈\ncategories: \n    - 杂谈\n---\n最近在某知名创业公众号里面看到一篇抨击国内高校当前软件工程教育“名不副实”的文章([原文链接](http://36kr.com/p/5044247.html))。博主当时转发在朋友圈的时候是倾向于认同作者的观点，但是仔细想想，也不尽然。<!--more-->\n\n这篇文章的大体内容是这样的：作者提到当前高校的计算机教育与社会脱节，并且把“软件工程”当成是最脱节的课程。文章认为，教材上的“软件工程”是理论先行的，而现实中的“软件工程”是实践先行的；教材上的 “软件工程” 是单机环境的，现实的 “软件工程” 是网络环境的；教材上的 “软件工程” 侧重的是开发，实际的 “软件工程” 兼顾开发与维护。这几个观点虽然没有错，但是博主个人认为也不是全对，问题在哪里呢？\n\n首先，大学教材里面关于软件工程的概念一般是——“系统化、规范化的软件开发”，其主要目的是规范软件开发的流程。也就是说，“软件工程”这门课程本身就是一个方法论，它是一个指导规范而不是具体的编码技巧。由于自己目前是做前端的，那就拿“前端工程”这个名词来解释吧。2011年以前，“前端工程”是不存在的，当时的前端开发充其量仅仅是网页开发，一般由后台工程师或设计师负责完成。目前来说，按照概念，“前端工程”至少应该是要解决以下几个方面的问题：\n1、提供项目开发所需的一整套运行环境，这和IDE作用类似，由于前端开发的特殊性，这个“IDE”是一个集成了多种语言和工具的开发环境；\n2、资源管理，包括资源获取、依赖处理、实时更新、按需加载、公共模块管理等。这里也可以看成是组件化和模块化；\n3、打通研发链路的各个环节，debug、mock、proxy、test、build、deploy等，达到一次安装，自动打包的目的。\n4、解决前端性能问题，尤其是移动前端页面的性能优化，实现组件化开发。\n所以，一个典型的webapp项目目录是这样的( 注：此目录图来自[基于webpack搭建前端工程解决方案探索](https://github.com/chemdemo/chemdemo.github.io/issues/10))：\n```\n- webapp/               # webapp根目录\n  - src/                # 开发目录\n    + css/              # css资源目录\n    + img/              # webapp图片资源目录\n    - js/               # webapp js&jsx资源目录\n      - components/     # 标准组件存放目录\n          - foo/        # 组件foo\n            + css/      # 组件foo的样式\n            + js/       # 组件foo的逻辑\n            + tmpl/     # 组件foo的模板\n            index.js    # 组件foo的入口\n          + bar/        # 组件bar\n      + lib/            # 第三方纯js库\n      ...               # 根据项目需要任意添加的代码目录\n    + tmpl/             # webapp前端模板资源目录\n    a.html              # webapp入口文件a\n    b.html              # webapp入口文件b\n  - assets/             # 编译输出目录，即发布目录\n    + js/               # 编译输出的js目录\n    + img/              # 编译输出的图片目录\n    + css/              # 编译输出的css目录\n    a.html              # 编译输出的入口a\n    b.html              # 编译处理后的入口b\n  + mock/               # 假数据目录\n  app.js                # 本地server入口\n  routes.js             # 本地路由配置\n  webpack.config.js     # webpack配置文件\n  gulpfile.js           # gulp任务配置\n  package.json          # 项目配置\n  README.md             # 项目说明\n```\n这个目录是由开发环境(配置工具)自动生成的，这个项目目录基本上体现了资源管理、模块管理、调试、打包、发布这几个重要环节。\n\n那么回到本文主题，按照开头所提文章的观点，因为高校课程“软件工程”名不副实，所以按照“软件工程” 教的去做，多半开发不出来软件（或者说，开发不出好的软件）。但问题是，“软件工程”本身就是一个开发指导原则，一个软件是否能开发完成不是仅仅靠这个指导原则就可以实现的。需要工程师在“软件工程”的指引下，使用（搭建）一套完整的开发工具，通过编码来实现最终的项目成果。所以，从这个角度来讲，高校开设的“软件工程”课程并不算脱节，只是这个课程的教学成果并不能直接体现在学生的编码能力上面。\n\n至于说，教材上的“软件工程”是理论先行的，而现实中的“软件工程”是实践先行的；教材上的 “软件工程” 是单机环境的，现实的 “软件工程” 是网络环境的；教材上的 “软件工程” 侧重的是开发，实际的 “软件工程” 兼顾开发与维护。那是因为高校的课程由于本身环境的局限性，导致了软件工程的方法论仅仅存在于理论指导层面，而不像实际开发当中，程序员每天都在这套流程的限制下重复自己的工作。所以归根结底，问题的根源是高校的课程并不能很好地与项目实践相结合，而不能单单归咎于教学与社会脱节。\n\n当然，文章所提的教学与业界脱节的问题确实是当前高校软件工程相关专业存在的最大弊端。像数据结构与算法、C语言基础、计算机网络这样的基础课程并没有太明显的问题。但是为了更好地培养有价值的软件开发人才，高校应该想办法将更多的企业实践机会提供给学生，并且根据业界技术动向及时开设相关的技术课程。在这一方面，博主认为自己所在的华南地区某著名综合院校还是做得不错的，不少选修课程都是与最新的技术相关。另外，从学生的角度来讲，也要提高自己的自学能力和效率，关注最新的业界动态，及早完善自己的技术栈。但是能做到这样子的学生，基本也就是学校大神级的存在了。\n\n\n","slug":"关于软件工程的一点感想——以前端为例","published":1,"updated":"2016-08-13T03:08:44.568Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqtry002h7kau5pia48s9","content":"<p>最近在某知名创业公众号里面看到一篇抨击国内高校当前软件工程教育“名不副实”的文章(<a href=\"http://36kr.com/p/5044247.html\" target=\"_blank\" rel=\"external\">原文链接</a>)。博主当时转发在朋友圈的时候是倾向于认同作者的观点，但是仔细想想，也不尽然。<a id=\"more\"></a></p>\n<p>这篇文章的大体内容是这样的：作者提到当前高校的计算机教育与社会脱节，并且把“软件工程”当成是最脱节的课程。文章认为，教材上的“软件工程”是理论先行的，而现实中的“软件工程”是实践先行的；教材上的 “软件工程” 是单机环境的，现实的 “软件工程” 是网络环境的；教材上的 “软件工程” 侧重的是开发，实际的 “软件工程” 兼顾开发与维护。这几个观点虽然没有错，但是博主个人认为也不是全对，问题在哪里呢？</p>\n<p>首先，大学教材里面关于软件工程的概念一般是——“系统化、规范化的软件开发”，其主要目的是规范软件开发的流程。也就是说，“软件工程”这门课程本身就是一个方法论，它是一个指导规范而不是具体的编码技巧。由于自己目前是做前端的，那就拿“前端工程”这个名词来解释吧。2011年以前，“前端工程”是不存在的，当时的前端开发充其量仅仅是网页开发，一般由后台工程师或设计师负责完成。目前来说，按照概念，“前端工程”至少应该是要解决以下几个方面的问题：<br>1、提供项目开发所需的一整套运行环境，这和IDE作用类似，由于前端开发的特殊性，这个“IDE”是一个集成了多种语言和工具的开发环境；<br>2、资源管理，包括资源获取、依赖处理、实时更新、按需加载、公共模块管理等。这里也可以看成是组件化和模块化；<br>3、打通研发链路的各个环节，debug、mock、proxy、test、build、deploy等，达到一次安装，自动打包的目的。<br>4、解决前端性能问题，尤其是移动前端页面的性能优化，实现组件化开发。<br>所以，一个典型的webapp项目目录是这样的( 注：此目录图来自<a href=\"https://github.com/chemdemo/chemdemo.github.io/issues/10\" target=\"_blank\" rel=\"external\">基于webpack搭建前端工程解决方案探索</a>)：<br><figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">- webapp/               <span class=\"comment\"># webapp根目录</span></div><div class=\"line\">  - src/                <span class=\"comment\"># 开发目录</span></div><div class=\"line\">    + css/              <span class=\"comment\"># css资源目录</span></div><div class=\"line\">    + img/              <span class=\"comment\"># webapp图片资源目录</span></div><div class=\"line\">    - js/               <span class=\"comment\"># webapp js&amp;jsx资源目录</span></div><div class=\"line\">      - components/     <span class=\"comment\"># 标准组件存放目录</span></div><div class=\"line\">          - foo/        <span class=\"comment\"># 组件foo</span></div><div class=\"line\">            + css/      <span class=\"comment\"># 组件foo的样式</span></div><div class=\"line\">            + js/       <span class=\"comment\"># 组件foo的逻辑</span></div><div class=\"line\">            + tmpl/     <span class=\"comment\"># 组件foo的模板</span></div><div class=\"line\">            index.js    <span class=\"comment\"># 组件foo的入口</span></div><div class=\"line\">          + bar/        <span class=\"comment\"># 组件bar</span></div><div class=\"line\">      + <span class=\"class\"><span class=\"keyword\">lib</span>/            <span class=\"comment\"># 第三方纯js库</span></span></div><div class=\"line\">      ...               <span class=\"comment\"># 根据项目需要任意添加的代码目录</span></div><div class=\"line\">    + tmpl/             <span class=\"comment\"># webapp前端模板资源目录</span></div><div class=\"line\">    a.html              <span class=\"comment\"># webapp入口文件a</span></div><div class=\"line\">    b.html              <span class=\"comment\"># webapp入口文件b</span></div><div class=\"line\">  - assets/             <span class=\"comment\"># 编译输出目录，即发布目录</span></div><div class=\"line\">    + js/               <span class=\"comment\"># 编译输出的js目录</span></div><div class=\"line\">    + img/              <span class=\"comment\"># 编译输出的图片目录</span></div><div class=\"line\">    + css/              <span class=\"comment\"># 编译输出的css目录</span></div><div class=\"line\">    a.html              <span class=\"comment\"># 编译输出的入口a</span></div><div class=\"line\">    b.html              <span class=\"comment\"># 编译处理后的入口b</span></div><div class=\"line\">  + mock/               <span class=\"comment\"># 假数据目录</span></div><div class=\"line\">  app.js                <span class=\"comment\"># 本地server入口</span></div><div class=\"line\">  routes.js             <span class=\"comment\"># 本地路由配置</span></div><div class=\"line\">  webpack.config.js     <span class=\"comment\"># webpack配置文件</span></div><div class=\"line\">  gulpfile.js           <span class=\"comment\"># gulp任务配置</span></div><div class=\"line\">  package.json          <span class=\"comment\"># 项目配置</span></div><div class=\"line\">  README.md             <span class=\"comment\"># 项目说明</span></div></pre></td></tr></table></figure></p>\n<p>这个目录是由开发环境(配置工具)自动生成的，这个项目目录基本上体现了资源管理、模块管理、调试、打包、发布这几个重要环节。</p>\n<p>那么回到本文主题，按照开头所提文章的观点，因为高校课程“软件工程”名不副实，所以按照“软件工程” 教的去做，多半开发不出来软件（或者说，开发不出好的软件）。但问题是，“软件工程”本身就是一个开发指导原则，一个软件是否能开发完成不是仅仅靠这个指导原则就可以实现的。需要工程师在“软件工程”的指引下，使用（搭建）一套完整的开发工具，通过编码来实现最终的项目成果。所以，从这个角度来讲，高校开设的“软件工程”课程并不算脱节，只是这个课程的教学成果并不能直接体现在学生的编码能力上面。</p>\n<p>至于说，教材上的“软件工程”是理论先行的，而现实中的“软件工程”是实践先行的；教材上的 “软件工程” 是单机环境的，现实的 “软件工程” 是网络环境的；教材上的 “软件工程” 侧重的是开发，实际的 “软件工程” 兼顾开发与维护。那是因为高校的课程由于本身环境的局限性，导致了软件工程的方法论仅仅存在于理论指导层面，而不像实际开发当中，程序员每天都在这套流程的限制下重复自己的工作。所以归根结底，问题的根源是高校的课程并不能很好地与项目实践相结合，而不能单单归咎于教学与社会脱节。</p>\n<p>当然，文章所提的教学与业界脱节的问题确实是当前高校软件工程相关专业存在的最大弊端。像数据结构与算法、C语言基础、计算机网络这样的基础课程并没有太明显的问题。但是为了更好地培养有价值的软件开发人才，高校应该想办法将更多的企业实践机会提供给学生，并且根据业界技术动向及时开设相关的技术课程。在这一方面，博主认为自己所在的华南地区某著名综合院校还是做得不错的，不少选修课程都是与最新的技术相关。另外，从学生的角度来讲，也要提高自己的自学能力和效率，关注最新的业界动态，及早完善自己的技术栈。但是能做到这样子的学生，基本也就是学校大神级的存在了。</p>\n","excerpt":"<p>最近在某知名创业公众号里面看到一篇抨击国内高校当前软件工程教育“名不副实”的文章(<a href=\"http://36kr.com/p/5044247.html\">原文链接</a>)。博主当时转发在朋友圈的时候是倾向于认同作者的观点，但是仔细想想，也不尽然。","more":"</p>\n<p>这篇文章的大体内容是这样的：作者提到当前高校的计算机教育与社会脱节，并且把“软件工程”当成是最脱节的课程。文章认为，教材上的“软件工程”是理论先行的，而现实中的“软件工程”是实践先行的；教材上的 “软件工程” 是单机环境的，现实的 “软件工程” 是网络环境的；教材上的 “软件工程” 侧重的是开发，实际的 “软件工程” 兼顾开发与维护。这几个观点虽然没有错，但是博主个人认为也不是全对，问题在哪里呢？</p>\n<p>首先，大学教材里面关于软件工程的概念一般是——“系统化、规范化的软件开发”，其主要目的是规范软件开发的流程。也就是说，“软件工程”这门课程本身就是一个方法论，它是一个指导规范而不是具体的编码技巧。由于自己目前是做前端的，那就拿“前端工程”这个名词来解释吧。2011年以前，“前端工程”是不存在的，当时的前端开发充其量仅仅是网页开发，一般由后台工程师或设计师负责完成。目前来说，按照概念，“前端工程”至少应该是要解决以下几个方面的问题：<br>1、提供项目开发所需的一整套运行环境，这和IDE作用类似，由于前端开发的特殊性，这个“IDE”是一个集成了多种语言和工具的开发环境；<br>2、资源管理，包括资源获取、依赖处理、实时更新、按需加载、公共模块管理等。这里也可以看成是组件化和模块化；<br>3、打通研发链路的各个环节，debug、mock、proxy、test、build、deploy等，达到一次安装，自动打包的目的。<br>4、解决前端性能问题，尤其是移动前端页面的性能优化，实现组件化开发。<br>所以，一个典型的webapp项目目录是这样的( 注：此目录图来自<a href=\"https://github.com/chemdemo/chemdemo.github.io/issues/10\">基于webpack搭建前端工程解决方案探索</a>)：<br><figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">- webapp/               <span class=\"comment\"># webapp根目录</span></div><div class=\"line\">  - src/                <span class=\"comment\"># 开发目录</span></div><div class=\"line\">    + css/              <span class=\"comment\"># css资源目录</span></div><div class=\"line\">    + img/              <span class=\"comment\"># webapp图片资源目录</span></div><div class=\"line\">    - js/               <span class=\"comment\"># webapp js&amp;jsx资源目录</span></div><div class=\"line\">      - components/     <span class=\"comment\"># 标准组件存放目录</span></div><div class=\"line\">          - foo/        <span class=\"comment\"># 组件foo</span></div><div class=\"line\">            + css/      <span class=\"comment\"># 组件foo的样式</span></div><div class=\"line\">            + js/       <span class=\"comment\"># 组件foo的逻辑</span></div><div class=\"line\">            + tmpl/     <span class=\"comment\"># 组件foo的模板</span></div><div class=\"line\">            index.js    <span class=\"comment\"># 组件foo的入口</span></div><div class=\"line\">          + bar/        <span class=\"comment\"># 组件bar</span></div><div class=\"line\">      + <span class=\"class\"><span class=\"keyword\">lib</span>/            <span class=\"comment\"># 第三方纯js库</span></span></div><div class=\"line\">      ...               <span class=\"comment\"># 根据项目需要任意添加的代码目录</span></div><div class=\"line\">    + tmpl/             <span class=\"comment\"># webapp前端模板资源目录</span></div><div class=\"line\">    a.html              <span class=\"comment\"># webapp入口文件a</span></div><div class=\"line\">    b.html              <span class=\"comment\"># webapp入口文件b</span></div><div class=\"line\">  - assets/             <span class=\"comment\"># 编译输出目录，即发布目录</span></div><div class=\"line\">    + js/               <span class=\"comment\"># 编译输出的js目录</span></div><div class=\"line\">    + img/              <span class=\"comment\"># 编译输出的图片目录</span></div><div class=\"line\">    + css/              <span class=\"comment\"># 编译输出的css目录</span></div><div class=\"line\">    a.html              <span class=\"comment\"># 编译输出的入口a</span></div><div class=\"line\">    b.html              <span class=\"comment\"># 编译处理后的入口b</span></div><div class=\"line\">  + mock/               <span class=\"comment\"># 假数据目录</span></div><div class=\"line\">  app.js                <span class=\"comment\"># 本地server入口</span></div><div class=\"line\">  routes.js             <span class=\"comment\"># 本地路由配置</span></div><div class=\"line\">  webpack.config.js     <span class=\"comment\"># webpack配置文件</span></div><div class=\"line\">  gulpfile.js           <span class=\"comment\"># gulp任务配置</span></div><div class=\"line\">  package.json          <span class=\"comment\"># 项目配置</span></div><div class=\"line\">  README.md             <span class=\"comment\"># 项目说明</span></div></pre></td></tr></table></figure></p>\n<p>这个目录是由开发环境(配置工具)自动生成的，这个项目目录基本上体现了资源管理、模块管理、调试、打包、发布这几个重要环节。</p>\n<p>那么回到本文主题，按照开头所提文章的观点，因为高校课程“软件工程”名不副实，所以按照“软件工程” 教的去做，多半开发不出来软件（或者说，开发不出好的软件）。但问题是，“软件工程”本身就是一个开发指导原则，一个软件是否能开发完成不是仅仅靠这个指导原则就可以实现的。需要工程师在“软件工程”的指引下，使用（搭建）一套完整的开发工具，通过编码来实现最终的项目成果。所以，从这个角度来讲，高校开设的“软件工程”课程并不算脱节，只是这个课程的教学成果并不能直接体现在学生的编码能力上面。</p>\n<p>至于说，教材上的“软件工程”是理论先行的，而现实中的“软件工程”是实践先行的；教材上的 “软件工程” 是单机环境的，现实的 “软件工程” 是网络环境的；教材上的 “软件工程” 侧重的是开发，实际的 “软件工程” 兼顾开发与维护。那是因为高校的课程由于本身环境的局限性，导致了软件工程的方法论仅仅存在于理论指导层面，而不像实际开发当中，程序员每天都在这套流程的限制下重复自己的工作。所以归根结底，问题的根源是高校的课程并不能很好地与项目实践相结合，而不能单单归咎于教学与社会脱节。</p>\n<p>当然，文章所提的教学与业界脱节的问题确实是当前高校软件工程相关专业存在的最大弊端。像数据结构与算法、C语言基础、计算机网络这样的基础课程并没有太明显的问题。但是为了更好地培养有价值的软件开发人才，高校应该想办法将更多的企业实践机会提供给学生，并且根据业界技术动向及时开设相关的技术课程。在这一方面，博主认为自己所在的华南地区某著名综合院校还是做得不错的，不少选修课程都是与最新的技术相关。另外，从学生的角度来讲，也要提高自己的自学能力和效率，关注最新的业界动态，及早完善自己的技术栈。但是能做到这样子的学生，基本也就是学校大神级的存在了。</p>"},{"title":"React.js那些事(core篇)","date":"2015-10-07T08:03:42.000Z","_content":"\n这一篇主要讲讲React.js虚拟DOM的底层相关，主要是自己学习官方文档的Reconciliation部分的一些总结。我们都知道，React的虚拟DOM是非常高效的。那么，React底层是使用什么样的算法实现DOM的高效渲染呢？\n<!--more-->\n# 机制\nReact.js在内存里的DOM树操作是子树的替换，也就是用变化之后的子树整个代替原来的子树，而不是在内存里面调整子树。从算法的角度来说，生成最少的将一颗树形结构转换成另一颗树形结构的操作，其最优算法的复杂度是 O(n3)，n是树中节点的总数。所以React尝试从另一个方面入手，使用试探的方法。首先需要达成两点假设：\n1、拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。\n2、可以为元素提供一个唯一的标志，该元素在不同的渲染过程中保持不变。实际上，这些假设会使在几乎所有的应用场景下，应用变得出奇地快。\n\n# 详细\n## diffing算法\n为了实现子树的替换，首先必须要检查两棵树的差异。React的处理机制分三种类型处理。\n![示例1](http://huguozhi-media.stor.sinaapp.com/mygitio%2F1.png)\n### 不同的节点类型\n节点类型不同，React 将会把它们当做两个不同的子树，移除之前的那棵子树，然后创建并插入第二棵子树。React不会尝试计算出该渲染什么，仅会从 DOM中移除之前的节点，然后插入新的节点。碰到不一样的组件结构，React将重新创建树形结构，而不是耗费时间去尝试匹配这两个树形结构。所以，React的虚拟DOM是非常高效的。\n\n### DOM节点\nDOM节点是相同类型的，比较两个DOM节点的时候，首先查看属性。对随着时间发生了变化的属性进行更新，然后递归检查所有子级的属性。\n\n### 自定义组件\n我们决定两个自定义组件是相同的。因为组件是状态化的，不可能每次状态改变都要创建一个新的组件实例。React 利用新组件上的所有属性，然后在之前的组件实例上调用 component[Will/Did]ReceiveProps()。现在，之前的组件就是可操作了的。它的 render() 方法被调用，然后差异算法重新比较新的状态和上一次的状态。\n\n## 子级优化差异\nReact采用的方法是同时遍历两个子级列表，当发现差异的时候，就产生一次 DOM 修改。例如我们如果需要在组件末尾添加一个元素，那么如果两个子级（原有的和新添加的）是相同元素，则直接修改已有子级元素的文本内容，然后在后面插入一个新的子级节点。\n另外，React引入一个唯一的key属性，给每一个子级一个键值，用于和以后变化的组件进行比较。这样，React就能够检测出节点插入、移除和替换，并且借助哈希表使节点移动复杂度为 O(n)。\n![示例1](http://huguozhi-media.stor.sinaapp.com/mygitio%2F2.png)\n\n# 本篇结语\n这一篇主要是介绍React的渲染机制，虚拟dom是React.js的核心。想要更多地了解React.js的朋友可以进入[官方文档](http://reactjs.cn/)进行深入学习。\n\n","source":"_posts/2015-10-07-React-js那些事-core篇.md","raw":"title: React.js那些事(core篇)\ndate: 2015-10-07 16:03:42\ntags:\n    - React\n    - virtual dom\ncategories:\n    - 前端开发\n---\n\n这一篇主要讲讲React.js虚拟DOM的底层相关，主要是自己学习官方文档的Reconciliation部分的一些总结。我们都知道，React的虚拟DOM是非常高效的。那么，React底层是使用什么样的算法实现DOM的高效渲染呢？\n<!--more-->\n# 机制\nReact.js在内存里的DOM树操作是子树的替换，也就是用变化之后的子树整个代替原来的子树，而不是在内存里面调整子树。从算法的角度来说，生成最少的将一颗树形结构转换成另一颗树形结构的操作，其最优算法的复杂度是 O(n3)，n是树中节点的总数。所以React尝试从另一个方面入手，使用试探的方法。首先需要达成两点假设：\n1、拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。\n2、可以为元素提供一个唯一的标志，该元素在不同的渲染过程中保持不变。实际上，这些假设会使在几乎所有的应用场景下，应用变得出奇地快。\n\n# 详细\n## diffing算法\n为了实现子树的替换，首先必须要检查两棵树的差异。React的处理机制分三种类型处理。\n![示例1](http://huguozhi-media.stor.sinaapp.com/mygitio%2F1.png)\n### 不同的节点类型\n节点类型不同，React 将会把它们当做两个不同的子树，移除之前的那棵子树，然后创建并插入第二棵子树。React不会尝试计算出该渲染什么，仅会从 DOM中移除之前的节点，然后插入新的节点。碰到不一样的组件结构，React将重新创建树形结构，而不是耗费时间去尝试匹配这两个树形结构。所以，React的虚拟DOM是非常高效的。\n\n### DOM节点\nDOM节点是相同类型的，比较两个DOM节点的时候，首先查看属性。对随着时间发生了变化的属性进行更新，然后递归检查所有子级的属性。\n\n### 自定义组件\n我们决定两个自定义组件是相同的。因为组件是状态化的，不可能每次状态改变都要创建一个新的组件实例。React 利用新组件上的所有属性，然后在之前的组件实例上调用 component[Will/Did]ReceiveProps()。现在，之前的组件就是可操作了的。它的 render() 方法被调用，然后差异算法重新比较新的状态和上一次的状态。\n\n## 子级优化差异\nReact采用的方法是同时遍历两个子级列表，当发现差异的时候，就产生一次 DOM 修改。例如我们如果需要在组件末尾添加一个元素，那么如果两个子级（原有的和新添加的）是相同元素，则直接修改已有子级元素的文本内容，然后在后面插入一个新的子级节点。\n另外，React引入一个唯一的key属性，给每一个子级一个键值，用于和以后变化的组件进行比较。这样，React就能够检测出节点插入、移除和替换，并且借助哈希表使节点移动复杂度为 O(n)。\n![示例1](http://huguozhi-media.stor.sinaapp.com/mygitio%2F2.png)\n\n# 本篇结语\n这一篇主要是介绍React的渲染机制，虚拟dom是React.js的核心。想要更多地了解React.js的朋友可以进入[官方文档](http://reactjs.cn/)进行深入学习。\n\n","slug":"2015-10-07-React-js那些事-core篇","published":1,"updated":"2016-08-13T03:08:44.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirsyqts0002k7kauqw1fbbr9","content":"<p>这一篇主要讲讲React.js虚拟DOM的底层相关，主要是自己学习官方文档的Reconciliation部分的一些总结。我们都知道，React的虚拟DOM是非常高效的。那么，React底层是使用什么样的算法实现DOM的高效渲染呢？<br><a id=\"more\"></a></p>\n<h1 id=\"机制\"><a href=\"#机制\" class=\"headerlink\" title=\"机制\"></a>机制</h1><p>React.js在内存里的DOM树操作是子树的替换，也就是用变化之后的子树整个代替原来的子树，而不是在内存里面调整子树。从算法的角度来说，生成最少的将一颗树形结构转换成另一颗树形结构的操作，其最优算法的复杂度是 O(n3)，n是树中节点的总数。所以React尝试从另一个方面入手，使用试探的方法。首先需要达成两点假设：<br>1、拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。<br>2、可以为元素提供一个唯一的标志，该元素在不同的渲染过程中保持不变。实际上，这些假设会使在几乎所有的应用场景下，应用变得出奇地快。</p>\n<h1 id=\"详细\"><a href=\"#详细\" class=\"headerlink\" title=\"详细\"></a>详细</h1><h2 id=\"diffing算法\"><a href=\"#diffing算法\" class=\"headerlink\" title=\"diffing算法\"></a>diffing算法</h2><p>为了实现子树的替换，首先必须要检查两棵树的差异。React的处理机制分三种类型处理。<br><img src=\"http://huguozhi-media.stor.sinaapp.com/mygitio%2F1.png\" alt=\"示例1\"></p>\n<h3 id=\"不同的节点类型\"><a href=\"#不同的节点类型\" class=\"headerlink\" title=\"不同的节点类型\"></a>不同的节点类型</h3><p>节点类型不同，React 将会把它们当做两个不同的子树，移除之前的那棵子树，然后创建并插入第二棵子树。React不会尝试计算出该渲染什么，仅会从 DOM中移除之前的节点，然后插入新的节点。碰到不一样的组件结构，React将重新创建树形结构，而不是耗费时间去尝试匹配这两个树形结构。所以，React的虚拟DOM是非常高效的。</p>\n<h3 id=\"DOM节点\"><a href=\"#DOM节点\" class=\"headerlink\" title=\"DOM节点\"></a>DOM节点</h3><p>DOM节点是相同类型的，比较两个DOM节点的时候，首先查看属性。对随着时间发生了变化的属性进行更新，然后递归检查所有子级的属性。</p>\n<h3 id=\"自定义组件\"><a href=\"#自定义组件\" class=\"headerlink\" title=\"自定义组件\"></a>自定义组件</h3><p>我们决定两个自定义组件是相同的。因为组件是状态化的，不可能每次状态改变都要创建一个新的组件实例。React 利用新组件上的所有属性，然后在之前的组件实例上调用 component[Will/Did]ReceiveProps()。现在，之前的组件就是可操作了的。它的 render() 方法被调用，然后差异算法重新比较新的状态和上一次的状态。</p>\n<h2 id=\"子级优化差异\"><a href=\"#子级优化差异\" class=\"headerlink\" title=\"子级优化差异\"></a>子级优化差异</h2><p>React采用的方法是同时遍历两个子级列表，当发现差异的时候，就产生一次 DOM 修改。例如我们如果需要在组件末尾添加一个元素，那么如果两个子级（原有的和新添加的）是相同元素，则直接修改已有子级元素的文本内容，然后在后面插入一个新的子级节点。<br>另外，React引入一个唯一的key属性，给每一个子级一个键值，用于和以后变化的组件进行比较。这样，React就能够检测出节点插入、移除和替换，并且借助哈希表使节点移动复杂度为 O(n)。<br><img src=\"http://huguozhi-media.stor.sinaapp.com/mygitio%2F2.png\" alt=\"示例1\"></p>\n<h1 id=\"本篇结语\"><a href=\"#本篇结语\" class=\"headerlink\" title=\"本篇结语\"></a>本篇结语</h1><p>这一篇主要是介绍React的渲染机制，虚拟dom是React.js的核心。想要更多地了解React.js的朋友可以进入<a href=\"http://reactjs.cn/\" target=\"_blank\" rel=\"external\">官方文档</a>进行深入学习。</p>\n","excerpt":"<p>这一篇主要讲讲React.js虚拟DOM的底层相关，主要是自己学习官方文档的Reconciliation部分的一些总结。我们都知道，React的虚拟DOM是非常高效的。那么，React底层是使用什么样的算法实现DOM的高效渲染呢？<br>","more":"</p>\n<h1 id=\"机制\"><a href=\"#机制\" class=\"headerlink\" title=\"机制\"></a>机制</h1><p>React.js在内存里的DOM树操作是子树的替换，也就是用变化之后的子树整个代替原来的子树，而不是在内存里面调整子树。从算法的角度来说，生成最少的将一颗树形结构转换成另一颗树形结构的操作，其最优算法的复杂度是 O(n3)，n是树中节点的总数。所以React尝试从另一个方面入手，使用试探的方法。首先需要达成两点假设：<br>1、拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。<br>2、可以为元素提供一个唯一的标志，该元素在不同的渲染过程中保持不变。实际上，这些假设会使在几乎所有的应用场景下，应用变得出奇地快。</p>\n<h1 id=\"详细\"><a href=\"#详细\" class=\"headerlink\" title=\"详细\"></a>详细</h1><h2 id=\"diffing算法\"><a href=\"#diffing算法\" class=\"headerlink\" title=\"diffing算法\"></a>diffing算法</h2><p>为了实现子树的替换，首先必须要检查两棵树的差异。React的处理机制分三种类型处理。<br><img src=\"http://huguozhi-media.stor.sinaapp.com/mygitio%2F1.png\" alt=\"示例1\"></p>\n<h3 id=\"不同的节点类型\"><a href=\"#不同的节点类型\" class=\"headerlink\" title=\"不同的节点类型\"></a>不同的节点类型</h3><p>节点类型不同，React 将会把它们当做两个不同的子树，移除之前的那棵子树，然后创建并插入第二棵子树。React不会尝试计算出该渲染什么，仅会从 DOM中移除之前的节点，然后插入新的节点。碰到不一样的组件结构，React将重新创建树形结构，而不是耗费时间去尝试匹配这两个树形结构。所以，React的虚拟DOM是非常高效的。</p>\n<h3 id=\"DOM节点\"><a href=\"#DOM节点\" class=\"headerlink\" title=\"DOM节点\"></a>DOM节点</h3><p>DOM节点是相同类型的，比较两个DOM节点的时候，首先查看属性。对随着时间发生了变化的属性进行更新，然后递归检查所有子级的属性。</p>\n<h3 id=\"自定义组件\"><a href=\"#自定义组件\" class=\"headerlink\" title=\"自定义组件\"></a>自定义组件</h3><p>我们决定两个自定义组件是相同的。因为组件是状态化的，不可能每次状态改变都要创建一个新的组件实例。React 利用新组件上的所有属性，然后在之前的组件实例上调用 component[Will/Did]ReceiveProps()。现在，之前的组件就是可操作了的。它的 render() 方法被调用，然后差异算法重新比较新的状态和上一次的状态。</p>\n<h2 id=\"子级优化差异\"><a href=\"#子级优化差异\" class=\"headerlink\" title=\"子级优化差异\"></a>子级优化差异</h2><p>React采用的方法是同时遍历两个子级列表，当发现差异的时候，就产生一次 DOM 修改。例如我们如果需要在组件末尾添加一个元素，那么如果两个子级（原有的和新添加的）是相同元素，则直接修改已有子级元素的文本内容，然后在后面插入一个新的子级节点。<br>另外，React引入一个唯一的key属性，给每一个子级一个键值，用于和以后变化的组件进行比较。这样，React就能够检测出节点插入、移除和替换，并且借助哈希表使节点移动复杂度为 O(n)。<br><img src=\"http://huguozhi-media.stor.sinaapp.com/mygitio%2F2.png\" alt=\"示例1\"></p>\n<h1 id=\"本篇结语\"><a href=\"#本篇结语\" class=\"headerlink\" title=\"本篇结语\"></a>本篇结语</h1><p>这一篇主要是介绍React的渲染机制，虚拟dom是React.js的核心。想要更多地了解React.js的朋友可以进入<a href=\"http://reactjs.cn/\">官方文档</a>进行深入学习。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cirsyqtqg00057kaulycxjw51","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtqm000a7kaut7mo8jjs"},{"post_id":"cirsyqtq500007kaulmqzviwd","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtqp000e7kau6oodamff"},{"post_id":"cirsyqtql00097kau18lmfrcf","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtqq000h7kau2nzoimdp"},{"post_id":"cirsyqtq900017kausn05etr6","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtqt000m7kaujabighkp"},{"post_id":"cirsyqtqm000b7kautrheecl5","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtqu000o7kaupxnu21t3"},{"post_id":"cirsyqtqq000g7kauvl12dnkv","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtqw000r7kauk12kp31q"},{"post_id":"cirsyqtqe00047kauehhbz1rh","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtqx000u7kauf4nu9wl3"},{"post_id":"cirsyqtqr000j7kaufpjo136o","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtqy000x7kau65oq79gv"},{"post_id":"cirsyqtqt000n7kaur42e0w3v","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtr200107kauxvump77c"},{"post_id":"cirsyqtqi00077kaueru2sthq","category_id":"cirsyqtqs000k7kau4hq5wn3a","_id":"cirsyqtr400137kauhp6vrggi"},{"post_id":"cirsyqtqu000p7kauxikmnzbh","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtr600167kauay6n3kgt"},{"post_id":"cirsyqtqw000s7kaubnhu85ta","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtr800197kauezniru7j"},{"post_id":"cirsyqtqy000v7kauqc6c26zo","category_id":"cirsyqtqs000k7kau4hq5wn3a","_id":"cirsyqtrb001d7kauto2j6jld"},{"post_id":"cirsyqtr200117kau7ca8ubpx","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtrc001g7kaudm5buvle"},{"post_id":"cirsyqtr400147kauj559g8jt","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtre001k7kauukgehr0i"},{"post_id":"cirsyqtr600187kau9lflhhs2","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtrg001n7kaujn4aedlx"},{"post_id":"cirsyqtqz000z7kau3dw0mgdl","category_id":"cirsyqtr400127kautzmhwv11","_id":"cirsyqtrk001r7kau2h14lu3o"},{"post_id":"cirsyqtr9001b7kauctzhzrki","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtrl001t7kau2fekrvun"},{"post_id":"cirsyqtrb001f7kaudxo1e70o","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtrn001w7kau10lq4wig"},{"post_id":"cirsyqtrc001i7kauxthal2sj","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtrq00207kauevgrcnsd"},{"post_id":"cirsyqtre001l7kau20des9c0","category_id":"cirsyqtqs000k7kau4hq5wn3a","_id":"cirsyqtrr00237kau27kb23o5"},{"post_id":"cirsyqtrh001o7kau19wonjmv","category_id":"cirsyqtr400127kautzmhwv11","_id":"cirsyqtrt00287kaupc7ywc1t"},{"post_id":"cirsyqtrq00217kauzigm2ha1","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqtrv002b7kauvo5k2x9l"},{"post_id":"cirsyqtrk001s7kau5j6o4utg","category_id":"cirsyqtrn001v7kaubbwfmgkw","_id":"cirsyqtry002g7kauz59ker6y"},{"post_id":"cirsyqtrr00257kauygejl77d","category_id":"cirsyqtqs000k7kau4hq5wn3a","_id":"cirsyqts0002j7kau3j1tes1r"},{"post_id":"cirsyqtru00297kauceumrmoj","category_id":"cirsyqtqs000k7kau4hq5wn3a","_id":"cirsyqts2002m7kaufu76m28n"},{"post_id":"cirsyqtrm001u7kauge04aq61","category_id":"cirsyqtrn001v7kaubbwfmgkw","_id":"cirsyqts3002o7kaui8q8ds4l"},{"post_id":"cirsyqtrv002c7kauomw2f8i1","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqts4002r7kaua5n5rwa8"},{"post_id":"cirsyqtry002h7kau5pia48s9","category_id":"cirsyqtrx002d7kausyxa6k97","_id":"cirsyqts4002t7kaujjyvsgck"},{"post_id":"cirsyqtro001y7kauijijdulb","category_id":"cirsyqtrx002d7kausyxa6k97","_id":"cirsyqts5002w7kaufk8z7jnp"},{"post_id":"cirsyqts0002k7kauqw1fbbr9","category_id":"cirsyqtqd00037kau3vchlnsu","_id":"cirsyqts5002y7kauiqs0s54t"}],"PostTag":[{"post_id":"cirsyqtq500007kaulmqzviwd","tag_id":"cirsyqtqb00027kaulk1nhlzo","_id":"cirsyqtqp000f7kau8rs64sa7"},{"post_id":"cirsyqtq500007kaulmqzviwd","tag_id":"cirsyqtqi00067kauxx7ddz95","_id":"cirsyqtqr000i7kau6csqyirn"},{"post_id":"cirsyqtq900017kausn05etr6","tag_id":"cirsyqtqo000d7kaulod6hi47","_id":"cirsyqtqx000t7kauhj4c42vz"},{"post_id":"cirsyqtq900017kausn05etr6","tag_id":"cirsyqtqs000l7kaup7fzhukl","_id":"cirsyqtqy000w7kau0iqjjuvl"},{"post_id":"cirsyqtqe00047kauehhbz1rh","tag_id":"cirsyqtqv000q7kaupvirir26","_id":"cirsyqtr600177kau8j5i4mi1"},{"post_id":"cirsyqtqe00047kauehhbz1rh","tag_id":"cirsyqtqz000y7kaucsfgazuy","_id":"cirsyqtr9001a7kaupsro187x"},{"post_id":"cirsyqtr600187kau9lflhhs2","tag_id":"cirsyqtqb00027kaulk1nhlzo","_id":"cirsyqtrb001e7kauolhox19x"},{"post_id":"cirsyqtr600187kau9lflhhs2","tag_id":"cirsyqtqi00067kauxx7ddz95","_id":"cirsyqtrc001h7kaunbd09agh"},{"post_id":"cirsyqtqg00057kaulycxjw51","tag_id":"cirsyqtqv000q7kaupvirir26","_id":"cirsyqtrf001m7kau2x68a6cm"},{"post_id":"cirsyqtqg00057kaulycxjw51","tag_id":"cirsyqtra001c7kaumg42m1ee","_id":"cirsyqtrj001p7kauaztrwfva"},{"post_id":"cirsyqtqi00077kaueru2sthq","tag_id":"cirsyqtrd001j7kaughowf13y","_id":"cirsyqtrp001z7kaud5mf4sp4"},{"post_id":"cirsyqtqi00077kaueru2sthq","tag_id":"cirsyqtrk001q7kaubz024idw","_id":"cirsyqtrr00227kau57rdyx21"},{"post_id":"cirsyqtrq00217kauzigm2ha1","tag_id":"cirsyqtqo000d7kaulod6hi47","_id":"cirsyqtrt00277kaup1wn9nfw"},{"post_id":"cirsyqtql00097kau18lmfrcf","tag_id":"cirsyqtqo000d7kaulod6hi47","_id":"cirsyqtrv002a7kauvlklzcoz"},{"post_id":"cirsyqtrr00257kauygejl77d","tag_id":"cirsyqtrd001j7kaughowf13y","_id":"cirsyqtry002f7kaukg15s5sy"},{"post_id":"cirsyqtrr00257kauygejl77d","tag_id":"cirsyqtrk001q7kaubz024idw","_id":"cirsyqts0002i7kaul83y8kt0"},{"post_id":"cirsyqts0002k7kauqw1fbbr9","tag_id":"cirsyqtqv000q7kaupvirir26","_id":"cirsyqts3002n7kaulqaf7ezu"},{"post_id":"cirsyqts0002k7kauqw1fbbr9","tag_id":"cirsyqtqz000y7kaucsfgazuy","_id":"cirsyqts3002p7kau8yf4lghh"},{"post_id":"cirsyqtqm000b7kautrheecl5","tag_id":"cirsyqtrr00247kaulzbls4sa","_id":"cirsyqts4002s7kaukeo8rroe"},{"post_id":"cirsyqtqm000b7kautrheecl5","tag_id":"cirsyqtrx002e7kaur8pzvjod","_id":"cirsyqts4002u7kauvqazqodu"},{"post_id":"cirsyqtqm000b7kautrheecl5","tag_id":"cirsyqts2002l7kautktgpep9","_id":"cirsyqts5002x7kaudxibzy6b"},{"post_id":"cirsyqtqq000g7kauvl12dnkv","tag_id":"cirsyqtqv000q7kaupvirir26","_id":"cirsyqts500307kau8edtqdm9"},{"post_id":"cirsyqtqq000g7kauvl12dnkv","tag_id":"cirsyqtqz000y7kaucsfgazuy","_id":"cirsyqts500317kau4s93gmbj"},{"post_id":"cirsyqtqr000j7kaufpjo136o","tag_id":"cirsyqtqv000q7kaupvirir26","_id":"cirsyqts600347kaust9sjhg4"},{"post_id":"cirsyqtqr000j7kaufpjo136o","tag_id":"cirsyqtqz000y7kaucsfgazuy","_id":"cirsyqts600357kaul0924t9w"},{"post_id":"cirsyqtqt000n7kaur42e0w3v","tag_id":"cirsyqtqv000q7kaupvirir26","_id":"cirsyqts700387kauhe8n40ex"},{"post_id":"cirsyqtqt000n7kaur42e0w3v","tag_id":"cirsyqtra001c7kaumg42m1ee","_id":"cirsyqts700397kau12j0yfpl"},{"post_id":"cirsyqtqu000p7kauxikmnzbh","tag_id":"cirsyqts700377kauc8po1ugd","_id":"cirsyqts8003d7kaumclytp76"},{"post_id":"cirsyqtqu000p7kauxikmnzbh","tag_id":"cirsyqts8003a7kaur3wkylgk","_id":"cirsyqts9003e7kauv61v1581"},{"post_id":"cirsyqtqu000p7kauxikmnzbh","tag_id":"cirsyqts8003b7kau0dxby22j","_id":"cirsyqts9003g7kauz282d8f8"},{"post_id":"cirsyqtqw000s7kaubnhu85ta","tag_id":"cirsyqts8003c7kaux1g2nrrm","_id":"cirsyqts9003i7kaudovqsthv"},{"post_id":"cirsyqtqw000s7kaubnhu85ta","tag_id":"cirsyqts9003f7kaukvinyrkv","_id":"cirsyqtsa003j7kause5newyn"},{"post_id":"cirsyqtqy000v7kauqc6c26zo","tag_id":"cirsyqts9003h7kau34dpb5uh","_id":"cirsyqtsb003m7kaurjk4ok8b"},{"post_id":"cirsyqtqy000v7kauqc6c26zo","tag_id":"cirsyqtsa003k7kaufvbs7pov","_id":"cirsyqtsb003n7kaugy1tyqpd"},{"post_id":"cirsyqtr200117kau7ca8ubpx","tag_id":"cirsyqtqo000d7kaulod6hi47","_id":"cirsyqtsc003p7kauwi6gp1s6"},{"post_id":"cirsyqtr200117kau7ca8ubpx","tag_id":"cirsyqtsa003l7kauasekc45y","_id":"cirsyqtsc003q7kaut7u0c1mn"},{"post_id":"cirsyqtrc001i7kauxthal2sj","tag_id":"cirsyqtrr00247kaulzbls4sa","_id":"cirsyqtsd003s7kaujolz21rf"},{"post_id":"cirsyqtro001y7kauijijdulb","tag_id":"cirsyqtsd003r7kauovnhdamf","_id":"cirsyqtse003u7kau2n2hn9v4"},{"post_id":"cirsyqtru00297kauceumrmoj","tag_id":"cirsyqtrk001q7kaubz024idw","_id":"cirsyqtse003w7kauawscjhfu"},{"post_id":"cirsyqtru00297kauceumrmoj","tag_id":"cirsyqtsd003t7kaubzjhlgsq","_id":"cirsyqtse003x7kaug2yafzcs"},{"post_id":"cirsyqtrv002c7kauomw2f8i1","tag_id":"cirsyqtse003v7kauepimol5g","_id":"cirsyqtsg00407kaukvtnh4nv"},{"post_id":"cirsyqtrv002c7kauomw2f8i1","tag_id":"cirsyqtse003y7kauchi8iagb","_id":"cirsyqtsg00417kau3mmj9sc8"},{"post_id":"cirsyqtry002h7kau5pia48s9","tag_id":"cirsyqtsd003r7kauovnhdamf","_id":"cirsyqtsg00427kauroiefyqt"}],"Tag":[{"name":"hash","_id":"cirsyqtqb00027kaulk1nhlzo"},{"name":"location","_id":"cirsyqtqi00067kauxx7ddz95"},{"name":"css","_id":"cirsyqtqo000d7kaulod6hi47"},{"name":"flexbox","_id":"cirsyqtqs000l7kaup7fzhukl"},{"name":"React","_id":"cirsyqtqv000q7kaupvirir26"},{"name":"virtual dom","_id":"cirsyqtqz000y7kaucsfgazuy"},{"name":"组件化开发","_id":"cirsyqtra001c7kaumg42m1ee"},{"name":"mocha","_id":"cirsyqtrd001j7kaughowf13y"},{"name":"node","_id":"cirsyqtrk001q7kaubz024idw"},{"name":"js","_id":"cirsyqtrr00247kaulzbls4sa"},{"name":"curring","_id":"cirsyqtrx002e7kaur8pzvjod"},{"name":"uncurrying","_id":"cirsyqts2002l7kautktgpep9"},{"name":"Vue","_id":"cirsyqts700377kauc8po1ugd"},{"name":"MVVM","_id":"cirsyqts8003a7kaur3wkylgk"},{"name":"Vuex","_id":"cirsyqts8003b7kau0dxby22j"},{"name":"cleaver","_id":"cirsyqts8003c7kaux1g2nrrm"},{"name":"幻灯","_id":"cirsyqts9003f7kaukvinyrkv"},{"name":"SEO","_id":"cirsyqts9003h7kau34dpb5uh"},{"name":"爬虫","_id":"cirsyqtsa003k7kaufvbs7pov"},{"name":"html5","_id":"cirsyqtsa003l7kauasekc45y"},{"name":"前端杂谈","_id":"cirsyqtsd003r7kauovnhdamf"},{"name":"网络","_id":"cirsyqtsd003t7kaubzjhlgsq"},{"name":"构建工具","_id":"cirsyqtse003v7kauepimol5g"},{"name":"前端工程","_id":"cirsyqtse003y7kauchi8iagb"}]}}