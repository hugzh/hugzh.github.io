<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[果汁的随笔]]></title>
  <subtitle><![CDATA[代码不过百万行，不娶媳妇不见娘]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hugzh.github.io/"/>
  <updated>2016-01-04T06:25:21.909Z</updated>
  <id>http://hugzh.github.io/</id>
  
  <author>
    <name><![CDATA[橙乡果汁]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[单元测试工具Mocha和SuperTest组合]]></title>
    <link href="http://hugzh.github.io/2015/12/08/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Mocha%E5%92%8CSuperTest%E7%BB%84%E5%90%88/"/>
    <id>http://hugzh.github.io/2015/12/08/单元测试工具Mocha和SuperTest组合/</id>
    <published>2015-12-08T12:07:57.000Z</published>
    <updated>2016-01-04T06:25:21.909Z</updated>
    <content type="html"><![CDATA[<p>毕业季，一堆乱七八糟的事情搞得已经整整两个月没有时间写写笔记了。最近进行着一个Node小项目，其中关于单元测试部分花了不少时间去踩坑。所以在这里简单总结一下关于Node开发测试框架Mocha(摩卡)的一些基础用法。由于本人是入门级别的Node开发者，所以这篇文章也是仅适用于和我一样的初级Node开发者，如有不正确的地方欢迎大神们指正！</p>
<h2 id="一、Mocha">一、Mocha</h2><p>Mocha是非常流行JavaScript测试框架之一，在浏览器和Node环境都可以使用。这里主要是针对Node环境。<br><a id="more"></a></p>
<h3 id="1、安装">1、安装</h3><p>关于Mocha的安装当然是万能的npm了，直接npm install就OK，这里不再罗嗦了。</p>
<h3 id="2、使用">2、使用</h3><p>然后就是Mocha的语法了。首先来看一下最简单例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个简单的加法函数</span></span><br><span class="line"><span class="comment">//add.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = add;</span><br></pre></td></tr></table></figure></p>
<p>现在用Mocha写一个测试脚本去测试这个函数。一般来说，测试脚本的命名要和测试的模块一致，后缀为.test.js。这里测试脚本的名称为add.test.js，表示对add模块进行测试。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.test.js</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">require</span>(<span class="string">'./add'</span>);</span><br><span class="line"><span class="keyword">var</span> should = <span class="keyword">require</span>(<span class="string">'should'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test add'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    it(<span class="string">'1 + 1 should be equal to 2'</span>, <span class="function"><span class="keyword">function</span><span class="params">(done)</span></span>&#123;</span><br><span class="line">        (add(<span class="number">1</span>,<span class="number">1</span>) === <span class="number">2</span>).should.be.<span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>然后保存代码之后进入终端，执行mocha add.test 即可。其中describe()函数是测试描述，表示一组相关测试用例是对哪个模块的测试。it()是一个测试用例，在一个describe块的内部可以执行对个测试用例(it块)。</p>
<p>这是同步函数的测试。在Node环境中，绝大部分的业务逻辑都是异步的，所以测试结果的回调是JavaScript测试框架需要解决的首要问题。Mocha提供了一个回调函数done，在业务代码执行完毕之后调用done()结束测试用例，不然的话测试用例就会出现timeout的情况导致测试用例失败。Mocha默认的超时时间是2000毫秒，如果由于测试用例的执行时间比较长需要延长超时时间，可以在命令行添加 -t 参数，比如mocha -t 3000 add.test.js。当然还有其他命令行参数，比如 mocha -w 用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。查看更多的命令行参数可以通过 mocha -h 查找。</p>
<p>那么接下来看一个异步测试例子：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe<span class="list">(<span class="quoted">'test</span> async function', function<span class="list">()</span>&#123;</span><br><span class="line">    it<span class="list">(<span class="quoted">'supertest</span> example', function<span class="list">(<span class="keyword">done</span>)</span>&#123;</span><br><span class="line">        request.post<span class="list">(<span class="quoted">'/</span>')</span></span><br><span class="line">        .expect<span class="list">(<span class="number">200</span>)</span></span><br><span class="line">        .end<span class="list">(<span class="keyword">function</span><span class="list">(<span class="keyword">err</span>, res)</span> &#123;</span><br><span class="line">            should.not.exist<span class="list">(<span class="keyword">err</span>)</span><span class="comment">;</span></span><br><span class="line">            done<span class="list">()</span><span class="comment">;</span></span><br><span class="line">        &#125;)</span></span><br><span class="line">    &#125;)</span></span><br><span class="line">&#125;)</span></span><br></pre></td></tr></table></figure></p>
<p>在request请求执行完毕end()之后，一定要调用done()，否则测试用例超时，那么这个用例就失败了。当然这里用到了断言库should，稍后再介绍它的语法。</p>
<h3 id="3、钩子(hooks)">3、钩子(hooks)</h3><p>Mocha的Hooks主要是用来设置前置条件和后置处理。比如说一个业务请求之前必须先登录，那个登录操作就在before()里面完成。Mocha提供了before,after,beforeEach,afterEach四个钩子。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'hooks'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  before(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// runs before all tests in this block</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  after(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// runs after all tests in this block</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// runs before each test in this block</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  afterEach(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// runs after each test in this block</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'test'</span>,<span class="function"><span class="keyword">function</span><span class="params">(done)</span></span>&#123;</span><br><span class="line">    <span class="comment">//test here</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果说某个测试需要跳过，使用it.skip()，Mocha跳过这个用例而不影响其他it块；只测试某个测试用例，使用it.only()，Mocha只执行.only用例，无视其他it块。</p>
<h2 id="二、断言库should">二、断言库should</h2><p>Mocha本身是不包含断言库的，所以我们需要自己选择断言库。should是一个很简单的、贴近自然语言的断言库。当然，Mocha是适配所有的断言库的，如果你喜欢其他的断言库比如expect之类的，你也可以把它包含进来使用。</p>
<p>should的语法非常贴近自然语言，简单易懂，常见的should断言如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全等，相当于===</span></span><br><span class="line">.exactly</span><br><span class="line">(<span class="number">5</span>).should.be.exactly(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 对象存在</span></span><br><span class="line">.ok</span><br><span class="line"><span class="literal">true</span>.should.be.ok;</span><br><span class="line"><span class="string">'yay'</span>.should.be.ok;</span><br><span class="line">(<span class="number">1</span>).should.be.ok;</span><br><span class="line">(&#123;&#125;).should.be.ok;</span><br><span class="line"><span class="literal">false</span>.should.not.be.ok;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真</span></span><br><span class="line">.<span class="literal">true</span></span><br><span class="line">(<span class="number">5</span>===<span class="number">5</span>).should.be.<span class="literal">true</span></span><br><span class="line">(err === <span class="literal">null</span>).should.be.<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相等,相当于 ==</span></span><br><span class="line">.eql</span><br><span class="line">(&#123; <span class="string">foo:</span> <span class="string">'bar'</span> &#125;).should.eql(&#123; <span class="string">foo:</span> <span class="string">'bar'</span> &#125;);</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].should.eql([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// see next example it is correct, even if it is different types, but actual content the same</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].should.eql(&#123; <span class="string">'0'</span>: <span class="number">1</span>, <span class="string">'1'</span>: <span class="number">2</span>, <span class="string">'2'</span>: <span class="number">3</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非数字</span></span><br><span class="line">.NaN</span><br><span class="line">(undefined + <span class="number">0</span>).should.be.NaN;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断类型</span></span><br><span class="line">.typeof</span><br><span class="line">user.should.be.type(<span class="string">'object'</span>);</span><br><span class="line"><span class="string">'test'</span>.should.be.type(<span class="string">'string'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的一个实例</span></span><br><span class="line">.<span class="keyword">instanceof</span></span><br><span class="line">user.should.be.an.<span class="keyword">instanceof</span>(User);</span><br><span class="line">[].should.be.an.instanceOf(Array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在</span></span><br><span class="line">.exist()</span><br><span class="line">should.not.exist(err)</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度包含</span></span><br><span class="line">.containDeep()</span><br><span class="line">[[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]].should.containDeep([[<span class="number">3</span>]]);</span><br><span class="line">[[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>]].should.containDeep([[<span class="number">3</span>]]);</span><br><span class="line">[&#123;<span class="string">a:</span> <span class="string">'a'</span>&#125;, &#123;<span class="string">b:</span> <span class="string">'b'</span>, <span class="string">c:</span> <span class="string">'c'</span>&#125;].should.containDeep([&#123;<span class="string">a:</span> <span class="string">'a'</span>&#125;]);</span><br><span class="line">[&#123;<span class="string">a:</span> <span class="string">'a'</span>&#125;, &#123;<span class="string">b:</span> <span class="string">'b'</span>, <span class="string">c:</span> <span class="string">'c'</span>&#125;].should.containDeep([&#123;<span class="string">b:</span> <span class="string">'b'</span>&#125;]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出异常</span></span><br><span class="line">.<span class="keyword">throw</span>()和throwError()</span><br><span class="line">(function()&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'fail'</span>);</span><br><span class="line">&#125;).should.<span class="keyword">throw</span>();</span><br><span class="line">(function()&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'fail'</span>);</span><br><span class="line">&#125;).should.<span class="keyword">throw</span>(<span class="string">'fail'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http响应的头部包含</span></span><br><span class="line">.header</span><br><span class="line">res.should.have.header(<span class="string">'content-length'</span>);</span><br><span class="line">res.should.have.header(<span class="string">'Content-Length'</span>, <span class="string">'123'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含或等价于</span></span><br><span class="line">.containEql</span><br><span class="line">(&#123; <span class="string">b:</span> <span class="number">10</span> &#125;).should.containEql(&#123; <span class="string">b:</span> <span class="number">10</span> &#125;);</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, &#123; <span class="string">a:</span> <span class="number">10</span> &#125;]).should.containEql(&#123; <span class="string">a:</span> <span class="number">10</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="三、SuperTest">三、SuperTest</h2><p>单单使用Mocha和should就几乎可以满足所有JavaScript函数的单元测试。但是对于Node应用而言，不仅仅是函数的集合，比如一个web应用的测试。这时候就需要配合一个http代理，完成Http请求和路由的测试。<br>Supertest是一个HTTP代理服务引擎，可以模拟一切HTTP请求行为。Supertest可以搭配任意的应用框架，从而进行应用的单元测试。</p>
<h3 id="1、用法">1、用法</h3><h4 id="API">API</h4><p>首先，传入应用来实例化supertest,比如说实例化一个express：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> supertest = <span class="built_in">require</span>(<span class="string">'supertest'</span>), </span><br><span class="line">    express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> request = supertest(app);</span><br></pre></td></tr></table></figure></p>
<p>接下来就可以在Mocha测试用例中直接使用request发出一个基于该web应用的http请求了。</p>
<p>1、.set()<br>如果需要设置数据，supertest的API提供了 .set 来设置，比如：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe<span class="list">(<span class="quoted">'GET</span> /users', function<span class="list">()</span>&#123;</span><br><span class="line">  it<span class="list">(<span class="quoted">'respond</span> with json', function<span class="list">(<span class="keyword">done</span>)</span>&#123;</span><br><span class="line">    request<span class="list">(<span class="keyword">app</span>)</span></span><br><span class="line">      .get<span class="list">(<span class="quoted">'/user</span>')</span></span><br><span class="line">      .set<span class="list">(<span class="quoted">'Accept</span>', <span class="quoted">'application/json</span>')</span></span><br><span class="line">      .expect<span class="list">(<span class="number">200</span>)</span></span><br><span class="line">      .end<span class="list">(<span class="keyword">function</span><span class="list">(<span class="keyword">err</span>, res)</span>&#123;</span><br><span class="line">        should.not.exist<span class="list">(<span class="keyword">err</span>)</span><span class="comment">;</span></span><br><span class="line">        res.text.should.containEql<span class="list">(<span class="quoted">'success</span>')</span><span class="comment">;</span></span><br><span class="line">        done<span class="list">()</span><span class="comment">;</span></span><br><span class="line">      &#125;)</span><span class="comment">;</span></span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>2、.expect()<br>.expect 是一个断言，上述测试代码在执行之后期望的状态码是200(OK)。如果接收到的数据为html页面，.expect(‘Content-Type’, ‘text/html;charset=utf-8’)</p>
<p>3、.end()<br>.end 是执行一个request请求，在回调函数里面根据业务逻辑的返回数据做断言分析。</p>
<p>4、.send()<br>很多情况下，项目需要测试一个表单业务。supertest提供了.send()方法来发送表单域数据。比如一个登录模块，需要发送用户名密码：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe<span class="list">(<span class="quoted">'test</span> login', function<span class="list">()</span>&#123;</span><br><span class="line">    it<span class="list">(<span class="quoted">'login</span> sucessfully', function <span class="list">(<span class="keyword">done</span>)</span> &#123;</span><br><span class="line">        request.post<span class="list">(<span class="quoted">'/user</span>')</span></span><br><span class="line">        .send<span class="list">(&#123;</span><br><span class="line">            username: <span class="quoted">'username</span>',</span><br><span class="line">            password: '<span class="number">123456</span>'</span><br><span class="line">        &#125;)</span></span><br><span class="line">        .end<span class="list">(<span class="keyword">function</span> <span class="list">(<span class="keyword">err</span>, res)</span> &#123;</span><br><span class="line">            should.not.exists<span class="list">(<span class="keyword">err</span>)</span><span class="comment">;</span></span><br><span class="line">            done<span class="list">()</span><span class="comment">;</span></span><br><span class="line">        &#125;)</span><span class="comment">;</span></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span></span><br></pre></td></tr></table></figure></p>
<p>5、.attach()<br>.attach方法主要用来测试文件上传，由于.send()只能上传文本域，所以关于multipart -file的上传需要通过附件来绑定。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">request</span><span class="params">(app)</span></span></span><br><span class="line">.<span class="function"><span class="title">post</span><span class="params">(<span class="string">'/'</span>)</span></span></span><br><span class="line">.<span class="function"><span class="title">field</span><span class="params">(<span class="string">'name'</span>, <span class="string">'my awesome avatar'</span>)</span></span></span><br><span class="line">.<span class="function"><span class="title">attach</span><span class="params">(<span class="string">'avatar'</span>, <span class="string">'test/fixtures/homeboy.jpg'</span>)</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h4 id="持久化Cookie">持久化Cookie</h4><p>在很多业务测试中，需要用户先登录才有权限执行操作。这个时候作为HTTP请求模拟，必须要可以保存一些Cookie数据，也就是Cookie的持久化。这一般有两种解决思路。<br>1、在 supertest 中，可以通过 var request = supertest.agent(app) 获取一个 agent 对象，这个对象的 API 跟直接在 superagent 上调用各种方法是一样的。这个request在被多次调用 get 和 post 之后，可以一路把 cookie 都保存下来。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> supertest = <span class="keyword">require</span>(<span class="string">'supertest'</span>);</span><br><span class="line">  <span class="built_in">var</span> app = express();</span><br><span class="line">  <span class="built_in">var</span> request = supertest<span class="built_in">.</span>agent(app);</span><br><span class="line"></span><br><span class="line">  request<span class="built_in">.</span>post(<span class="string">'login'</span>)<span class="built_in">.</span>end(<span class="attribute">...</span>);</span><br><span class="line">  <span class="comment">// then ..</span></span><br><span class="line">  request<span class="built_in">.</span>post(<span class="string">'create_topic'</span>)<span class="built_in">.</span>end(<span class="attribute">...</span>); <span class="comment">// 此时的request中有用户登陆后的 cookie</span></span><br></pre></td></tr></table></figure></p>
<p>2、通过.set()，在发起请求时，调用 .set(‘Cookie’, ‘a cookie string’) 这样的方式。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="keyword">require</span>(<span class="string">'supertest'</span>);</span><br><span class="line"><span class="keyword">var</span> userCookie;</span><br><span class="line">request.post(<span class="string">'login'</span>)</span><br><span class="line">.<span class="keyword">end</span>(<span class="function"><span class="keyword">function</span> <span class="params">(err, res)</span> <span class="comment">&#123;</span><br><span class="line">    userCookie = res.headers['Cookie']</span><br><span class="line">&#125;</span>);</span></span><br><span class="line"><span class="comment">// then ..</span></span><br><span class="line"></span><br><span class="line">request.post(<span class="string">'create_topic'</span>)</span><br><span class="line">    .<span class="keyword">set</span>(<span class="string">'Cookie'</span>, userCookie)</span><br><span class="line">    .<span class="keyword">end</span>(...)</span><br></pre></td></tr></table></figure></p>
<h3 id="2、实战demo">2、实战demo</h3><p>为了更好地帮助理解SuperTest的强大功能，这里放上我的一个项目模块的测试demo。</p>
<h4 id="项目源文件">项目源文件</h4><p>首先，这是一个express应用的登录注册和用户信息修改模块，要测试的就是这个user模块。为了节省篇幅，这里只放上UserController和Router两个项目文件。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">UserController.js</span><br><span class="line">// 用户首页</span><br><span class="line">exports.getUser = <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!req.user) &#123;</span><br><span class="line">        res.send(&#123;status: <span class="keyword">false</span>, info: <span class="string">'未登录'</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.render(<span class="string">'user'</span>, &#123;status: <span class="keyword">true</span>, userdata: req.user&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.login =  <span class="function"><span class="keyword">function</span> <span class="params">(req, res, next)</span></span> &#123;</span><br><span class="line">    req.session.save(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            log.<span class="built_in">error</span>(err);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">next</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">        res.redirect(<span class="string">'/user/'</span> + req.user.username);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.logout = <span class="function"><span class="keyword">function</span> <span class="params">(req, res, next)</span></span> &#123;</span><br><span class="line">    req.logout();</span><br><span class="line">    req.session.save(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            log.<span class="built_in">error</span>(err);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">next</span> (err);</span><br><span class="line">        &#125;</span><br><span class="line">        res.redirect(<span class="string">'/user'</span>);</span><br><span class="line">        res.<span class="keyword">end</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 用户注册</span><br><span class="line">exports.addUser = <span class="function"><span class="keyword">function</span> <span class="params">(req, res, next)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!req.body.username || !req.body.password) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.send(&#123;status: <span class="keyword">false</span>, info: <span class="string">'用户名或密码不能为空'</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.body.password.length &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.send(&#123;status: <span class="keyword">false</span>, info: <span class="string">'密码长度太短'</span>&#125;);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    User.register(new User(&#123;username: req.body.username&#125;), req.body.password, <span class="function"><span class="keyword">function</span> <span class="params">(err, user)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            log.<span class="built_in">error</span>(err);</span><br><span class="line">            <span class="keyword">return</span> res.render(<span class="string">'register'</span>, &#123;info: <span class="string">'用户名已被使用'</span>&#125;);</span><br><span class="line">        &#125; </span><br><span class="line">        passport.authenticate(<span class="string">'local'</span>)(req, res, <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> &#123;</span><br><span class="line">            req.session.save(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    log.<span class="built_in">error</span>(err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">next</span>(err);</span><br><span class="line">                &#125;</span><br><span class="line">                res.redirect(<span class="string">'/user/'</span> + req.body.username);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 更新用户信息文字资料</span><br><span class="line">exports.updateInfo = <span class="function"><span class="keyword">function</span> <span class="params">(req, res, next)</span></span> &#123;</span><br><span class="line">    User.findOne(&#123;username: req.user.username&#125;, <span class="function"><span class="keyword">function</span> <span class="params">(err, doc)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doc) &#123;</span><br><span class="line">            doc.update(req.body, <span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    log.<span class="built_in">error</span>(err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">next</span>(err);</span><br><span class="line">                &#125;</span><br><span class="line">                res.send(&#123;status: <span class="keyword">true</span>&#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 更换头像</span><br><span class="line">exports.updateAvator = <span class="function"><span class="keyword">function</span> <span class="params">(req, res,next)</span></span> &#123;</span><br><span class="line">    upload(req, res, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            log.<span class="built_in">error</span>(err);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">next</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">        User.findOne(&#123;username: req.user.username&#125;, <span class="function"><span class="keyword">function</span> <span class="params">(err, doc)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                log.<span class="built_in">error</span>(err);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">next</span>(err);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (doc) &#123;</span><br><span class="line">                doc.update(&#123;avator: req.file.filename&#125;, <span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span></span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        log.<span class="built_in">error</span>(err);</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">next</span>(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.<span class="built_in">type</span>(<span class="string">'html'</span>);</span><br><span class="line">                    res.send(&#123;status: <span class="keyword">true</span>, avator: req.file.filename&#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">next</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Router文件<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="keyword">get</span>(<span class="string">'/:uid'</span>, isAuthenticated, user.getUser);</span><br><span class="line">router.<span class="keyword">get</span>(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>&#123;</span><br><span class="line">    res.render(<span class="string">'login'</span>, &#123;info: <span class="string">''</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">router.post(<span class="string">'/'</span>,passport.authenticate(<span class="string">'local'</span>), <span class="comment">/*&#123;failureRedirect: '/user'&#125;),*/</span> user.login);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/authenticate/logout'</span>, user.logout);</span><br><span class="line"></span><br><span class="line">router.<span class="keyword">get</span>(<span class="string">'/authenticate/register'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>&#123;</span><br><span class="line">    res.render(<span class="string">'register'</span>, &#123;info: <span class="string">''</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/authenticate/register'</span>, user.addUser);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户相关的资料</span></span><br><span class="line">router.post(<span class="string">'/update/info'</span>, user.updateInfo);</span><br><span class="line">router.post(<span class="string">'/update/avator'</span>, user.updateAvator);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure></p>
<h4 id="测试脚本">测试脚本</h4><p>首先，测试注册功能。为了防止用户名冲突，在测试用例之前设置钩子before块，清除User集合。<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user.test.js</span></span><br><span class="line">describe(<span class="string">'test user.addUser()'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">       before(<span class="function"><span class="keyword">function</span> <span class="params">(done)</span> &#123;</span></span><br><span class="line">           <span class="transposed_variable">User.</span>remove(&#123;&#125;, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> &#123;</span></span><br><span class="line">               done();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       it(<span class="string">'register sucessfully'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(done)</span> &#123;</span></span><br><span class="line">           <span class="transposed_variable">request.</span>post(<span class="string">'/user/authenticate/register'</span>)</span><br><span class="line">           .send(&#123;</span><br><span class="line">               username: <span class="string">'username'</span>,</span><br><span class="line">               password: <span class="string">'123456'</span></span><br><span class="line">           &#125;)</span><br><span class="line">           <span class="comment">//注册成功之后重定向</span></span><br><span class="line">           .expect(<span class="number">302</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, res)</span> &#123;</span></span><br><span class="line">               <span class="transposed_variable">should.</span><span class="transposed_variable">not.</span><span class="built_in">exists</span>(err);</span><br><span class="line">               done();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">//测试用户名存在的用例</span></span><br><span class="line">       it(<span class="string">'username already exist'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(done)</span> &#123;</span></span><br><span class="line">           <span class="transposed_variable">request.</span>post(<span class="string">'/user/authenticate/register'</span>)</span><br><span class="line">           .send(&#123;</span><br><span class="line">               username: <span class="string">'username'</span>,</span><br><span class="line">               password: <span class="string">'123456'</span></span><br><span class="line">           &#125;)</span><br><span class="line">           .<span class="keyword">end</span>(<span class="function"><span class="keyword">function</span> <span class="params">(err, res)</span> &#123;</span></span><br><span class="line">               <span class="transposed_variable">should.</span><span class="transposed_variable">not.</span><span class="built_in">exists</span>(err);</span><br><span class="line">               <span class="transposed_variable">res.</span><span class="transposed_variable">text.</span><span class="transposed_variable">should.</span>containEql(<span class="string">'用户名已被使用'</span>);</span><br><span class="line">               done();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">// 测试头像上传</span></span><br><span class="line">   describe(<span class="string">'test user.updateAvator()'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">       <span class="comment">//bofore HOOKS，测试业务逻辑之前先登录，并持久化cookie</span></span><br><span class="line">       before(<span class="function"><span class="keyword">function</span> <span class="params">(done)</span> &#123;</span></span><br><span class="line">           <span class="transposed_variable">request.</span>post(<span class="string">'/user'</span>)</span><br><span class="line">           .send(&#123;</span><br><span class="line">               username: <span class="string">'username'</span>,</span><br><span class="line">               password: <span class="string">'123456'</span></span><br><span class="line">           &#125;)</span><br><span class="line">           .<span class="keyword">end</span>(<span class="function"><span class="keyword">function</span> <span class="params">(err, res)</span> &#123;</span></span><br><span class="line">               done();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       it(<span class="string">'update avator upload sucessfully'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(done)</span> &#123;</span></span><br><span class="line">           <span class="transposed_variable">request.</span>post(<span class="string">'/user/update/avator'</span>)</span><br><span class="line">           .attach(<span class="string">'avator'</span>,<span class="string">'test/image/test.jpg'</span>)</span><br><span class="line">           .<span class="keyword">end</span>(<span class="function"><span class="keyword">function</span> <span class="params">(err, res)</span> &#123;</span></span><br><span class="line">               <span class="transposed_variable">should.</span><span class="transposed_variable">not.</span><span class="built_in">exists</span>(err);</span><br><span class="line">               <span class="transposed_variable">res.</span><span class="transposed_variable">text.</span><span class="transposed_variable">should.</span>containEql(<span class="string">'"</span>status<span class="string">":true'</span>);</span><br><span class="line">               done();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;); </span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>毕业季，一堆乱七八糟的事情搞得已经整整两个月没有时间写写笔记了。最近进行着一个Node小项目，其中关于单元测试部分花了不少时间去踩坑。所以在这里简单总结一下关于Node开发测试框架Mocha(摩卡)的一些基础用法。由于本人是入门级别的Node开发者，所以这篇文章也是仅适用于和我一样的初级Node开发者，如有不正确的地方欢迎大神们指正！</p>
<h2 id="一、Mocha">一、Mocha</h2><p>Mocha是非常流行JavaScript测试框架之一，在浏览器和Node环境都可以使用。这里主要是针对Node环境。<br>]]>
    
    </summary>
    
      <category term="mocha" scheme="http://hugzh.github.io/tags/mocha/"/>
    
      <category term="node" scheme="http://hugzh.github.io/tags/node/"/>
    
      <category term="Nodejs" scheme="http://hugzh.github.io/categories/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React.js那些事(core篇)]]></title>
    <link href="http://hugzh.github.io/2015/10/07/React-js%E9%82%A3%E4%BA%9B%E4%BA%8B-core%E7%AF%87/"/>
    <id>http://hugzh.github.io/2015/10/07/React-js那些事-core篇/</id>
    <published>2015-10-07T08:03:42.000Z</published>
    <updated>2016-01-04T05:57:16.528Z</updated>
    <content type="html"><![CDATA[<p>这一篇主要讲讲React.js虚拟DOM的底层相关，主要是自己学习官方文档的Reconciliation部分的一些总结。我们都知道，React的虚拟DOM是非常高效的。那么，React底层是使用什么样的算法实现DOM的高效渲染呢？<br><a id="more"></a></p>
<h1 id="机制">机制</h1><p>React.js在内存里的DOM树操作是子树的替换，也就是用变化之后的子树整个代替原来的子树，而不是在内存里面调整子树。从算法的角度来说，生成最少的将一颗树形结构转换成另一颗树形结构的操作，其最优算法的复杂度是 O(n3)，n是树中节点的总数。所以React尝试从另一个方面入手，使用试探的方法。首先需要达成两点假设：<br>1、拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。<br>2、可以为元素提供一个唯一的标志，该元素在不同的渲染过程中保持不变。实际上，这些假设会使在几乎所有的应用场景下，应用变得出奇地快。</p>
<h1 id="详细">详细</h1><h2 id="diffing算法">diffing算法</h2><p>为了实现子树的替换，首先必须要检查两棵树的差异。React的处理机制分三种类型处理。<br><img src="http://huguozhi-media.stor.sinaapp.com/mygitio%2F1.png" alt="示例1"></p>
<h3 id="不同的节点类型">不同的节点类型</h3><p>节点类型不同，React 将会把它们当做两个不同的子树，移除之前的那棵子树，然后创建并插入第二棵子树。React不会尝试计算出该渲染什么，仅会从 DOM中移除之前的节点，然后插入新的节点。碰到不一样的组件结构，React将重新创建树形结构，而不是耗费时间去尝试匹配这两个树形结构。所以，React的虚拟DOM是非常高效的。</p>
<h3 id="DOM节点">DOM节点</h3><p>DOM节点是相同类型的，比较两个DOM节点的时候，首先查看属性。对随着时间发生了变化的属性进行更新，然后递归检查所有子级的属性。</p>
<h3 id="自定义组件">自定义组件</h3><p>我们决定两个自定义组件是相同的。因为组件是状态化的，不可能每次状态改变都要创建一个新的组件实例。React 利用新组件上的所有属性，然后在之前的组件实例上调用 component[Will/Did]ReceiveProps()。现在，之前的组件就是可操作了的。它的 render() 方法被调用，然后差异算法重新比较新的状态和上一次的状态。</p>
<h2 id="子级优化差异">子级优化差异</h2><p>React采用的方法是同时遍历两个子级列表，当发现差异的时候，就产生一次 DOM 修改。例如我们如果需要在组件末尾添加一个元素，那么如果两个子级（原有的和新添加的）是相同元素，则直接修改已有子级元素的文本内容，然后在后面插入一个新的子级节点。<br>另外，React引入一个唯一的key属性，给每一个子级一个键值，用于和以后变化的组件进行比较。这样，React就能够检测出节点插入、移除和替换，并且借助哈希表使节点移动复杂度为 O(n)。<br><img src="http://huguozhi-media.stor.sinaapp.com/mygitio%2F2.png" alt="示例1"></p>
<h1 id="本篇结语">本篇结语</h1><p>这一篇主要是介绍React的渲染机制，虚拟dom是React.js的核心。想要更多地了解React.js的朋友可以进入<a href="http://reactjs.cn/" target="_blank" rel="external">官方文档</a>进行深入学习。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一篇主要讲讲React.js虚拟DOM的底层相关，主要是自己学习官方文档的Reconciliation部分的一些总结。我们都知道，React的虚拟DOM是非常高效的。那么，React底层是使用什么样的算法实现DOM的高效渲染呢？<br>]]>
    
    </summary>
    
      <category term="React" scheme="http://hugzh.github.io/tags/React/"/>
    
      <category term="virtual dom" scheme="http://hugzh.github.io/tags/virtual-dom/"/>
    
      <category term="前端开发" scheme="http://hugzh.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React.js那些事(入门篇)]]></title>
    <link href="http://hugzh.github.io/2015/09/14/React-js%E9%82%A3%E4%BA%9B%E4%BA%8B-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://hugzh.github.io/2015/09/14/React-js那些事-入门篇/</id>
    <published>2015-09-14T10:59:50.000Z</published>
    <updated>2016-01-04T05:57:05.278Z</updated>
    <content type="html"><![CDATA[<p>关于React.js的相关背景知识以及它的核心概念已经在<a href="http://hugzh.github.io/2015/09/11/React-js%E9%82%A3%E4%BA%9B%E4%BA%8B-%E4%BB%8B%E7%BB%8D%E7%AF%87/">上一篇文章</a>里面说过。在这一篇里面，我通过一个组件开发的实例简单介绍如何使用React进行web组件开发。</p>
<p>先来介绍一下这个打算实现的组件的功能：这是一个简单的三列表格，包含用户id，用户名，电话号码三列。当用户点击表头thead的单元时，表格会根据点中的列的字段进行升序排序。<br><a id="more"></a><br>三军未动，先上demo：</p>
<iframe width="100%" height="300" src="//jsfiddle.net/hugzh/6jzz77de/3/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="第一步：划分组件">第一步：划分组件</h2><p>首先，我们需要将整个组件划分为几个子组件，这是组件开发的重要思想——拆分组合。这是实现组件重用的关键技术。根据案例的原型，我将组件划分如下：<br><img src="http://huguozhi-media.stor.sinaapp.com/mygitio%2Ftable.JPG" alt="table partion"><br>最外层的组件是我需要的目标组件 ——TableComponent，由绿色部分和黄色部分组成;<br>绿色部分为组件Thead，由三个相同的组件TheadCell构成(红色);<br>黄色部分为组件Tbody,每一行是一个组件Cell(蓝色)；<br>红色部分—— TheadCell;<br>蓝色部分—— Cell;</p>
<h2 id="第二步：组件绘制">第二步：组件绘制</h2><p>组件绘制非常简单，首先需要引入react.js文件以及TSX转换器文件JSXTransformer.js。然后，创建一个组件只需要调用一个函数React.createClass()即可，可以从外层到里层构件或者从里层到外层构件。比如，我先构造组件TheadCell:</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  <span class="type">TheadCell</span> = <span class="type">React</span>.createClass(&#123;</span><br><span class="line">    render: function ()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;th <span class="keyword">ref</span>=<span class="string">"getSortKey"</span> title=<span class="string">"点击此键进行排序"</span>&gt;&#123;this.props.content&#125;&lt;/th&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就可以构造出一个Thead组件了，它的UI表现就是一个表头的 th 元素。一个组件的数据内容由该组件的父级传递过来，父级传递给子级的数据是通过 props 对象来传递的。然后子级组件通过this.props来读取数据对象的内容。父级组件传递数据对象给子级组件的方法也很简单，只要在组件传入一个属性值即可。在这里，TheadCell的父级组件为Thead，创建它并传递数据给TheadCell：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var  Thead = React.createClass(&#123;</span><br><span class="line">    render: function ()&#123;</span><br><span class="line">        return (</span><br><span class="line">            <span class="tag">&lt;<span class="title">thead</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">caption</span>&gt;</span>点击表格头部进行排序<span class="tag">&lt;/<span class="title">caption</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">TheadCell</span> <span class="attribute">content</span>=<span class="value">&#123;this.props.uid&#125;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">TheadCell</span> <span class="attribute">content</span>=<span class="value">&#123;this.props.name&#125;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">TheadCell</span> <span class="attribute">content</span>=<span class="value">&#123;this.props.tel&#125;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">thead</span>&gt;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样，Thead包含了三个子组件TheadCell，然后类似XML的标签语法定义组件的“属性”——content。在这里，content的值来自Thead的父级组件TableComponent。<br>同样的道理，创建剩下的所有静态组件：</p>
<p>创建Cell：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Cell  = React.createClass(&#123;</span><br><span class="line">    render: function()&#123;</span><br><span class="line">        return (</span><br><span class="line">            <span class="variable">&lt;tr&gt;</span></span><br><span class="line">                <span class="variable">&lt;td&gt;</span>&#123;this.props.<span class="keyword">user</span>Item.uid&#125;<span class="variable">&lt;/td&gt;</span></span><br><span class="line">                <span class="variable">&lt;td&gt;</span>&#123;this.props.<span class="keyword">user</span>Item.name&#125;<span class="variable">&lt;/td&gt;</span></span><br><span class="line">                <span class="variable">&lt;td&gt;</span>&#123;this.props.<span class="keyword">user</span>Item.tel&#125;<span class="variable">&lt;/td&gt;</span></span><br><span class="line">            <span class="variable">&lt;/tr&gt;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>创建Tbody:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Tbody = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> row = [],</span><br><span class="line">            userlist = <span class="keyword">this</span>.props.items;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> userlist)&#123;</span><br><span class="line">            row.push(&lt;Cell userItem=&#123;<span class="keyword">this</span>.props.items[item]&#125; key=&#123;item&#125;/&gt;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;tbody&gt;</span><br><span class="line">                &#123;row&#125;</span><br><span class="line">            &lt;/tbody&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>创建TableComponent:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TableComponent = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;table&gt;</span><br><span class="line">                &lt;Thead  uid=<span class="string">"uid"</span> name=<span class="string">"name"</span> tel=<span class="string">"tel"</span>/&gt;</span><br><span class="line">                &lt;Tbody items=&#123;<span class="keyword">this</span>.props.data&#125;/&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在这个地方，为了方便，我省略了从服务器加载数据的步骤，直接声明一个静态数据：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var USERS = [</span><br><span class="line">    &#123;<span class="string">"uid"</span>:<span class="number">4</span>,<span class="string">"name"</span>:<span class="string">"zhut"</span>,<span class="string">"tel"</span>:<span class="string">"13899994567"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"uid"</span>:<span class="number">2</span>,<span class="string">"name"</span>:<span class="string">"xiaom"</span>,<span class="string">"tel"</span>:<span class="string">"13580889999"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"uid"</span>:<span class="number">3</span>,<span class="string">"name"</span>:<span class="string">"Brand"</span>,<span class="string">"tel"</span>:<span class="string">"15918446402"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"uid"</span>:<span class="number">1</span>,<span class="string">"name"</span>:<span class="string">"defan"</span>,<span class="string">"tel"</span>:<span class="string">"18913145678"</span>&#125;</span><br><span class="line"> ];</span><br></pre></td></tr></table></figure></p>
<p>最后，把组件渲染到html页面上。静态组件也就绘制完成了：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.<span class="built_in">render</span><span class="params">(&lt;TableComponent data=&#123;USERS&#125; /&gt;,document.getElementById<span class="params">(<span class="string">"content"</span>)</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="第三步：识别UI的state">第三步：识别UI的state</h2><p>state是组件私有的，可以通过调用 this.setState() 来改变它。当状态更新之后，组件重新渲染自己。也就是说每当state改变之后，React的虚拟DOM机制就会感知到变化然后重新绘制UI。由于虚拟DOM操作是在内存里面，这就使得UI的重新绘制非常地高效快捷。这是React的精髓所在。<br>好了，寻找state的三步法：</p>
<ul>
<li>是否是从父级通过 props 传入的？如果是，可能不是 state 。</li>
<li>是否会随着时间改变？如果不是，可能不是 state 。</li>
<li>能根据组件中其它 state 数据或者 props 计算出来吗？如果是，就不是 state 。</li>
</ul>
<p>在这里，我们的组件是随着TheadCell被点击，整个组件重新排序。所以Thead组件的变化必须影响到Tbody的状态。所以我们把state设置在Thead和Tbody的父级组件TableComponent上。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TableComponent = React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            sortBy:<span class="string">''</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;table&gt;</span><br><span class="line">                &lt;Thead uid=<span class="string">"uid"</span> name=<span class="string">"name"</span> tel=<span class="string">"tel"</span>/&gt;</span><br><span class="line">                &lt;Tbody items=&#123;<span class="keyword">this</span>.props.data&#125; sortBy=&#123;<span class="keyword">this</span>.state.sortBy&#125;/&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>getInitialState 初始化组件的state，然后传递给子级Tbody。</p>
<h2 id="第四步：添加反向数据流">第四步：添加反向数据流</h2><p>state的动态变化才会导致组件重新绘制，所以发生在组件点击事件必须要能改变组件的state，组件树中层级很深的表单组件TheadCell需要更新 TableComponent 中的 state 。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TableComponent = React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            sortBy:<span class="string">''</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClick: <span class="function"><span class="keyword">function</span><span class="params">(value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            sortBy:value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;table&gt;</span><br><span class="line">                &lt;Thead  sort=&#123;<span class="keyword">this</span>.handleClick&#125; uid=<span class="string">"uid"</span> name=<span class="string">"name"</span> tel=<span class="string">"tel"</span>/&gt;</span><br><span class="line">                &lt;Tbody items=&#123;<span class="keyword">this</span>.props.data&#125; sortBy=&#123;<span class="keyword">this</span>.state.sortBy&#125;/&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里，传递给子级组件Thead一个回调函数handleClick，回调函数触发时调用this.setState()来改变组件的state。由于点击事件是绑定在Thead的子级TheadCell上的，所以我这里的处理方法就是让Thead把回调函数handleClick再传递给下一子级TheadCell。Thead是这样子处理的：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  Thead = React.createClass(&#123;</span><br><span class="line">    returnSort: <span class="function"><span class="keyword">function</span><span class="params">(v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.props.sort(v);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;thead&gt;</span><br><span class="line">                &lt;caption&gt;点击表格头部进行排序&lt;/caption&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;TheadCell bubbleClick=&#123;<span class="keyword">this</span>.returnSort&#125; content=&#123;<span class="keyword">this</span>.props.uid&#125; /&gt;</span><br><span class="line">                    &lt;TheadCell bubbleClick=&#123;<span class="keyword">this</span>.returnSort&#125; content=&#123;<span class="keyword">this</span>.props.name&#125; /&gt;</span><br><span class="line">                    &lt;TheadCell bubbleClick=&#123;<span class="keyword">this</span>.returnSort&#125; content=&#123;<span class="keyword">this</span>.props.tel&#125; /&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">            &lt;/thead&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>把TheadCell的回调作为回调sort的一个过渡。</p>
<p>最后，需要知道鼠标点击的是哪一个表头字段（uid,name还是tel）。React提供的获取标签值得方法是refs，所以 th 标签需要知道一个ref属性，我把它的值叫做getSortKey，也就是用来排序的字段。通过getDOMNode获取到UI的具体节点。在这里需要说明的一点就是，React里面给标签对象注册事件必须使用基于元素的DOM0级事件注册，而且是用驼峰格式。比如注册点击事件onClick。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  TheadCell = React.createClass(&#123;</span><br><span class="line">    handler: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.props.bubbleClick(<span class="keyword">this</span>.refs.getSortKey.getDOMNode().innerHTML);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;th ref=<span class="string">"getSortKey"</span> title=<span class="string">"点击此键进行排序"</span> onClick=&#123;<span class="keyword">this</span>.handler&#125;&gt;&#123;<span class="keyword">this</span>.props.content&#125;&lt;/th&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>接下来就是双向数据流绑定的重要一步，也就是组件state改变之后UI如何实时响应并重新渲染绘制。这一步是发生在Tbody组件上面的，关键的地方在于表格tbody的绘制必须要由state计算而来，这样state的改变才会导致UI的重新绘制：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Tbody = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> row = [],</span><br><span class="line">            userlist = <span class="keyword">this</span>.props.items,</span><br><span class="line">                cmpKey = <span class="string">""</span>,</span><br><span class="line">                    sortBy = <span class="keyword">this</span>.props.sortBy;</span><br><span class="line">        <span class="comment">// 获取需要拿来比较的字段</span></span><br><span class="line">        <span class="keyword">for</span> (it <span class="keyword">in</span> userlist[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(sortBy == it)&#123;</span><br><span class="line">                cmpKey = it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有排序键，进行排序</span></span><br><span class="line">        <span class="keyword">if</span> (cmpKey)&#123;</span><br><span class="line">            userlist.sort(<span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[cmpKey] &lt; b[cmpKey])&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a[cmpKey] &gt; b[cmpKey])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 排序后的table</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> userlist)&#123;</span><br><span class="line">            row.push(&lt;Cell userItem=&#123;<span class="keyword">this</span>.props.items[item]&#125; key=&#123;item&#125;/&gt;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;tbody&gt;</span><br><span class="line">                &#123;row&#125;</span><br><span class="line">            &lt;/tbody&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="本篇结语">本篇结语</h1><p>这一篇主要是介绍怎么样去使用React制作组件，这是入门级别的说明。想要更多地了解React.js的朋友可以进入<a href="http://reactjs.cn/" target="_blank" rel="external">官方文档</a>进行深入学习。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于React.js的相关背景知识以及它的核心概念已经在<a href="http://hugzh.github.io/2015/09/11/React-js%E9%82%A3%E4%BA%9B%E4%BA%8B-%E4%BB%8B%E7%BB%8D%E7%AF%87/">上一篇文章</a>里面说过。在这一篇里面，我通过一个组件开发的实例简单介绍如何使用React进行web组件开发。</p>
<p>先来介绍一下这个打算实现的组件的功能：这是一个简单的三列表格，包含用户id，用户名，电话号码三列。当用户点击表头thead的单元时，表格会根据点中的列的字段进行升序排序。<br>]]>
    
    </summary>
    
      <category term="React" scheme="http://hugzh.github.io/tags/React/"/>
    
      <category term="组件化开发" scheme="http://hugzh.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    
      <category term="前端开发" scheme="http://hugzh.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React.js那些事(介绍篇)]]></title>
    <link href="http://hugzh.github.io/2015/09/11/React-js%E9%82%A3%E4%BA%9B%E4%BA%8B-%E4%BB%8B%E7%BB%8D%E7%AF%87/"/>
    <id>http://hugzh.github.io/2015/09/11/React-js那些事-介绍篇/</id>
    <published>2015-09-11T05:28:05.000Z</published>
    <updated>2016-01-04T05:56:45.868Z</updated>
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>WEB前端开发的发展历史大概经过了“原始时代——类库时代——工程构建时代——模块化时代”。目前前端领域的发展正处在一个空前繁荣的阶段——“模块化/组件化时代”。</p>
<h2 id="原始时代">原始时代</h2><p>曾几何时，前端开发在软件工程的技术栈里面只被视为设计类岗位，甚至现在为止也有一些小企业依然把前端的职责视为简单的编写html+css页面。早期的前端开发完全依赖于后端技术，所有的数据渲染都由后端开发者进行，界面源码和后台逻辑代码混在一起。这个时代的前端无疑是非常薄的，薄到“网页开发人员”的入门门槛几乎低至为零。<br><a id="more"></a></p>
<h2 id="类库时代">类库时代</h2><p>这一阶段出现了对js封装的各种类库，代表作当然就是前端领域从业者无所不知的jquery库啦。类库时代的开发者承担了很大一部分数据交互的工作。借鉴于AJAX，开发过程可以实现很好的前后端分离，MVC开发框架日益盛行。这个时代，前端开发者在一定程度上摆脱了对后端的严重依赖，使得前后端开发依赖于接口，大大加快了开发效率。</p>
<h2 id="工程构建时代">工程构建时代</h2><p>基于各种自动化构建工具部署前端代码是这一时代的基本特征，前端发展到今天，自动化构建依然是当前的技术主流，Grunt,gulp.js以及国内的Fis等都是自动化代码优化和部署的热门工具。</p>
<h2 id="模块化时代">模块化时代</h2><p>模块化时代标志着前端开发正式进入工程化阶段，“前端工程师”正式成为名副其实的“工程师”。我之所以这样认为是因为这一阶段前端开发可以完全实现代码的重用，实现模块化开发，系统化、规范化的软件开发就是“软件工程”。所以前端工程师也就是在这一阶段日渐活跃，需求量也迅猛增长。前端模块时代的技术代表就是Require.js以及国内的sea.js这样的模块加载器。在MVC开发模式的基础上实现了对视图层的模块化开发，MVC框架至此达到一个鼎盛阶段。<br>然而前端之所以迷人在于新的开发模式和技术不会停止出现，不同的应用需求催生了新的开发技术的诞生。最近几年，组件化开发正成为前端领域的潮流，组件开发减少了代码的耦合，非常适合大型网站应用的开发（这类大型网站的特点就是大量的模块类似或者重复）。可实现代码高度重用的MVVM框架开发进入开发者眼中——这就是React.js的诞生背景</p>
<h1 id="React-js">React.js</h1><h2 id="React是什么东西？">React是什么东西？</h2><p>来自官网的介绍：</p>
<ul>
<li>仅仅是UI<br>许多人使用React作为MVC架构的V层。尽管React并没有假设过你的其余技术栈，但它仍可以作为一个小特征轻易地在已有项目中使用。</li>
<li>虚拟DOM<br>React为了更高超的性能而使用虚拟DOM作为其不同的实现。它同时也可以由服务端Node.js渲染而不需要过重的浏览器DOM支持。</li>
<li>数据流<br>React实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。</li>
</ul>
<p>也就是说，React是一个视图层的应用，并且是一个高效的视图。React提供了和以往不一样的方式来看待视图，它以组件开发为基础。对React应用而言，你需要分割你的页面，使其成为一个个的组件。也就是说，你的应用是由这些组件组合而成的。组件本身可以实现数据流的的单向流动，实现独立开发。这就是我们所说的“组件驱动开发”。</p>
<h2 id="虚拟DOM">虚拟DOM</h2><p>React的一大特点是其所拥有的虚拟DOM，它让页面渲染变得非常的高效，并且比直接操纵DOM变得更为可控。由于虚拟DOM的绘制是在内存里面进行的，高效是它的特征。这两大特点的组合使得React具有强大的自上而下的页面渲染能力。</p>
<p>React提供了一个观察者模型用于替代传统的脏检查（dirty checking）， 也就是持续的检查模型的变化。这也就是解释了为什么React不需要计算哪些发生了改变的原因，因为它根据state的变化会立即知道。这个过程减少了DOM操作，并让应用程序变得更平滑。我们知道DOM操作是非常耗性能的，更少的DOM操作意味着更高效的渲染。React在底层实现了一个diffing算法，该算法使用DOM的树形表示法，当某个 节点发生变化（标记为dirty）时它会重新计算整个子树，你会注意到你的模型发生了改变，因为整个子树在之后会被重新渲染。</p>
<h2 id="JSX">JSX</h2><p>JSX是什么鬼？？？JSX是一个看起来很像XML的JavaScript语法扩展。React可以用来做简单的JSX句法转换。React提供了（也是建议使用）JSX代替JS进行组件绘制，然后运行的时候使用一个JSX编译器进行转换。JSX的使用还是比较简单的：<br>要渲染 HTML 标签，只需在 JSX 里使用小写字母开头的标签名。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myDivElement = &#60;div className=&#34;foo&#34; /&#62;;&#10;React.render(myDivElement, document.body);</span><br></pre></td></tr></table></figure></p>
<p>要渲染 React 组件，只需创建一个大写字母开头的本地变量。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var MyComponent = React.createClass(&#123;/*&#19968;&#20123;&#20195;&#30721;*/&#125;);&#10;var myElement = &#60;MyComponent someProperty=&#123;true&#125; /&#62;;&#10;React.render(myElement, document.body);</span><br></pre></td></tr></table></figure></p>
<h1 id="本节结语">本节结语</h1><p>关于React.js的入门介绍暂时到这里，想要更多地了解React.js的朋友可以进入<a href="http://reactjs.cn/" target="_blank" rel="external">官方文档</a>进行学习。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="引言">引言</h1><p>WEB前端开发的发展历史大概经过了“原始时代——类库时代——工程构建时代——模块化时代”。目前前端领域的发展正处在一个空前繁荣的阶段——“模块化/组件化时代”。</p>
<h2 id="原始时代">原始时代</h2><p>曾几何时，前端开发在软件工程的技术栈里面只被视为设计类岗位，甚至现在为止也有一些小企业依然把前端的职责视为简单的编写html+css页面。早期的前端开发完全依赖于后端技术，所有的数据渲染都由后端开发者进行，界面源码和后台逻辑代码混在一起。这个时代的前端无疑是非常薄的，薄到“网页开发人员”的入门门槛几乎低至为零。<br>]]>
    
    </summary>
    
      <category term="React" scheme="http://hugzh.github.io/tags/React/"/>
    
      <category term="virtual dom" scheme="http://hugzh.github.io/tags/virtual-dom/"/>
    
      <category term="前端开发" scheme="http://hugzh.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Flexbox 布局]]></title>
    <link href="http://hugzh.github.io/2015/09/02/Flexbox-%E5%B8%83%E5%B1%80/"/>
    <id>http://hugzh.github.io/2015/09/02/Flexbox-布局/</id>
    <published>2015-09-02T03:57:07.000Z</published>
    <updated>2016-01-04T06:23:25.240Z</updated>
    <content type="html"><![CDATA[<h1 id="1、简述">1、简述</h1><p>Flex布局也叫“弹性盒子布局”，用来为盒状模型提供最大的灵活性。弹性布局的主要思想是让容器有能力来改变项目的宽度和高度，以填满可用空间（主要是为了容纳所有类型的显示设备和屏幕尺寸）的能力。<br>最重要的是弹性盒子布局与方向无关，相对于常规的布局（块是垂直和内联水平为基础），很显然，这些工作以及网页设计缺乏灵活性，无法支持大型和复杂的应用程序（特别当它涉及到改变方向，缩放、拉伸和收缩等）。</p>
<p>由于flexbox是一个整体模块，而不是单一的一个属性，它涉及到了很多东西，包括它的整个属性集。它们之中有一些是在父容器上设置，而有一些则是在子容器上设置。<br><a id="more"></a></p>
<h2 id="2、flexbox属性详解">2、flexbox属性详解</h2><p>首先，需要看看整个弹性盒子的组成，先看下面一个图：<br><img src="http://img.caibaojian.com/uploads/2014/05/flexbox.png" alt="flexbox"></p>
<p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>
<h2 id="3、容器的flex属性">3、容器的flex属性</h2><p>首先，定义一个flex容器的方法:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.container</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">display</span>:<span class="value"> -webkit-flex</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>; <span class="comment">/* or inline-flex */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>容器的属性包括6个：</p>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content<h3 id="3-1、flex-direction属性">3.1、flex-direction属性</h3>该属性决定主轴的方向，包括4个值：</li>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。<br><img src="https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-direction1.svg" alt="flex-direction"></li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.container</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">flex-direction</span>:<span class="value"> row | row-reverse | column | column-reverse</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2、flex-wrap属性">3.2、flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br>一共3个值，</p>
<ul>
<li>nowrap:(默认)不换行</li>
<li>wrap：换行</li>
<li>wrap-reverse：按照从左往右，换行之后从右到左，再换行从左到右这样的顺序排列<br><img src="https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-wrap.svg" alt="flex-wrap"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.container</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">flex-wrap</span>:<span class="value"> nowrap | wrap | wrap-reverse</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-3、flex-flow属性">3.3、flex-flow属性</h3><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.container</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;</span><br><span class="line">&#125;</span></span></span></span><br></pre></td></tr></table></figure>
<h3 id="3-4、justify-content属性">3.4、justify-content属性</h3><p>定义主轴上面的对齐方式，帮助灵活或者不灵活的元素在未占满整行的时候分布多余的空间。包括5个值：</p>
<ul>
<li>flex-start（默认值）：主轴开始方向对齐</li>
<li>flex-end：主轴结束方向对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg" alt="justify-content"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.container</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">justify-content</span>:<span class="value"> flex-start | flex-end | center | space-between | space-around</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-5、align-items属性">3.5、align-items属性</h3><p>align-items属性定义项目在交叉轴上如何对齐。包括5个值：</p>
<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg" alt="align-items"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.container</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">align-items</span>:<span class="value"> flex-start | flex-end | center | baseline | stretch</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6、align-content属性">3.6、align-content属性</h3><p>定义交叉抽上面有多余空间时的对齐方式。类似于主轴上面对齐的justify-content属性。如果项目只有一根轴线，该属性不起作用。<br>该属性可以取6个值：</p>
<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
</ul>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2013/04/align-content.svg" alt="align-content"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.container</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">align-content</span>:<span class="value"> flex-start | flex-end | center | space-between | space-around | stretch</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="4、子元素（项目）的属性">4、子元素（项目）的属性</h2><p>弹性布局元素的子元素的属性包括6个：</p>
<ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ul>
<h3 id="4-1、order属性">4.1、order属性</h3><p>子元素默认是按照代码声明的顺序铺层的，可以通过order值指定某个子元素的排序。order的取值为整数（可以是负数，默认0）<br><img src="https://cdn.css-tricks.com/wp-content/uploads/2013/04/order-2.svg" alt="order"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.item</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">order</span>:<span class="value"> &lt;integer&gt;</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2、flex-grow属性">4.2、flex-grow属性</h3><p>该属性定义弹性布局子元素的“生长”能力。</p>
<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br><img src="https://cdn.css-tricks.com/wp-content/uploads/2014/05/flex-grow.svg" alt="flex-grow"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.item</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">flex-grow</span>:<span class="value"> &lt;number&gt;</span></span>; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3、flex-shrink属性">4.3、flex-shrink属性</h3><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。不允许为负数。</p>
<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.item</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">flex-shrink</span>:<span class="value"> &lt;number&gt;</span></span>; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-4、flex-basis属性">4.4、flex-basis属性</h3><p>定义剩余空间未分配之前的元素默认尺寸。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.item</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">flex-basis</span>:<span class="value"> &lt;length&gt; | auto</span></span>; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-5、flex属性">4.5、flex属性</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会自动推算其它相关值。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.item</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">flex</span>:<span class="value"> none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span></span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-6、align-self属性">4.6、align-self属性</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该元素包括6个值。<br><img src="https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-self.svg" alt="align-self"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.item</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">align-self</span>:<span class="value"> auto | flex-start | flex-end | center | baseline | stretch</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>本文参考CSS-TRICKS上的文章<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external">A Complete Guide to Flexbox</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1、简述">1、简述</h1><p>Flex布局也叫“弹性盒子布局”，用来为盒状模型提供最大的灵活性。弹性布局的主要思想是让容器有能力来改变项目的宽度和高度，以填满可用空间（主要是为了容纳所有类型的显示设备和屏幕尺寸）的能力。<br>最重要的是弹性盒子布局与方向无关，相对于常规的布局（块是垂直和内联水平为基础），很显然，这些工作以及网页设计缺乏灵活性，无法支持大型和复杂的应用程序（特别当它涉及到改变方向，缩放、拉伸和收缩等）。</p>
<p>由于flexbox是一个整体模块，而不是单一的一个属性，它涉及到了很多东西，包括它的整个属性集。它们之中有一些是在父容器上设置，而有一些则是在子容器上设置。<br>]]>
    
    </summary>
    
      <category term="css" scheme="http://hugzh.github.io/tags/css/"/>
    
      <category term="flexbox" scheme="http://hugzh.github.io/tags/flexbox/"/>
    
      <category term="前端开发" scheme="http://hugzh.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javascript之Location对象]]></title>
    <link href="http://hugzh.github.io/2015/08/15/javascript%E4%B9%8BLocation%E5%AF%B9%E8%B1%A1/"/>
    <id>http://hugzh.github.io/2015/08/15/javascript之Location对象/</id>
    <published>2015-08-15T04:55:22.000Z</published>
    <updated>2016-01-04T06:23:14.584Z</updated>
    <content type="html"><![CDATA[<h1 id="Location对象">Location对象</h1><p>location对象是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。location对象既是window对象的属性，也是document对象的属性，window.location和document.location是引用同一个对象。<br><a id="more"></a></p>
<h2 id="location对象的所有属性">location对象的所有属性</h2><ul>
<li>hash          //返回URL中的hash(#后面跟的零个或者多个字符),如果URL中不包含散列，则返回空字符串</li>
<li>host          //返回服务器的名称和端口（如果有）</li>
<li>hostname      //返回不带端口的服务器名称</li>
<li>href          //返回当前加载页面的完整URL，location对象的toString()方法也是返回这个值</li>
<li>pathname      //返回URL中的路径</li>
<li>port          //返回URL中指定的端口号，没有包含则为空</li>
<li>ptotocol      //返回这个页面使用的协议</li>
<li>search        //返回查询字符串，比如“?q=javascript”<br>我想在这里讨论的是location对象的hash属性及其用法</li>
</ul>
<h2 id="关于hash">关于hash</h2><h4 id="“#”的含义">“#”的含义</h4><p>“#”代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如,”<a href="http://www.example.com/index.html#print" target="_blank" rel="external">http://www.example.com/index.html#print</a>“<br>就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。<br>为网页位置指定标识符，有两个方法。一是使用锚点，比如<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"print"</span>&gt;</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>二是使用id属性，比如<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"print"</span> &gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="HTTP请求不包括”#”">HTTP请求不包括”#”</h4><p>“#”是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括“#”。在第一个“#”后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。</p>
<h4 id="改变“#”后面的字符不触发网页重载">改变“#”后面的字符不触发网页重载</h4><p>单单改变“#”后的部分，浏览器只会滚动到相应位置，不会重新加载网</p>
<h4 id="改变“#”会改变浏览器的访问历史">改变“#”会改变浏览器的访问历史</h4><p>每一次改变“#”后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置。<br>这对于ajax应用程序特别有用，可以用不同的“#”值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。<br>值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。</p>
<h4 id="监听hash值变化的方法">监听hash值变化的方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = func;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">onhashchange</span>=<span class="value">"func();"</span>&gt;</span></span><br><span class="line">window.addEventListener("hashchange", func, false);</span></span><br></pre></td></tr></table></figure>
<p>其中，onhashchange是一个html5的事件。当“#”值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0+支持该事件。对于不支持onhashchange的浏览器，可以用setInterval监控location.hash的变化。</p>
<h4 id="Google抓取“#”的机制">Google抓取“#”的机制</h4><p>默认情况下，Google的网络蜘蛛忽视URL的#部分。<br>但是，Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用”#!”，Google会自动将其后面的内容转成查询字符串<em>escaped_fragment</em>的值。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Location对象">Location对象</h1><p>location对象是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。location对象既是window对象的属性，也是document对象的属性，window.location和document.location是引用同一个对象。<br>]]>
    
    </summary>
    
      <category term="hash" scheme="http://hugzh.github.io/tags/hash/"/>
    
      <category term="location" scheme="http://hugzh.github.io/tags/location/"/>
    
      <category term="前端开发" scheme="http://hugzh.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用Cleaver制作html5幻灯]]></title>
    <link href="http://hugzh.github.io/2015/07/07/cleaver-make-ppt/"/>
    <id>http://hugzh.github.io/2015/07/07/cleaver-make-ppt/</id>
    <published>2015-07-07T15:24:02.000Z</published>
    <updated>2016-01-04T06:24:54.914Z</updated>
    <content type="html"><![CDATA[<p>Cleaver是一款基于html5的插件，依赖于Markdown文档格式，可以用来快速地制作幻灯片。这里主要是讲一讲如何安装和使用Cleaver制作炫酷幻灯片。<br><a id="more"></a></p>
<h3 id="1-Cleaver安装"><strong>1.Cleaver安装</strong></h3><p>通过nodejs来安装Cleaver，而且只支持Linux系统，windows下暂时不支持。</p>
<p>进入新建好的文件夹demo，使用命令 npm install cleaver -g ，即可安装完成。</p>
<h3 id="2-Cleaver基本使用"><strong>2.<span style="color: #000000;">Cleaver基本使用</span> </strong></h3><p>执行cleaver命令，解析一个markdown文件。用cleaver自带的例子：</p>
<p><code>cleaver node_modules/cleaver/examples/basic.md</code></p>
<p>basic.md的内容是这样的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">title: Basic Example</span><br><span class="line">author:</span><br><span class="line">name: Jordan Scales</span><br><span class="line">twitter: jdan</span><br><span class="line">url: http://jordanscales.com</span><br><span class="line">output: basic.html</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"></span><br><span class="line"># Cleaver 101</span><br><span class="line">## A first look at quick HTML presentations</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">### A textual example</span><br><span class="line"></span><br><span class="line">Content can be written in **Markdown!** New lines no longer need two angle brackets.</span><br><span class="line"></span><br><span class="line">This will be in a separate paragraph.</span><br><span class="line"></span><br><span class="line">&lt;img src="http://whatismarkdown.com/workspace/img/logo.gif" alt="Drawing" style="width: 150px;"/&gt;</span><br><span class="line"></span><br><span class="line">![markdown-logo](logo.gif)</span><br><span class="line">&lt;img src="logo.gif" /&gt;</span><br><span class="line"></span><br><span class="line">[Here's a link](http://google.com).</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">### A list of things</span><br><span class="line"></span><br><span class="line">* Item 1</span><br><span class="line">* Item B</span><br><span class="line">* Item gamma</span><br><span class="line"></span><br><span class="line">No need for multiple templates! [Another link](http://google.com).</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">### Unicode</span><br><span class="line"></span><br><span class="line">* 林花謝了春紅 太匆匆</span><br><span class="line">* 胭脂淚 留人醉 幾時重</span><br><span class="line">* Matching Pairs «»‹› “”‘’「」〈〉《》〔〕</span><br><span class="line">* Greek αβγδ εζηθ ικλμ νξοπ ρςτυ φχψω</span><br><span class="line">* currency ¤ $ ¢ € ₠ £ ¥</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">### A code example</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">// cool looking code</span><br><span class="line">var func = function (arg1) &#123;</span><br><span class="line">return function (arg2) &#123;</span><br><span class="line">return "arg1: " + arg1 + "arg2: " + arg2;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(func(1)(2)); // result is threeAnd here is some `inline code` to check out.</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>然后打开该目录下的basic.html即可查看幻灯</p>
<p><a href="http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/07/cleaver-firefox.png" target="_blank" rel="external"><img src="http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/07/cleaver-firefox-300x217.png" alt="" title="cleaver-firefox"></a></p>
<h3 id="3-简单做一些配置："><strong>3.简单做一些配置：</strong></h3><p>1). title: HTML的标题名</p>
<p>2). author: 作者信息,在最后一页显示</p>
<p>包括下面信息：</p>
<ul>
<li>name: 名字</li>
<li>url: 个人网站</li>
<li>twitter: 微博</li>
<li>email: 邮件地址<br>3). theme: 皮肤(theme: jdan/cleaver-retro)</li>
</ul>
<p>4). style: css样式表(style: css/main.css)</p>
<p>5). output: 生成的HTML文件名(output: basic.html)</p>
<p>6). controls: 控制按钮(controls: true)</p>
<p>7). progress: 顶部显示进程条(progress: true)</p>
<p>8). agenda: 生成一个目录页(progress: false)</p>
<p>9). encoding: 文档的字符编码(encoding: utf-8)</p>
<p>10). template: 设置每张slide的模板(template: template/slide.mustache)</p>
<p>11). layout: 设置HTML模板(template: template/layout.mustache)</p>
<h3 id="4-正文"><strong>4.正文</strong></h3><p>正文必须使用Markdown语法。</p>
<p>&nbsp;</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Cleaver是一款基于html5的插件，依赖于Markdown文档格式，可以用来快速地制作幻灯片。这里主要是讲一讲如何安装和使用Cleaver制作炫酷幻灯片。<br>]]>
    
    </summary>
    
      <category term="cleaver" scheme="http://hugzh.github.io/tags/cleaver/"/>
    
      <category term="幻灯" scheme="http://hugzh.github.io/tags/%E5%B9%BB%E7%81%AF/"/>
    
      <category term="前端开发" scheme="http://hugzh.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从AJAX的使用到爬虫友好到SEO优化]]></title>
    <link href="http://hugzh.github.io/2015/05/14/from-ajax-to-seo/"/>
    <id>http://hugzh.github.io/2015/05/14/from-ajax-to-seo/</id>
    <published>2015-05-14T13:26:09.000Z</published>
    <updated>2016-01-04T06:25:11.953Z</updated>
    <content type="html"><![CDATA[<p>&nbsp;</p>
<h1 id="关于Ajax的使用注意">关于Ajax的使用注意</h1><p>最近做爬虫项目的时候发现一个比较值得探讨的问题：由于Ajax的无刷新加载特性，web开发者都比较喜欢使用ajax进行与服务器的数据交互。很多DOM元素都是在基本DOM文档加载完毕之后再进行加载的。这种做法虽然对用户非常友好，但是有时候对于程序（搜索引擎）来说，页面信息获取也会带来一些挑战。<br><a id="more"></a></p>
<h2 id="1-_关于异步加载">1.  关于异步加载</h2><p>Ajax的使用是非常广泛的。作为前端开发者，我们往往喜欢JSON数据这种交互模式,所以在渲染页面的时候也倾向于使用ajax从服务器获取JSON数据，从而实现无刷新渲染。这么做对于用户体验肯定是加分的。但是大规模地使用Ajax有时候会使得爬虫很难去获得想要的数据，当然如果我们设计的网站本身就是不想要别人抓取到数据的那就另当别论（除此之外还要加上一些JS动态加载数据以及数据编码等开发方式）。</p>
<p>我们知道，所谓的网络“爬虫” ，就是通过一些http的request模块获取某个URL对应的页面的整个html文档，然后根据一些XPath或者CSS路径语法提取出文档的DOM节点内容，从而获取想要的数据。因此，如果这个页面的重要数据是通过JS执行Ajax来实现的话，就要求爬虫自己去模拟JS事件的触发（这种情况出现最多的就是”load more“这种情景）。甚至有时候如果封装的函数和要传输的参数太过复杂的话，爬虫根本无法通过模拟事件获取最新数据。这样无形之中就会使得爬虫无法抓取更多的网页数据。也就是对爬虫不友好。当然，很多脚本语言已经实现了很多对于事件模拟的模块，但是如果在不是非常必要的情况下，我觉得还是不要滥用Ajax。 那么，爬虫在获取JSON数据的时候具体是怎样工作的呢？我这里举一个处理样例，这个例子是基于Nodejs的Osmosis插件做的爬虫处理。<br>首先  ，我们先来看看这个AJAX的访问url “<a href="http://russia.tv/video/json/menu_id/267?page=4" target="_blank" rel="external">http://russia.tv/video/json/menu_id/267?page=4</a>“ ,访问这个URL得到的数据格式如图：</p>
<p><a href="http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/05/捕获.jpg" target="_blank" rel="external"><img src="http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/05/捕获-300x89.jpg" alt="" title="捕获JSON"></a></p>
<p>我们需要的仅仅是里面的’url’键对应的值，所以爬虫可以这样去提取数据：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var json_text = JSON.parse(data.json);</span><br><span class="line">// get flower</span><br><span class="line">// &#123;<span class="string">"last_page"</span>:<span class="number">0</span>,<span class="string">"row_list"</span>:[&#123;<span class="string">"url"</span>:<span class="string">'xxxxx'</span>&#125;]&#125;</span><br><span class="line">var urls = [];</span><br><span class="line"> <span class="number">_</span>.each(json_text.row_list, <span class="keyword">function</span> (url) &#123;</span><br><span class="line"></span><br><span class="line">     urls.push(&#123;</span><br><span class="line">        url: url.url</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="2-搜索引擎优化(SEO)">2.搜索引擎优化(SEO)</h2><p>既然聊到了爬虫，那么第二个我想说的问题就是关于SEO。爬虫只是人工搜索数据的一种手段，但是更高级别的大规模数据搜索往往是谷歌百度等搜索引擎。这类的搜索引擎是使用robots来进行数据挖掘的。这就要求前端开发者需要做一些页面优化，使得自己的站点可以更好的被搜索引擎发现。这就是SEO的主要内容，比较简单的SEO方法就是添加meta标签。meta是用来在HTML文档中模拟HTTP协议的响应头报文。META标签是HTML语言HEAD区的一个辅助性标签，它位于HTML文档头部的&lt;HEAD&gt;标记和&lt;TITLE&gt;标记之间，它提供用户不可见的信息。以下是几种meta标签的用法：</p>
<div align="left">1、&lt;meta name=”Generator” content=””&gt;用以说明生成工具（如Microsoft FrontPage 4.0）等；</div><br><div align="left">2、&lt;meta name=”KEYWords”  content=””&gt;向搜索引擎说明你的网页的关键词；</div><br><div align="left">3、&lt;meta name=”DEscription”  content=””&gt;告诉搜索引擎你的站点的主要内容；</div><br><div align="left">4、&lt;meta name=”Author”  content=”你的姓名”&gt;告诉搜索引擎你的站点的制作的作者；</div><br><div align="left">5、&lt;meta name=”Robots”  content= “all|none|index|noindex|follow|nofollow”&gt;</div><br><div align="left">　 其中的属性说明如下：</div><br><div align="left">　 设定为all：文件将被检索，且页面上的链接可以被查询；</div><br><div align="left">   设定为none：文件将不被检索，且页面上的链接不可以被查询；</div><br><div align="left">   设定为index：文件将被检索；</div><br><div align="left">   设定为follow：页面上的链接可以被查询；</div><br><div align="left">   设定为noindex：文件将不被检索，但页面上的链接可以被查询；</div><br><div align="left">   设定为nofollow：文件将不被检索，页面上的链接可以被查询。</div><br><div align="left"> 还有一种比较常见的meta标签是用户社交（<strong>Open Graph Protocol</strong>）。我们可以发现很多网页的head里面包含&lt;meta property=”og:title” content=”xxx”&gt;这样的标签。</div><br><div align="left">Meta Property=og标签是什么呢?og是一种新的HTTP头部标记，即Open Graph Protocol。即这种协议可以让网页成为一个“富媒体对象”。</div>

<p>用了Meta Property=og标签，就是你同意了网页内容可以被其他社会化网站引用等，目前这种协议被SNS网站如Fackbook、renren采用。SNS已经成为网络上的一大热门应用，优质的内容通过分享在好友间迅速传播。为了提高站外内容的传播效率，2010年F8会议上Facebook公布 了一套开放内容协议(Open Graph Protocol)，任何网页只要遵守该协议，SNS就能从页面上提取最有效的信息并呈现给用户。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&nbsp;</p>
<h1 id="关于Ajax的使用注意">关于Ajax的使用注意</h1><p>最近做爬虫项目的时候发现一个比较值得探讨的问题：由于Ajax的无刷新加载特性，web开发者都比较喜欢使用ajax进行与服务器的数据交互。很多DOM元素都是在基本DOM文档加载完毕之后再进行加载的。这种做法虽然对用户非常友好，但是有时候对于程序（搜索引擎）来说，页面信息获取也会带来一些挑战。<br>]]>
    
    </summary>
    
      <category term="SEO" scheme="http://hugzh.github.io/tags/SEO/"/>
    
      <category term="爬虫" scheme="http://hugzh.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Nodejs" scheme="http://hugzh.github.io/categories/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用nodejs做一个新闻网页爬虫——Nodejs初体验]]></title>
    <link href="http://hugzh.github.io/2015/04/16/node-spider/"/>
    <id>http://hugzh.github.io/2015/04/16/node-spider/</id>
    <published>2015-04-16T12:45:12.000Z</published>
    <updated>2016-01-04T08:52:21.147Z</updated>
    <content type="html"><![CDATA[<p>昨天在leader的要求下做了一个小小的作业，作为近期项目的一个入门练习。要写的是一个网页爬虫，使用node来爬取网易新闻页 <a href="http://news.163.com" target="_blank" rel="external">http://news.163.com</a> 的首页所有的新闻连接，存入urls.txt文件。然后从urls.txt文件中选取一条url进行新闻内容的爬取，存入news.txt文件中。<br><a id="more"></a><br>本来对nodejs的了解仅仅停留在“hello world”的水平，虽然很早就曾打算学习这们传说中无比流弊的语言，无奈最近因为找实习各种事务缠身，始终没时间深入研究node。好在leader给我们的任务恰恰成为我学习node的推动力，哈哈。</p>
<p>回到刚才说的任务，网页爬虫。既然是对网页内容的提取，首先必须得搭建好一个良好的架构。主要是两个方面：一个是对整个页面的爬取，另一个就是对页面关键词的提取。爬取页面肯定要用到node的http模块，在这里我是用了http.get的方法。对于页面元素的提取，我是用了最近刚刚接触过的cheerio这样一个库，这是一个非常轻量型的第三方插件，它的使用语法和jQuery几乎完全一样。比如选择器的语法：<br>$(selectior,[context],[root])</p>
<p>选择器在 Context 范围内搜索，Context又在Root范围内搜索。selector 和context可是一个字符串表达式，DOM元素，和DOM元素的数组，或者chreeio对象。root 是通常是HTML 文档字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.apple'</span>, <span class="string">'#fruits'</span>).text()</span><br><span class="line"><span class="comment">//=&amp;gt; Apple</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'ul .pear'</span>).attr(<span class="string">'class'</span>)</span><br><span class="line"><span class="comment">//=&amp;gt; pear</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'li[class=orange]'</span>).html()</span><br><span class="line"><span class="comment">//=&amp;gt; &amp;lt;li class="orange"&amp;gt;Orange&amp;lt;/li&amp;gt;</span></span><br></pre></td></tr></table></figure>
<p>又比如获取html元素内容的语法：.text( [textString] )</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.orange'</span>).text()</span><br><span class="line"><span class="comment">//=&amp;gt; Orange</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'ul'</span>).text()</span><br><span class="line"><span class="comment">//=&amp;gt;  Apple</span></span><br><span class="line"><span class="comment">//    Orange</span></span><br><span class="line"><span class="comment">//    Pear&lt;/pre&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是我整个代码的目录结构</p>
<p><a href="http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/04/捕获.jpg" target="_blank" rel="external"><img src="http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/04/捕获-300x112.jpg" alt="" title="捕获"></a></p>
<p>其中app.js就是负责爬取新闻列表页的url，而getNew.js是负责对新闻内容的抓取。这个项目的难点就是中文编码的转码问题，由于网易新闻主页的html编码方式是GBK，而Nodejs本身是不支持GBK字符的读写的，所以抓取下来的新闻内容就会出现乱码。这是Nodejs入门的一个经典案例，花了我很长时间来解决。后来查找资料得知使用iconv插件来进行转码，最终解决了这个烦人的问题。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>)</span><br><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>)</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*get one url from file urls.txt*/</span></span><br><span class="line">fs.readFile(<span class="string">'urls.txt'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(err);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> urlArray = data.split(<span class="string">'\"&#125;,'</span>);</span><br><span class="line">	<span class="keyword">var</span> urlstr = urlArray[<span class="number">0</span>].split(<span class="string">':\"'</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> url = urlstr[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">console</span>.log(url);</span><br><span class="line">	http.get(url,<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">		<span class="comment">//this step is very important</span></span><br><span class="line">		<span class="comment">//it change gbk unicode into binary,avoid error</span></span><br><span class="line"></span><br><span class="line">		res.setEncoding(<span class="string">'binary'</span>);</span><br><span class="line">		<span class="keyword">var</span> article = <span class="string">''</span>;</span><br><span class="line">		res.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">			article += data;</span><br><span class="line">		&#125;).on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(article, <span class="string">'binary'</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//decode the content in gbk unicode</span></span><br><span class="line">			<span class="comment">//depend on plus-in iconv</span></span><br><span class="line">			<span class="keyword">var</span> gbkStr = iconv.decode(buf, <span class="string">'GBK'</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> $ = cheerio.load(gbkStr);</span><br><span class="line">			<span class="keyword">var</span> result = [];</span><br><span class="line">			<span class="keyword">var</span> title = $(<span class="string">'#h1title'</span>).text();</span><br><span class="line">			<span class="keyword">var</span> cont  = <span class="string">''</span>;</span><br><span class="line">			$(<span class="string">'p'</span>,<span class="string">'#endText'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">index,ele</span>)</span>&#123;</span><br><span class="line">				cont+=$(<span class="keyword">this</span>).text();</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			result.push(&#123;ArticleTitle:title,ArticleContent:cont&#125;);</span><br><span class="line">			<span class="keyword">var</span> file = <span class="string">'article.txt'</span>;</span><br><span class="line">			fs.writeFile(file,<span class="built_in">JSON</span>.stringify(result),<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(err)&#123;</span><br><span class="line">					<span class="built_in">console</span>.log(<span class="string">"write file failed"</span>+err);</span><br><span class="line">					<span class="keyword">return</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">		&#125;)</span><br><span class="line">		&#125;).on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(err);</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这就是整个项目的核心代码所在。如果要想查看app.js是如何写的，可以查看我的github地址，<a href="https://github.com/hugzh/node。" target="_blank" rel="external">https://github.com/hugzh/node。</a> 这里就不贴代码了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天在leader的要求下做了一个小小的作业，作为近期项目的一个入门练习。要写的是一个网页爬虫，使用node来爬取网易新闻页 <a href="http://news.163.com">http://news.163.com</a> 的首页所有的新闻连接，存入urls.txt文件。然后从urls.txt文件中选取一条url进行新闻内容的爬取，存入news.txt文件中。<br>]]>
    
    </summary>
    
      <category term="Nodejs" scheme="http://hugzh.github.io/categories/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一道经典的Web前端笔试试题——闭包]]></title>
    <link href="http://hugzh.github.io/2015/03/31/one-interview-closure/"/>
    <id>http://hugzh.github.io/2015/03/31/one-interview-closure/</id>
    <published>2015-03-31T14:29:29.000Z</published>
    <updated>2016-01-04T08:36:48.158Z</updated>
    <content type="html"><![CDATA[<p><strong>    永远不要以为自己学了点javascript的DOM操作就以为自己“学会”了JS这门博大精深的语言，其实是自己图样图森破了！！！其实javascript的真正精髓（难点）在于作用域、原型以及闭包这三个方面。这是成为前端高手之前必须要迈过的一道坎</strong>。<br><a id="more"></a><br>首先我们来看看这样一道题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&amp;lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">a+=i;&#125;,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数咋一看，没什么了不起的嘛。不就是实现从0加到9的和嘛！很简单，就是45。</p>
<p>显然，世界上大多数的事情总是不能按照我们自己编造的剧本发展滴。实际上，这个main函数的返回结果是100！！！Why?这就涉及到我想要讲的闭包问题。</p>
<p>JS的闭包是比较难理解的一个知识点，我到现在也没有完全理解。实际上，在循环内部的每一个函数中都保留着它的外部函数的活动对象，它们都是指向同一个变量i。当外部函数fn()返回后，变量i的值是10，此时每一个函数都保存着变量i的同一个变量对象，所以在每个函数内部的i的值都是10，所以a+=i实际上是等价于a+=10。循环10次之后的结果显然就变成100了！这其实是因为作用域链的配置机制引发的一个副作用，即闭包只能取得包含函数中任何变量的最后一个值。因为闭包所保存的是整个变量对象，而不是某一个特殊值。<br>那如果我非要实现从0到9相加怎么办呢？咱们可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&amp;lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">a+=num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//45</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们没有直接把闭包放进setTimeout函数，而是定义一个匿名函数，并立即执行该匿名函数的结果返回。匿名函数的参数num也就是最终要返回的值。在调用每个匿名函数的时候，我们传入了变量i。由于变量参数是传值的，所以i会复制一个副本给num参数，这样在匿名函数的内部又返回了一个访问num的闭包。所以，每一个内部函数中都有一个自己的num副本，算出来的结果就是0到9相加了，最后结果为45。</p>
<p>我们再来看一道著名互联网公司的实习招聘题目：</p>
<p><a href="http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/03/2.jpg" target="_blank" rel="external"><img src="http://bloghugzh-wordpress.stor.sinaapp.com/uploads/2015/03/2-300x189.jpg" alt="" title="2"></a></p>
<p>这道题的话相对理解起来还是比较容易理解的，如果你搞明白了闭包的含义的话。其实是这样子的：函数a里面有一个匿名函数，这个匿名函数访问了a函数的参数x，形成一个闭包。由于作用域链以及函数声明提前的关系，y函数在代码运行之前就已经预先声明，也就是存在于外部活动变量中，当a函数执行返回的时候，活动变量里面的x值就变成了活动变量里面的X值，即2。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>    永远不要以为自己学了点javascript的DOM操作就以为自己“学会”了JS这门博大精深的语言，其实是自己图样图森破了！！！其实javascript的真正精髓（难点）在于作用域、原型以及闭包这三个方面。这是成为前端高手之前必须要迈过的一道坎</strong>。<br>]]>
    
    </summary>
    
      <category term="js" scheme="http://hugzh.github.io/tags/js/"/>
    
      <category term="前端开发" scheme="http://hugzh.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML5里的placeholder属性]]></title>
    <link href="http://hugzh.github.io/2015/03/26/html5-placeholder/"/>
    <id>http://hugzh.github.io/2015/03/26/html5-placeholder/</id>
    <published>2015-03-26T15:33:49.000Z</published>
    <updated>2016-01-04T13:07:31.710Z</updated>
    <content type="html"><![CDATA[<p>HTML5里新引入很多有趣的新特征；有些体现在HTML里，有些是JavaScript API，全部非常的有用。其中我最喜欢的一个特征就是文本框(INPUT)里的 placeholder 属性。placeholder属性能够让你在文本框里显示提示信息，一旦你在文本框里输入了什么信息，提示信息就会隐藏。你以前可能无数次看到这种效果，但那些大部分是用JavaScript里实现的，而现在，HTML5提供了原生支持，而且效果更好！<br><a id="more"></a></p>
<h2 id="用法:">用法:</h2><p> 需要做的只是在文本框的声明标签上加入 placeholder 属性。完全不需要JavaScript来创造这种效果。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="class"><span class="keyword">type</span></span>=<span class="string">"text"</span> name=<span class="string">"first_name"</span> placeholder=<span class="string">"你的姓名..."</span> /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="检查浏览器是否支持Placeholder属性：">检查浏览器是否支持Placeholder属性：</h2><p>因为 placeholder 是一种新属性，很有必要检查一下你的浏览器是否支持它，比如IE6、IE8肯定是不支持的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlaceholderSupport</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> input = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="string">'placeholder'</span> <span class="keyword">in</span> input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用户的浏览器不支持 placeholder 特征，你需要借助MooTools, Dojo, 或其它JavaScript工具来实现它</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mootools ftw! */</span></span><br><span class="line"><span class="keyword">var</span> firstNameBox = $(<span class="string">'first_name'</span>),</span><br><span class="line">	message = firstNameBox.<span class="keyword">get</span>(<span class="string">'placeholder'</span>);</span><br><span class="line">firstNameBox.addEvents(&#123;</span><br><span class="line">	focus: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(firstNameBox.value == message) &#123; searchBox.value = <span class="string">''</span>; &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	blur: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(firstNameBox.value == <span class="string">''</span>) &#123; searchBox.value = message; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="可以对样式进行CSS美化：">可以对样式进行CSS美化：</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="pseudo">::-webkit-input-placeholder</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#f00</span></span></span>; &#125;</span></span><br><span class="line"><span class="pseudo">::-moz-placeholder</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#f00</span></span></span>; &#125;</span> <span class="comment">/* firefox 19+ */</span></span><br><span class="line"><span class="pseudo">:-ms-input-placeholder</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#f00</span></span></span>; &#125;</span> <span class="comment">/* ie */</span></span><br><span class="line"><span class="rule"><span class="attribute">input</span>:<span class="value">-moz-placeholder &#123; color:<span class="hexcolor">#f00</span></span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* individual: webkit */</span></span><br><span class="line"><span class="id">#field2</span><span class="pseudo">::-webkit-input-placeholder</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#00f</span></span></span>; &#125;</span></span><br><span class="line"><span class="id">#field3</span><span class="pseudo">::-webkit-input-placeholder</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#090</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value">lightgreen</span></span>; <span class="rule"><span class="attribute">text-transform</span>:<span class="value">uppercase</span></span>; &#125;</span></span><br><span class="line"><span class="id">#field4</span><span class="pseudo">::-webkit-input-placeholder</span> <span class="rules">&#123; <span class="rule"><span class="attribute">font-style</span>:<span class="value">italic</span></span>; <span class="rule"><span class="attribute">text-decoration</span>:<span class="value">overline</span></span>; <span class="rule"><span class="attribute">letter-spacing</span>:<span class="value"><span class="number">3px</span></span></span>; <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#999</span></span></span>; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* individual: mozilla */</span></span><br><span class="line"><span class="id">#field2</span><span class="pseudo">::-moz-placeholder</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#00f</span></span></span>; &#125;</span></span><br><span class="line"><span class="id">#field3</span><span class="pseudo">::-moz-placeholder</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#090</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value">lightgreen</span></span>; <span class="rule"><span class="attribute">text-transform</span>:<span class="value">uppercase</span></span>; &#125;</span></span><br><span class="line"><span class="id">#field4</span><span class="pseudo">::-moz-placeholder</span> <span class="rules">&#123; <span class="rule"><span class="attribute">font-style</span>:<span class="value">italic</span></span>; <span class="rule"><span class="attribute">text-decoration</span>:<span class="value">overline</span></span>; <span class="rule"><span class="attribute">letter-spacing</span>:<span class="value"><span class="number">3px</span></span></span>; <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#999</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="#">#</h1><p>你可以控制placeholder文字的字体、颜色和风格。你甚至可以将文本框的placeholder以动画方式显示。 美化你的文本框都是些看起来很小的事情，但对于一些交互式的网站来说，成功的关键就在于细节。现在IE10里也只支持placeholder了，相信越来越多的人会使用这种原生的placeholder效果。</p>
<p>(本文转载自 <a href="http://www.webhek.com/html5-placeholder?rel=http://geek.csdn.net" target="_blank" rel="external">http://www.webhek.com/html5-placeholder?rel=http://geek.csdn.net</a>)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>HTML5里新引入很多有趣的新特征；有些体现在HTML里，有些是JavaScript API，全部非常的有用。其中我最喜欢的一个特征就是文本框(INPUT)里的 placeholder 属性。placeholder属性能够让你在文本框里显示提示信息，一旦你在文本框里输入了什么信息，提示信息就会隐藏。你以前可能无数次看到这种效果，但那些大部分是用JavaScript里实现的，而现在，HTML5提供了原生支持，而且效果更好！<br>]]>
    
    </summary>
    
      <category term="css" scheme="http://hugzh.github.io/tags/css/"/>
    
      <category term="html5" scheme="http://hugzh.github.io/tags/html5/"/>
    
      <category term="前端开发" scheme="http://hugzh.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript操作符使用注意事项]]></title>
    <link href="http://hugzh.github.io/2015/03/11/javascript-op/"/>
    <id>http://hugzh.github.io/2015/03/11/javascript-op/</id>
    <published>2015-03-10T16:00:00.000Z</published>
    <updated>2016-01-04T06:26:01.369Z</updated>
    <content type="html"><![CDATA[<p>javascript 的操作符运算中有很多是可以适用于不同类型的值，这是因为javascript本身是一门变量类型松散型的语言，在使用运算符的时候有很多容易出错的地方。加法和减法这两个运算符是各种开发语言中用得最多的运算符了，但是在ECMAScript中，这两个操作符却有一系列特殊行为。<br><a id="more"></a><br>1、加法：<br>如果+号的两个操作数有一个是字符串，那么就有下面的规则：<br>两个操作数都是字符串的时候，那么结果就是两个字符串拼接；<br>只有一个是字符串，那么将另外一个操作数转化为字符串，然后两个字符串拼接<br>如果有一个操作数是对象、数值或者布尔值，则调用它们的toString()方法取得相应的字符串值，再按照上面的规则。</p>
<p>比如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var res = <span class="number">5</span>+<span class="number">5</span>; <span class="comment">//两个数值相加，结果为10</span></span><br><span class="line">var res2 = <span class="number">5</span>+“<span class="number">5</span>”; <span class="comment">//一个数值和一个字符串相加，结果为"55"</span></span><br></pre></td></tr></table></figure>
<p>编程中常犯的一个错误就是当我们想要得到相加结果，我们很容易这么写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> num1</span> = <span class="number">5</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> num2</span> = <span class="number">10</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> msg</span> = <span class="string">"The sum of 5 and 10 is "</span> + num1 +num2; <span class="comment">//错误结果</span></span><br></pre></td></tr></table></figure>
<p>这样我们得到的结果竟然是“The sum of 5 and 10 is 510”。出现这样的情况就是因为运算规则是从左到右，前面一个加号是字符串和数值相加，根据上面的规则，结果为字符串，然后再进行下一步加法时，还是字符串和数值的相加，结果就会出现上面的错误，正确的写法是将后两个数值相加就和之后再与字符串合并，即：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> num1</span> = <span class="number">5</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> num2</span> = <span class="number">10</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> msg</span> = <span class="string">"The sum of 5 and 10 is "</span> +（ num1 +num2）; <span class="comment">// The sum of 5 and 10 is 15</span></span><br></pre></td></tr></table></figure>
<p>2、减法：<br>减法和加法类似，但是参数转换略有不同，减法的两个操作数其中一个是字符串、布尔值或者对象的时候，后台调用Number() 函数将其转换为数值再进行减法运算。比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> res1</span> = <span class="number">5</span> - <span class="literal">true</span>; <span class="comment">//4，因为true被转换成1</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> res2</span> = <span class="number">5</span> - <span class="string">""</span>; <span class="comment">//5，因为""被转化成0</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> res3</span> = <span class="number">5</span> - <span class="string">"2"</span>; <span class="comment">//3，因为"2"被转化成数值2</span></span><br></pre></td></tr></table></figure>
<p>3、相等操作符：<br>javascript中==和===不一样。前一个是相等操作符，在比较之前会进行类型强制转换，也就是说true==1、null==undefined是成立的。但是后一个操作符是全等操作符，比较之前不会进行类型转换，所以全等的前提是类型和值都相等，关系才成立。</p>
<p>还有很多类似的小细节，使用者在开发过程中一定要注意这些可能造成致命错误的细节。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>javascript 的操作符运算中有很多是可以适用于不同类型的值，这是因为javascript本身是一门变量类型松散型的语言，在使用运算符的时候有很多容易出错的地方。加法和减法这两个运算符是各种开发语言中用得最多的运算符了，但是在ECMAScript中，这两个操作符却有一系列特殊行为。<br>]]>
    
    </summary>
    
      <category term="前端开发" scheme="http://hugzh.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动前端框架jQuery Mobile 的介绍（二）]]></title>
    <link href="http://hugzh.github.io/2015/01/29/jmobile-use-2/"/>
    <id>http://hugzh.github.io/2015/01/29/jmobile-use-2/</id>
    <published>2015-01-28T16:00:00.000Z</published>
    <updated>2016-01-04T06:26:12.213Z</updated>
    <content type="html"><![CDATA[<p>上一篇主要是介绍了jMobile框架的基础知识，在这一篇里，我们主要是介绍<br>表单应用以及基于移动端的各种events。<br><a id="more"></a></p>
<h2 id="一、表单基础：">一、表单基础：</h2><p>在 jQuery Mobile 中，我们可以使用下列表单控件：<br>1、文本输入框<br>2、搜索输入框<br>3、单选按钮<br>4、复选框<br>5、选择菜单<br>6、滑动条<br>7、翻转拨动开关</p>
<p>1~5都是和PC前端的用法一样。其中，滑动条以及翻转拨动按钮是具有移动设备特色的表单。值得注意的是，由于<br>html5的使用，input标签的type值可以是mail、date、search，这是不同于PC端的使用，<br>非常方便。如需让标签和表单元素看起来更适应宽屏，可以用带有data-role=”fieldcontain”<br>属性的<br>div或<br>fieldset元素包围 label/form 元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">form</span> <span class="attribute">method</span>=<span class="value">"post"</span> <span class="attribute">action</span>=<span class="value">"demoform.html"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">data-role</span>=<span class="value">"fieldcontain"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"fname"</span>&gt;</span>姓:<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"fname"</span> <span class="attribute">id</span>=<span class="value">"fname"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"lname"</span>&gt;</span>名:<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"lname"</span> <span class="attribute">id</span>=<span class="value">"lname"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了创建一个可以折叠的表单，可以将表单内容置于带有data-role=”collapsible”</p>
<p>属性的fieldset中。<br>表单滑动条的使用如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"range"</span> <span class="attribute">name</span>=<span class="value">"points"</span> <span class="attribute">id</span>=<span class="value">"points"</span> <span class="attribute">value</span>=<span class="value">"50"</span> <span class="attribute">min</span>=<span class="value">"0"</span> <span class="attribute">max</span>=<span class="value">"100"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的value属性表示滑动条的默认值，min和max是滑动条的取值范围。如果想要高亮突出<br>显示滑动条的值，添加 data-highlight=”true”。</p>
<p>至于拨动按钮开关，用法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">select</span> <span class="attribute">name</span>=<span class="value">"switch"</span> <span class="attribute">id</span>=<span class="value">"switch"</span> <span class="attribute">data-role</span>=<span class="value">"slider"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"on"</span>&gt;</span>On<span class="tag">&lt;/<span class="title">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"off"</span>&gt;</span>Off<span class="tag">&lt;/<span class="title">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以在option里面添加 “selected” 属性来设置选项中的一个为预选中状态（高亮突出显<br>示状态）。</p>
<h2 id="二、页面事件：">二、页面事件：</h2><p>在 jQuery Mobile 中, 使用pageinit 事件来设置代码脚本在DOM元素加载完成后开始<br>执行，所以要在任何新页面加载并创建是执行脚本，就需要绑定pageinit事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">"pageinit"</span>,<span class="string">"#pageone"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>点击事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).on(<span class="string">"tap"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="keyword">this</span>).hide();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>长按事件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$(<span class="string">"p"</span>).on(<span class="string">"taphold"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="keyword">this</span>).hide();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>滑动事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单滑动</span></span><br><span class="line">$(<span class="string">"p"</span>).on(<span class="string">"swipe"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="string">"span"</span>).text(<span class="string">"Swipe detected!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向左滑动</span></span><br><span class="line">$(<span class="string">"p"</span>).on(<span class="string">"swipeleft"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"You swiped left!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向右滑动</span></span><br><span class="line">$(<span class="string">"p"</span>).on(<span class="string">"swiperight"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"You swiped right!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>滚动屏幕事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滚屏开始</span></span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">"scrollstart"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//滚屏结束</span></span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">"scrollstop"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>另外，还有页面加载完成、失败、页面切换等事件，如果需要更加详细地了解jMobile的<br>用法，可以登录官方网站(<a href="http://jquerymobile.com/)去了解更多用法。" target="_blank" rel="external">http://jquerymobile.com/)去了解更多用法。</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇主要是介绍了jMobile框架的基础知识，在这一篇里，我们主要是介绍<br>表单应用以及基于移动端的各种events。<br>]]>
    
    </summary>
    
      <category term="前端开发" scheme="http://hugzh.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动前端框架jQuery Mobile 的介绍（一）]]></title>
    <link href="http://hugzh.github.io/2015/01/28/jmobile-use-1/"/>
    <id>http://hugzh.github.io/2015/01/28/jmobile-use-1/</id>
    <published>2015-01-27T16:00:00.000Z</published>
    <updated>2016-01-04T06:26:07.126Z</updated>
    <content type="html"><![CDATA[<p>简介：<br>jQuery Mobile 是用于创建移动 Web应用的前端开发框架，可以应用于智能手机与平板电脑。是一个比较好用的前端框架。<br>jMobile适用于ios，android，black berry，windows phone等主流移动终端操作系统。<br><a id="more"></a><br>jQuery Mobile 的安装：<br>安装非常简单，就像jQuery的安装一样，可以直接把文件下载到本地，然后再html文件的head标签内引用，也可以直接通过<br>CDN 中加载。需要包含三个文件jquery.mobile.min.css、jquery.js以及jquery.mobile.min.js。由于jMobile是自带一套UI的框架，<br>所以第一个css文件是必须要包含进来的。</p>
<p>一个简单的jMobile页面包括三个部分——header、content和footer。通过data-role来实现，比如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">data-role</span>=<span class="value">"header"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>头<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">data-role</span>=<span class="value">"content"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>主体<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">data-role</span>=<span class="value">"footer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>底部<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，jQuery Mobile 依赖 HTML5 data-* 属性来支持各种 UI 元素、过渡和页面结构：<br>data-role=”page” 是在浏览器中显示的页面。<br>data-role=”header” 是在页面顶部创建的工具条 (通常用于标题或者搜索按钮)<br>data-role=”content” 定义了页面的内容，比如文本， 图片，表单，按钮等。<br>data-role=”footer” 用于创建页面底部工具条。<br>在这些容器中你可以添加任何 HTML 元素 - 段落, 图片, 标题, 列表等。</p>
<p>在页面的切换方式使用data-transition来定义，可以包括从上到下滑动，从左到右滑动，抛出页面，弹窗等多种形式。<br>在导航元素上，data-role=”navbar”加图标data-icon可以实现导航栏。每一个的导航元素可以通过class=”ui-btn-active”<br>来实现按钮激活状态。在布局方面，可以使用网格和可折叠板块来实现复杂布局。如需创建一个可折叠的内容块，需要为<br>容器添加 data-role=”collapsible” 属性。在容器（div）内，添加一个标题元素（H1-H6），后跟您想要进行扩展的 HTML<br>标记：</p>
<p>一个默认展开的折叠板：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">data-role</span>=<span class="value">"collapsible"</span> <span class="attribute">data-collapsed</span>=<span class="value">"false"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>点击我 - 我可以折叠!<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>I'm 现在我默认是展开的。<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个默认折叠的折叠版：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">data-role</span>=<span class="value">"collapsible"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>点击我 - 我可以折叠!<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>我是可折叠的内容。<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>jMobile的列表使用非常有特色。可以在列表中添加图标。默认的列表用法如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">data-role</span>=<span class="value">"listview"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>列表项<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>列表项<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>列表项<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>列表样式的圆角和边缘，使用 data-inset=”true” 属性设置<br>列表项也可以转化为列表分割项，用来组织列表，使列表项成组。<br>指定列表分割，给列表项 li 元素添加 data-role=”list-divider” 属性即可。</p>
<p>jquery Mobile提供一个非常简单的方法，实现客户端搜索功能，筛选列表的选项。只需添加 data-filter=”true” 属性即可:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="tag">ul</span> data-role=<span class="string">"listview"</span> data-<span class="attribute">filter</span>=<span class="string">"true"</span>&gt;&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>以上的介绍时关于jMobile的最基础用法，我们在下一篇将着重介绍表单基础和事件处理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>简介：<br>jQuery Mobile 是用于创建移动 Web应用的前端开发框架，可以应用于智能手机与平板电脑。是一个比较好用的前端框架。<br>jMobile适用于ios，android，black berry，windows phone等主流移动终端操作系统。<br>]]>
    
    </summary>
    
      <category term="前端开发" scheme="http://hugzh.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用哈希密码的安全性问题]]></title>
    <link href="http://hugzh.github.io/2014/11/21/problem-of-hash/"/>
    <id>http://hugzh.github.io/2014/11/21/problem-of-hash/</id>
    <published>2014-11-20T16:00:00.000Z</published>
    <updated>2016-01-04T06:26:33.159Z</updated>
    <content type="html"><![CDATA[<h2 id="一、_哈希密码">一、 哈希密码</h2><p>哈希是一种散列函数，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。<br>在密码学当中，HASH主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码里,叫做HASH值. 也可以说，hash就是找到一种数据内容和数据存放地址之间的映射关系。MD4和MD5是哈希密码的主要算法。<br><a id="more"></a></p>
<h2 id="二、_哈希密码的安全隐患">二、 哈希密码的安全隐患</h2><p>哈希函数本来是不可逆的函数，也就是说知道了哈希值也不能使用算法把原文推算出来。但是由于常见字符串的哈希值，可以通过查表的方式找到原文，比如彩虹表等等。所以目前还是存在一些数据库可以查到简单字符串的哈希值的，这样就造成了用哈希函数加密的密文安全性不可靠。</p>
<h2 id="三、_哈希盐值">三、 哈希盐值</h2><p>盐值就是程序随机产生的随机字符串组合。<br>加盐后的散列值，可以极大的降低由于用户数据被盗而带来的密码泄漏风险，即使通过彩虹表寻找到了散列后的数值所对应的原始内容，但是由于经过了加盐，插入的字符串扰乱了真正的密码，使得获得真实密码的概率大大降低。那么它的原理是什么呢？<br>查表法和彩虹表只有在所有密码都以相同方式进行哈希加密时才有效。如果两个用户密码相同，那么他们密码的哈希值也是相同的。我们可以通过“随机化”哈希来阻止这类攻击，于是当相同的密码被哈希两次之后，得到的值就不相同了。为了校验密码是否正确，我们需要储存盐值。通常和密码哈希值一起存放在账户数据库中，或者直接存为哈希字符串的一部分。<br>加盐值的时候需要注意以下几点：<br>1、 盐值不能重复。两个相同的密码会得到相同的哈希值。攻击者可以使用反向查表法对每个值进行字典攻击，只需要把盐值应用到每个猜测的密码上再进行哈希即可。如果盐值被硬编码到某个流行的软件里，可以专门为这个软件制作查询表和彩虹表，那么破解它生成的哈希值就变得很简单了。用户创建账户或每次修改密码时，都应该重新生成新的盐值进行加密。<br>2、 盐值不能太短。如果盐值太短，攻击者可以构造一个查询表包含所有可能的盐值。以只有3个ASCII字符的盐值为例，一共有95x95x95=857,375种可能。同样地，用户名也不应该被用作盐值。尽管在一个网站中用户名是唯一的，但是它们是可预测的，并且经常重复用于其他服务中。攻击者可以针对常见用户名构建查询表，然后对用户名盐值哈希发起进攻。<br>为了使攻击者无法构造包含所有可能盐值的查询表，盐值必须足够长。一个好的做法是使用和哈希函数输出的字符串等长的盐值，比如SHA256算法的输出是256bits(32 bytes)，那么盐值也至少应该是32个随机字节。<br>3、 不使用组合哈希。人们经常不由自主地认为将不同的哈希函数组合起来，结果会更加安全。实际上这样做几乎没有好处，仅仅造成了函数之间互相影响的问题，甚至有时候会变得更加不安全。</p>
<h2 id="四、哈希加盐存储密码的步骤">四、哈希加盐存储密码的步骤</h2><p>存储密码的步骤<br>1. 使用CSPRNG（伪随机数生成器）生成一个长度足够的盐值<br>2. 将盐值混入密码，并使用标准的加密哈希函数进行加密，如MD5<br>3. 把哈希值和盐值一起存入数据库中对应此用户的那条记录<br>校验密码的步骤<br>1. 从数据库取出用户的密码哈希值和对应盐值<br>2. 将盐值混入用户输入的密码，并且使用同样的哈希函数进行加密<br>3. 比较上一步的结果和数据库储存的哈希值是否相同，如果相同那么密码正确，反之密码错误</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、_哈希密码">一、 哈希密码</h2><p>哈希是一种散列函数，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。<br>在密码学当中，HASH主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码里,叫做HASH值. 也可以说，hash就是找到一种数据内容和数据存放地址之间的映射关系。MD4和MD5是哈希密码的主要算法。<br>]]>
    
    </summary>
    
      <category term="其它" scheme="http://hugzh.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[文件上传插件Uploadify的简单介绍]]></title>
    <link href="http://hugzh.github.io/2014/10/01/uploadyfy-introduce/"/>
    <id>http://hugzh.github.io/2014/10/01/uploadyfy-introduce/</id>
    <published>2014-09-30T16:00:00.000Z</published>
    <updated>2016-01-04T13:07:18.270Z</updated>
    <content type="html"><![CDATA[<p>熟悉使用php的人一定会对php文件上传不陌生，多文件上传以及重命名等都是文件上传的重要应用，我在这里介绍一个ajax+jQuery的插件，这个插件比较好的地方就是前端的效果比较炫酷，使用比较简单，大大简化了代码复杂度。uploadify.swf是插件的核心部分，（下载地址:<a href="http://www.uploadify.com/download/）" target="_blank" rel="external">http://www.uploadify.com/download/）</a> 前端的效果主要由jquery.uploadify.js实现，所以这两个文件要包含进前端的源代码。我在这里主要是想介绍前端的接口函数以及php后台里面的文件重命名的技巧。<br>前端比较简单，主要是文件包含以及文件上传表单和接口函数。需要包含这几个js文件<br><a id="more"></a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"jquery.min.js"</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"jquery.uploadify.min.js"</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>还有就是接口函数:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">$(<span class="string">'#file_upload'</span>).uploadify(&#123;</span><br><span class="line"><span class="string">'swf'</span> : <span class="string">'uploadify.swf'</span>,</span><br><span class="line"><span class="string">'uploader'</span> : <span class="string">'uploadify.php'</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接口函数里面的uploadify()是属于插件uploadify.swf的函数，所以必须先把文件包含进去。<br>前端body部分的代码如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"queue"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;input <span class="property">id</span>=<span class="string">"file_upload"</span> <span class="property">name</span>=<span class="string">"file_upload"</span> type=<span class="string">"file"</span> multiple=<span class="string">"true"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>后台部分的php代码比较简单，比较关键的部分就是重命名，根据接口，后台处理函数命名为uploadify.php。由于多文件上传可以在一秒钟之内完成多个文件上传，所以把时间戳作为唯一命名的做法需要注意的地方就是不能把time函数作为字符串，这样会导致字符串相同，如此便没办法上传多个文件，我在这里的解决办法就是使用microtime()生成微秒级的时间，再转化为字符串，这样每个文件的命名就会唯一了。主要代码如下：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// Define a destination</span><br><span class="line"><span class="variable">$targetFolder</span> = <span class="string">'/uploads'</span>; // Relative <span class="keyword">to</span> the root</span><br><span class="line"></span><br><span class="line">/*<span class="variable">$verifyToken</span> = md5(<span class="string">'unique_salt'</span> . $_POST[<span class="string">'timestamp'</span>]);*/</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>($_FILES) &amp;amp;&amp;amp; $_POST[<span class="string">'token'</span>] == <span class="variable">$verifyToken</span>) &#123;</span><br><span class="line"><span class="variable">$tempFile</span> = $_FILES[<span class="string">'Filedata'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line"><span class="variable">$targetPath</span> = $_SERVER[<span class="string">'DOCUMENT_ROOT'</span>] . <span class="variable">$targetFolder</span>;</span><br><span class="line"></span><br><span class="line">/*文件以时间戳重命名，这<span class="number">6</span>行代码为个人添加，可以删除，删除之后保持文件原名*/</span><br><span class="line"><span class="variable">$date</span> = microtime();//取得当前时间</span><br><span class="line"><span class="variable">$nodot</span> = explode(<span class="string">"."</span>,<span class="variable">$date</span>);//切割掉 microtime()函数返回数据格式 <span class="number">0</span>.<span class="number">25139300</span> <span class="number">1138197510</span>中的点</span><br><span class="line"><span class="variable">$namestr</span> = str_replace(<span class="string">' '</span>,<span class="string">''</span>,<span class="variable">$nodot</span>[<span class="number">1</span>]);//去除空格</span><br><span class="line"><span class="variable">$uptype</span> = explode(<span class="string">"."</span>, $_FILES[<span class="string">"Filedata"</span>][<span class="string">"name"</span>]);//分割留下文件类型</span><br><span class="line"><span class="variable">$newname</span> = <span class="variable">$namestr</span>.<span class="string">"."</span>.<span class="variable">$uptype</span>[<span class="number">1</span>];</span><br><span class="line">$_FILES[<span class="string">"Filedata"</span>][<span class="string">"name"</span>] = <span class="variable">$newname</span>;//重命名</span><br><span class="line"><span class="variable">$targetFile</span> = rtrim(<span class="variable">$targetPath</span>,<span class="string">'/'</span>).<span class="string">'/'</span>.iconv(<span class="string">"UTF-8"</span>,<span class="string">"GB2312"</span>,$_FILES[<span class="string">"Filedata"</span>][<span class="string">"name"</span>]);</span><br><span class="line"></span><br><span class="line">// Validate the file type</span><br><span class="line"><span class="variable">$fileTypes</span> = array(<span class="string">'jpg'</span>,<span class="string">'jpeg'</span>,<span class="string">'pjpeg'</span>,<span class="string">'gif'</span>,<span class="string">'png'</span>); // File extensions</span><br><span class="line"><span class="variable">$fileParts</span> = pathinfo($_FILES[<span class="string">'Filedata'</span>][<span class="string">'name'</span>]);</span><br><span class="line"></span><br><span class="line">if (in_array(<span class="variable">$fileParts</span>[<span class="string">'extension'</span>],<span class="variable">$fileTypes</span>)) &#123;</span><br><span class="line">move_uploaded_file(<span class="variable">$tempFile</span>,<span class="variable">$targetFile</span>);</span><br><span class="line">echo <span class="string">'1'</span>;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo <span class="string">'Invalid file type.'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>熟悉使用php的人一定会对php文件上传不陌生，多文件上传以及重命名等都是文件上传的重要应用，我在这里介绍一个ajax+jQuery的插件，这个插件比较好的地方就是前端的效果比较炫酷，使用比较简单，大大简化了代码复杂度。uploadify.swf是插件的核心部分，（下载地址:<a href="http://www.uploadify.com/download/）">http://www.uploadify.com/download/）</a> 前端的效果主要由jquery.uploadify.js实现，所以这两个文件要包含进前端的源代码。我在这里主要是想介绍前端的接口函数以及php后台里面的文件重命名的技巧。<br>前端比较简单，主要是文件包含以及文件上传表单和接口函数。需要包含这几个js文件<br>]]>
    
    </summary>
    
      <category term="php" scheme="http://hugzh.github.io/categories/php/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Php验证码制作]]></title>
    <link href="http://hugzh.github.io/2014/09/17/yanzhengma-php/"/>
    <id>http://hugzh.github.io/2014/09/17/yanzhengma-php/</id>
    <published>2014-09-16T16:00:00.000Z</published>
    <updated>2016-01-04T06:26:46.615Z</updated>
    <content type="html"><![CDATA[<p>关于网页制作中的验证码部分是一个比较有趣的知识点，验证码的制作主要是基于PHP的图片处理拓展功能。 验证码制作的一般流程是：<br>1、创建验证码显示的底图<br>2、列出所有可能用到的字符内容以及字体颜色<br>3、随机截取部分（4或者5个）字符作为验证码输出<br>4、确定验证码显示的角度以及坐标<br>5、增加干扰元素（点和线条等）<br>6、php输出图片，并在脚本及时地destroy掉图片<br><a id="more"></a><br>然后是一个值得注意的地方就是，一般来说验证码不应该出现容易混淆的字符，比如l和1,2和z,0和o等等，这是作为一个开发者从用户体验的角度来说需要注意的地方，另外就是干扰元素的颜色不应该使用鲜艳的颜色，一般来说颜色RGB值在50之后比较稳妥。<br>以下是我的php代码，命名为yanzhengma.php:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$image</span> = imagecreatetruecolor(<span class="number">100</span>,<span class="number">30</span>);<span class="comment">//100x30的图片生成</span></span><br><span class="line"><span class="variable">$bgcolor</span> = imagecolorallocate(<span class="variable">$image</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>);<span class="comment">//白色底色</span></span><br><span class="line">imagefill(<span class="variable">$image</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="variable">$bgcolor</span>);`</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存验证码内容便于服务器验证</span></span><br><span class="line"><span class="variable">$capchcode</span>=<span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>;<span class="variable">$i</span>&amp;lt;<span class="number">4</span>;<span class="variable">$i</span>++)&#123;</span><br><span class="line"><span class="variable">$fontsize</span>=<span class="number">12</span>;</span><br><span class="line"><span class="variable">$fontcolor</span> = imagecolorallocate(<span class="variable">$image</span>,rand(<span class="number">0</span>,<span class="number">120</span>),rand(<span class="number">0</span>,<span class="number">120</span>),rand(<span class="number">0</span>,<span class="number">120</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//$fontcotent = rand(0,9);//产生随机数字</span></span><br><span class="line"><span class="variable">$data</span> = <span class="string">'ABCDEHJKYSWTRabcdefghjkmnpqstuwsy23456789'</span>;</span><br><span class="line"><span class="variable">$fontcotent</span> = substr(<span class="variable">$data</span>,rand(<span class="number">0</span>,strlen(<span class="variable">$data</span>)),<span class="number">1</span>);<span class="comment">//随机截取一个字符</span></span><br><span class="line"><span class="variable">$capchcode</span> .= <span class="variable">$fontcotent</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$x</span> = (<span class="variable">$i</span>*<span class="number">100</span>/<span class="number">4</span>)+rand(<span class="number">5</span>,<span class="number">10</span>);<span class="comment">//定义内容的x坐标、y坐标，随机</span></span><br><span class="line"><span class="variable">$y</span> = rand(<span class="number">5</span>,<span class="number">12</span>);</span><br><span class="line">imagestring(<span class="variable">$image</span>,<span class="variable">$fontsize</span>,<span class="variable">$x</span>,<span class="variable">$y</span>,<span class="variable">$fontcotent</span>,<span class="variable">$fontcolor</span>);<span class="comment">//产生字符送到图片</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">'authcode'</span>] = <span class="variable">$capchcode</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加点干扰元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>;<span class="variable">$i</span>&amp;lt;<span class="number">300</span>;<span class="variable">$i</span>++)&#123;</span><br><span class="line"><span class="variable">$pointcolor</span> = imagecolorallocate(<span class="variable">$image</span>,rand(<span class="number">50</span>,<span class="number">200</span>),rand(<span class="number">50</span>,<span class="number">200</span>),rand(<span class="number">50</span>,<span class="number">200</span>));</span><br><span class="line">imagesetpixel(<span class="variable">$image</span>,rand(<span class="number">1</span>,<span class="number">99</span>),rand(<span class="number">1</span>,<span class="number">29</span>),<span class="variable">$pointcolor</span>);<span class="comment">//点元素分布</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加线条干扰</span></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>;<span class="variable">$i</span>&amp;lt;<span class="number">3</span>;<span class="variable">$i</span>++)&#123;</span><br><span class="line"><span class="variable">$linecolor</span> = imagecolorallocate(<span class="variable">$image</span>,rand(<span class="number">80</span>,<span class="number">220</span>),rand(<span class="number">80</span>,<span class="number">220</span>),rand(<span class="number">80</span>,<span class="number">220</span>));</span><br><span class="line">imageline(<span class="variable">$image</span>,rand(<span class="number">1</span>,<span class="number">99</span>),rand(<span class="number">1</span>,<span class="number">29</span>),rand(<span class="number">1</span>,<span class="number">99</span>),rand(<span class="number">1</span>,<span class="number">29</span>),<span class="variable">$linecolor</span>);<span class="comment">//线条元素分布,两点确定一条直线</span></span><br><span class="line">&#125;</span><br><span class="line">header(<span class="string">'content-type:image/png'</span>);</span><br><span class="line">imagepng(<span class="variable">$image</span>);</span><br><span class="line">imagedestroy(<span class="variable">$image</span>);</span><br></pre></td></tr></table></figure>
<p>总的来说，简单验证码的制作并不难，如果要做一些gif类型的验证码或者一些更加个性化的验证码就需要多花费一些时间去查找相关资料了，这里不做介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于网页制作中的验证码部分是一个比较有趣的知识点，验证码的制作主要是基于PHP的图片处理拓展功能。 验证码制作的一般流程是：<br>1、创建验证码显示的底图<br>2、列出所有可能用到的字符内容以及字体颜色<br>3、随机截取部分（4或者5个）字符作为验证码输出<br>4、确定验证码显示的角度以及坐标<br>5、增加干扰元素（点和线条等）<br>6、php输出图片，并在脚本及时地destroy掉图片<br>]]>
    
    </summary>
    
      <category term="php" scheme="http://hugzh.github.io/categories/php/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Haskell初接触感悟]]></title>
    <link href="http://hugzh.github.io/2014/09/03/haskell-introduce/"/>
    <id>http://hugzh.github.io/2014/09/03/haskell-introduce/</id>
    <published>2014-09-02T16:00:00.000Z</published>
    <updated>2016-01-04T06:25:39.586Z</updated>
    <content type="html"><![CDATA[<p>最近选修函数程序设计这门选修课，初步接触到函数式编程语言 Haskell 的思想，在学习的过程中有意识地拿它跟Python去做一些比较，发现两者之间在元组Tuple以及List这种灵活数据类型上面有比较大的接近。但是在设计思想以及语法上面，两者又存在较大差别。先说说Haskell语言是什么东西：<br><a id="more"></a><br>Haskell 是一门纯函数式编程语言 (purely functional programming language)。在命令式语言中执行操作需要给电脑安排一组命令，随着命令的执行，状态就会随之发生改变。例如你指派变量 a 的值为 5，而随后做了其它一些事情之后 a 就可能变成的其它值。有控制流程 (control flow)，你就可以重复执行操作。然而在纯函数式编程语言中，你不是像命令式语言那样命令电脑“要做什么”，而是通过用函数来描述出问题“是什么”，如“阶乘是指从1到某个数的乘积”，”一个串列中数字的和”是指把第一个数字跟剩余数字的和相加。你用宣告函数是什么的形式来写程序。另外，变量 (variable) 一旦被指定，就不可以更改了，你已经说了 a 就是 5，就不能再另说 a 是别的什么数。（译注：其实用 variable 来表达造成字义的 overloading，会让人联想到 imperative languages 中 variable 是代表状态，但在 functional languages 中 variable 是相近于数学中使用的 variable。x=5 代表 x 就是 5，不是说 x 在 5 这个状态。) 所以说，在纯函数式编程语言中的函数能做的唯一事情就是利用引数计算结果，不会产生所谓的”副作用 (side effect)” (译注：也就是改变非函数内部的状态，像是 imperative languages 里面动到 global variable 就是 side effect)。一开始会觉得这限制很大，不过这也是他的优点所在：若以同样的参数调用同一个函数两次，得到的结果一定是相同。这被称作“引用透明 (Referential Transparency)” (译注：这就跟数学上函数的使用一样)。如此一来编译器就可以理解程序的行为，你也很容易就能验证一个函数的正确性，继而可以将一些简单的函数组合成更复杂的函数。(来源:《Learn You a Haskell For Great Good》)也就是说，面向对象或者基于过程的程序设计语言和函数式编程语言是存在本质区别的。<br>Haskell语言有什么特点呢，要记的特点（或者说优势）还是比较多的，这里介绍一两个我刚刚理解的方面。第一，灵活的数据结构——List和Tuple，关于这两种数据结构是有比较多的内建函数需要去掌握的，比如：head 返回一个 List 的头部，也就是 List 的首个元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; head [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>`；又比如：take 返回一个 List 的前几个元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">3</span> [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">1</span> [<span class="number">3</span>,<span class="number">9</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">5</span> [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">0</span> [<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>在这里我想要分享的是关于模式匹配这一章，模式匹配是Haskell最大的特点之一，也是学习Haskell的最大难点之一（个人感觉，目前还没有完全搞懂）。<br>函数的模式匹配在递归函数的运用还是比较多的，除了一种显示的匹配（类似于C语言里面的CASE）如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sayMe</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">sayMe</span> <span class="number">1</span> = <span class="string">"One!"</span></span><br><span class="line"><span class="title">sayMe</span> <span class="number">2</span> = <span class="string">"Two!"</span></span><br><span class="line"><span class="title">sayMe</span> <span class="number">3</span> = <span class="string">"Three!"</span></span><br><span class="line"><span class="title">sayMe</span> <span class="number">4</span> = <span class="string">"Four!"</span></span><br><span class="line"><span class="title">sayMe</span> <span class="number">5</span> = <span class="string">"Five!"</span></span><br><span class="line"><span class="title">sayMe</span> x = <span class="string">"Not between 1 and 5"</span></span><br></pre></td></tr></table></figure>
<p>除此之外，比较有用的模式匹配就是x:xs这种模式，这在函数递归里面非常重要。而函数递归有事Haskell的核心内容，因此，模式匹配也就是Haskell的核心内容。以下是一个递归求和的例子</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum'</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">sum'</span> (x:xs) = x + sum' xs</span><br></pre></td></tr></table></figure>
<p>在这段代码里面，现匹配列表为空的情况，余下的情况，提取出列表头部x，x加上余下列表的递归sum’函数，这样就会一直把列表里面的元素相加，知道列表为空，也就是边界条件。这就是模式匹配在函数递归里面的简单应用。至于更强大的函数功能，大家可以参考网上教程 <a href="http://learnyouahaskell-zh-tw.csie.org/zh-cn/chapters.html" target="_blank" rel="external">http://learnyouahaskell-zh-tw.csie.org/zh-cn/chapters.html</a> 去更深入的学习Haskell的精髓。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近选修函数程序设计这门选修课，初步接触到函数式编程语言 Haskell 的思想，在学习的过程中有意识地拿它跟Python去做一些比较，发现两者之间在元组Tuple以及List这种灵活数据类型上面有比较大的接近。但是在设计思想以及语法上面，两者又存在较大差别。先说说Haskell语言是什么东西：<br>]]>
    
    </summary>
    
      <category term="其它" scheme="http://hugzh.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
</feed>
